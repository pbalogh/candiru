{"version":3,"sources":["webpack:///webpack/bootstrap b324dc574cfedf5003ac","webpack:///./js/factories/nonterminalfactory.js","webpack:///./js/factories/tokenfactory.js","webpack:///./js/lexer.js","webpack:///./js/parser.js","webpack:///./js/symbol.js","webpack:///./js/nonterminal.js","webpack:///./js/token.js","webpack:///./js/visitors/xmljsonvisitor.js","webpack:///./js/visitors/xmlparsetimevisitor.js","webpack:///./js/mathius.js","webpack:///./js/visitors/booleanjsonvisitor.js","webpack:///./js/xmlius.js","webpack:///./js/boolius.js"],"names":["NonterminalFactory","grammarObject","nonterminals","grammarRule","nonterminal","length","lookaheadTokensToAvoid","push","TokenFactory","tokenDefinitions","tokens","tokenDefinition","makeToken","regex","name","ignore","token","IGNORE","makeTokenFromDefinition","Lexer","tokenFactory","getTokens","sentenceToTokenize","arrayOfTokens","startingLetter","stringToMatch","foundAMatchSomewhere","lengthOfMatch","matchYourselfToStartOfThisStringAndAddSelfToArray","Error","charAt","Parser","nonterminalFactory","getNonterminals","state","sentenceOfSymbols","resolvedSymbols","symbol","shift","constructor","type","_stringIMatched","nonterm","seriesOfSymbolsIAbsorbedAndReplaced","traceString","parseTimeVisitor","resolveIdentifiersToTypes","arrayOfSymbolsMatchedBeforeMe","finished","madeAMatch","getSimpleStringForSentence","slice","stringAndPosition","getLastTokenDescriptionOfSymbol","errorString","string","position","console","log","getStringAndPositionOfTokensOfSymbol","symbolsMatched","earliestPosition","start","tokenString","kid","Symbol","_name","someName","Nonterminal","seriesOfSymbolsIMustMatch","wildcardMode","join","returnString","toString","evaluationVisitor","execute","sentenceOfSymbolsToMatch","care","toStringSimple","sentenceOfSymbolsToMatchClone","seriesOfSymbolsIMustMatchClone","done","symbolThatBreaksWildcard","mySymbol","theirSymbol","getFrozenClone","theirNextSymbol","indexOf","frozenClone","Token","regexOfThingsIMustMatch","leng","stringIActuallyMatched","startIndex","_type","_length","_ignore","symbolArray","startingIndex","match","exec","index","frozenToken","substring","XMLJSONVisitor","newstate","thingToEvaluate","ob","value","getValue","condition","children","optionalAttributes","getAttributes","attributes","consolidateChildrenThatAreTokens","i","arrayOfSymbolsThatMightBeTokens","symbolChildrenOnly","runningStringOfTokenText","tokenConsolidatingStrings","makeTokenWrappingString","stringToWrap","newSymbol","childOfXMLNode","atts","val","returnAtts","nonterminalOrToken","returnVal","error","commentstring","JSON","stringify","toUpperCase","module","exports","XMLParseTimeVisitor","verifyOpeningAndCloseTagsMatch","verifyTagContentIsLegal","verifyAttributeContentIsLegal","openTagName","getTagName","closeTagName","Mathius","visitor","NumericVisitor","lexer","parser","setState","sentenceToParse","sentenceOfTokens","tokenize","parseTree","parse","evaluateParseTree","e","result","visit","window","BooleanJSONVisitor","getBoolean","getNameForOperator","operatorSymbol","XMLius","xmlParseTimeVisitor","Boolius","alert"],"mappings":"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","file":"boolius.bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/build\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 12);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap b324dc574cfedf5003ac","import Nonterminal from '../nonterminal';\n\nexport default class NonterminalFactory{\n  constructor(grammarObject){\n    this.grammarObject = grammarObject;\n    this.nonterminals = [];\n    for( let grammarRule of grammarObject )\n    {\n      let nonterminal = new Nonterminal( grammarRule[0], grammarRule[1] );\n      if( grammarRule.length > 2 ) // it has an array of lookaheadTokensToAvoid\n      {\n        nonterminal.lookaheadTokensToAvoid = grammarRule[2];\n      }\n      this.nonterminals.push( nonterminal );\n    }\n  }\n\n  getNonterminals(){\n    return this.nonterminals;\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ./js/factories/nonterminalfactory.js","import Token from '../token';\n\nexport default class TokenFactory{\n   constructor( tokenDefinitions ){\n     this.tokens = [];\n     this.tokenDefinitions = tokenDefinitions;\n   }\n\n   makeTokenFromDefinition( tokenDefinition ){\n     return this.makeToken( tokenDefinition[0], tokenDefinition[1], tokenDefinition.length > 2 ? tokenDefinition[2] : false );\n   }\n    makeToken( regex, name, ignore = false )\n    {\n      var token = new Token( regex, name, 0, \"\", ignore );\n      this.tokens.push( token );\n      return token;\n    }\n\n    getTokens()\n    {\n      let IGNORE = true;\n\n      for( let tokenDefinition of this.tokenDefinitions )\n      {\n        this.makeTokenFromDefinition( tokenDefinition )\n      }\n      return this.tokens;\n\n    }\n}\n\n\n// WEBPACK FOOTER //\n// ./js/factories/tokenfactory.js","import TokenFactory from './factories/tokenfactory';\n\nexport default class Lexer{\n\n  constructor( tokenDefinitions ){\n    let tokenFactory = new TokenFactory( tokenDefinitions );\n    this.tokens = tokenFactory.getTokens();\n  }\n\n  tokenize( sentenceToTokenize ){\n    let arrayOfTokens = [];\n    var startingLetter = 0;\n    let stringToMatch = sentenceToTokenize; // want to keep original sentence for length/reference\n\n    while(  startingLetter < sentenceToTokenize.length )\n    {\n      let foundAMatchSomewhere = false;\n      for (var token of this.tokens)\n      {\n        let lengthOfMatch = 0;\n        [lengthOfMatch, arrayOfTokens, stringToMatch ] =\n        token.matchYourselfToStartOfThisStringAndAddSelfToArray( arrayOfTokens, stringToMatch, startingLetter );\n        if( lengthOfMatch > 0 )\n        {\n          foundAMatchSomewhere = true;\n          startingLetter += lengthOfMatch;\n          break; // START AT THE TOP OF OUR TOKEN LIST!!\n          // That is IMPORTANT.\n          // Some of our later tokens, like IDENT, are catch-alls that will greedily snatch up keywords like NOT\n        }\n      }\n      if(! foundAMatchSomewhere)\n      {\n        throw new Error(\"Illegal character \" + stringToMatch.charAt(0) + \" at position \" + startingLetter );\n      }\n    }\n    return arrayOfTokens;\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ./js/lexer.js","import Symbol from './symbol'\nimport Nonterminal from './nonterminal'\nimport NonterminalFactory from '../js/factories/nonterminalfactory';\n\nexport default class Parser{\n  constructor( grammarObject ){\n    let nonterminalFactory = new NonterminalFactory( grammarObject );\n    this.nonterminals = nonterminalFactory.getNonterminals();\n    this.state = {};\n  }\n\n  setState( state ) {\n    this.state = state; // generally just a lookup table for declared/initialized variables\n  }\n\n  // What does this do? Well, if there's a token of type IDENT, it's a variable.\n  // If that variable hasn't been declared, then how are we supposed to know what type it is?\n  // We'll be strongly-typed so that even a simple grammar can work effectively.\n  resolveIdentifiersToTypes( sentenceOfSymbols ){\n    let resolvedSymbols = [];\n    while( sentenceOfSymbols.length > 0 )\n    {\n      let symbol = sentenceOfSymbols.shift();\n      // we only care about tokens\n      if( symbol.constructor.name == \"Token\")\n      {\n        if( symbol.type == \"IDENT\")\n        {\n          // so now we can wrap our variable in the appropriate nonterminal type\n          if( typeof this.state[symbol._stringIMatched] == \"boolean\")\n          {\n            let nonterm = new Nonterminal( [\"IDENT\"], \"BOOLEAN\" );\n            nonterm.seriesOfSymbolsIAbsorbedAndReplaced = [ symbol ];\n            symbol = nonterm;\n          }\n          resolvedSymbols.push( symbol );\n          continue;\n        }\n        else\n        {\n          resolvedSymbols.push( symbol );\n        }\n      }\n      else\n      {\n        resolvedSymbols.push( symbol );\n      }\n    }\n    return resolvedSymbols;\n  }\n\n  getSimpleStringForSentence( sentenceOfSymbols ) {\n          let traceString = \"\";\n          for( var symbol of sentenceOfSymbols )\n          {\n            traceString += symbol.type + \" \";\n          }\n          return traceString;\n  }\n\n  parse( sentenceOfSymbols, parseTimeVisitor = null ){\n\n    sentenceOfSymbols = this.resolveIdentifiersToTypes( sentenceOfSymbols );\n    let arrayOfSymbolsMatchedBeforeMe = [];\n    let lengthOfMatch = 0;\n    let finished = false;\n    while( !finished ){\n        let madeAMatch = false;\n        //console.log(\"------- Starting at top of nonterminals list -------\" );\n        for( var nonterminal of this.nonterminals )\n        {\n          // we'll go through the input sentence\n          // and try to match this nonterminal to the beginning of it.\n          // if there's a match, then our nonterminal will be part of the future sentence.\n          // (replacing whatever portion it matched.)\n          // if there's no match, we want to pop a symbol off the start of the input sentence\n          // (moving it into the future sentence, since we )\n          let traceString = this.getSimpleStringForSentence( sentenceOfSymbols );\n          while( sentenceOfSymbols.length > 0 )\n          {\n            //console.log(\"USING nonterminal \" + nonterminal.toStringSimple() + \" to look at \" + traceString );\n            [lengthOfMatch, arrayOfSymbolsMatchedBeforeMe, sentenceOfSymbols ] =\n            nonterminal.matchYourselfToStartOfThisStringAndAddSelfToArray( arrayOfSymbolsMatchedBeforeMe, sentenceOfSymbols, parseTimeVisitor );\n\n            // if we matched, then the good news is, the input sentence is now changed\n            // so we don't have to worry about changing it.\n            // otherwise, we didn't match the beginning of the input sentence,\n            // so let's pop a symbol off it and try again.\n            if( lengthOfMatch == 0 )\n            {\n\n              arrayOfSymbolsMatchedBeforeMe.push( sentenceOfSymbols.shift() );\n              traceString = this.getSimpleStringForSentence( sentenceOfSymbols );\n            }\n            else\n            {\n              //console.log(\"MATCHED nonterminal \" + nonterminal.toStringSimple() + \" to sentence \" + traceString );\n              madeAMatch = true;\n            }\n          }\n\n          // ok, we did what we could. let's gather our processed items and hand them to the next nonterminal to process.\n          sentenceOfSymbols = arrayOfSymbolsMatchedBeforeMe.slice(0); // make sure we copy the items over and keep these two arrays discrete!\n          arrayOfSymbolsMatchedBeforeMe = [];\n          //console.log(\"sentenceOfSymbols is now \" + sentenceOfSymbols );\n          // are we done? if so, then don't bother looking at other nonterminals!\n          if( sentenceOfSymbols.length <= 1 )\n          {\n            finished == true;\n            break;\n          }\n\n          // we need to start from the top of our nonterminals if we made a match!\n          // order MATTERS.\n          if( madeAMatch ) break;\n\n        } // end of cycling through our array of nonterminals\n\n        // what if we made it through all our nonterminals and didn't make a match?\n        // error, that's what!\n        if( ! madeAMatch )\n        {\n          let stringAndPosition = this.getLastTokenDescriptionOfSymbol( sentenceOfSymbols[0] );\n          let errorString = \"\\nSyntax error:\" + stringAndPosition.string + \" at position \" + stringAndPosition.position;\n          throw new Error( errorString );\n\n          finished = true;\n        }\n\n        if( sentenceOfSymbols.length <= 1 )\n        {\n          finished = true;\n        }\n        console.log(\"finished is \" + finished );\n    }  // end of our \"while\" loop going through sentenceOfSymbols until finished == true\n\n    return sentenceOfSymbols;\n  }\n\n  getLastTokenDescriptionOfSymbol( symbol ){\n     return this.getStringAndPositionOfTokensOfSymbol( symbol.symbolsMatched[ symbol.symbolsMatched.length - 1] );\n  }\n\n  getStringAndPositionOfTokensOfSymbol( symbol, earliestPosition = 100000000 ){\n    if (symbol.constructor.name == \"Token\" )\n    {\n      return { string: symbol._stringIMatched, position: symbol.start };\n    }\n    else if (symbol.constructor.name == \"Nonterminal\" )\n    {\n      let tokenString = \"\";\n      for( let kid of symbol.symbolsMatched )\n      {\n        let stringAndPosition = this.getStringAndPositionOfTokensOfSymbol( kid, earliestPosition );\n        tokenString += stringAndPosition.string;\n        if( stringAndPosition.position < earliestPosition )\n        {\n          earliestPosition = stringAndPosition.position;\n        }\n      }\n      return { string: tokenString, position: earliestPosition };\n    }\n  }\n\n\n}\n\n\n// WEBPACK FOOTER //\n// ./js/parser.js","export default class Symbol{\n  constructor(){\n\n  }\n  get name(){\n    return this._name;\n  }\n  set name( someName ){\n    this._name = someName;\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ./js/symbol.js","import Symbol from './symbol'\n\nexport default class Nonterminal extends Symbol{\n\n    constructor( seriesOfSymbolsIMustMatch, type ){\n      super();\n      this.seriesOfSymbolsIMustMatch  = seriesOfSymbolsIMustMatch;\n      this.type                       = type;\n      this.seriesOfSymbolsIAbsorbedAndReplaced = [];\n      this.wildcardMode = false;\n      this.lookaheadTokensToAvoid = null;\n    }\n\n    toStringSimple(){\n      return this.seriesOfSymbolsIMustMatch.join( ' ' );\n    }\n\n    toString(){\n      let returnString = this.type + \" (\";\n\n      for( var symbol of this.seriesOfSymbolsIAbsorbedAndReplaced )\n      {\n        returnString += \" \" + symbol.toString();\n      }\n      return returnString;\n    }\n\n    get symbolsMatched(){\n      return this.seriesOfSymbolsIAbsorbedAndReplaced;\n    }\n\n    get length(){\n      return this.seriesOfSymbolsIAbsorbedAndReplaced.length;\n    }\n\n    visit( evaluationVisitor ) {\n      return evaluationVisitor.execute( this );\n    }\n\n    matchYourselfToStartOfThisStringAndAddSelfToArray( arrayOfSymbolsMatchedBeforeMe, sentenceOfSymbolsToMatch, parseTimeVisitor ){\n\n      let care = false;\n\n      if( this.toStringSimple() == \"BOOLEAN & BOOLEAN\" )\n      {\n        //care = true;\n      }\n      // clone it so we don't destroy the original in case we're only a partial match\n\n      let sentenceOfSymbolsToMatchClone = sentenceOfSymbolsToMatch.slice(0);\n\n      if( care ) console.log(\"sentenceOfSymbolsToMatchClone is \" + sentenceOfSymbolsToMatchClone );\n\n      // same with ours\n\n      let seriesOfSymbolsIMustMatchClone = this.seriesOfSymbolsIMustMatch.slice(0);\n\n      if( care ) console.log(\"seriesOfSymbolsIMustMatchClone is \" + seriesOfSymbolsIMustMatchClone );\n\n      this.seriesOfSymbolsIAbsorbedAndReplaced = [];\n\n      let done = false;\n\n      // in case of wildcard, we need to know what the previous symbol was\n\n      let symbolThatBreaksWildcard = null;\n\n      while( seriesOfSymbolsIMustMatchClone.length > 0 )\n      {\n        if( care ) console.log(\"at top of seriesOfSymbolsIMustMatchClone.length loop, where seriesOfSymbolsIMustMatchClone.length is \" + seriesOfSymbolsIMustMatchClone.length );\n        let mySymbol = seriesOfSymbolsIMustMatchClone.shift();\n        let theirSymbol = sentenceOfSymbolsToMatchClone.shift();\n\n        if( care ) console.log(\"mySymbol is \" + mySymbol );\n        if( care ) console.log(\"theirSymbol is \" + theirSymbol );\n\n        // if they ran out of symbols, then we're obviously not a match. UNLESS we were in wildcard mode.\n        if( ! theirSymbol )\n        {\n            this.seriesOfSymbolsIAbsorbedAndReplaced = [];\n            return [ 0, arrayOfSymbolsMatchedBeforeMe, sentenceOfSymbolsToMatch ];\n        }\n\n\n\n        if( mySymbol == \"WILDCARD\" )\n        {\n          this.wildcardMode = true;\n          symbolThatBreaksWildcard = seriesOfSymbolsIMustMatchClone.shift();\n          while( theirSymbol.type != symbolThatBreaksWildcard )\n          {\n            this.seriesOfSymbolsIAbsorbedAndReplaced.push( theirSymbol );\n\n            if( sentenceOfSymbolsToMatchClone.length == 0 ) // they ran out of symbols in their sentence!\n            {\n              if( seriesOfSymbolsIMustMatchClone.length == 0 ) // that wildcard was my last character\n              {\n                arrayOfSymbolsMatchedBeforeMe.push( this.getFrozenClone() );\n                return [ this.length, arrayOfSymbolsMatchedBeforeMe, sentenceOfSymbolsToMatchClone ];\n              }\n              else // failure -- we had more to match but they ran out first\n              {\n                this.seriesOfSymbolsIAbsorbedAndReplaced = [];\n                return [ 0, arrayOfSymbolsMatchedBeforeMe, sentenceOfSymbolsToMatch ];\n              }\n            }\n            else\n            {\n              theirSymbol = sentenceOfSymbolsToMatchClone.shift();\n\n            }\n          } //end of tight loop inside wildcard mode, but still in wildcard mode\n\n          // absorb the one that got us out of the wildcard\n          // i.e., it matched the symbol of ours that follows (and thus ends) the wildcard\n\n          this.seriesOfSymbolsIAbsorbedAndReplaced.push( theirSymbol );\n\n          // we made it through!\n          // if that was the last one, then we should skip the rest of the matching and go right to success\n          // if not, keep the process going -- get a new symbol from them\n          if( seriesOfSymbolsIMustMatchClone.length == 0 ) // we don't have any more\n          {\n            done = true;\n          }\n          else if( sentenceOfSymbolsToMatchClone.length > 0 ) // we have more, and they have more things that need matching\n          {\n            theirSymbol = sentenceOfSymbolsToMatchClone.shift();\n            // but if our wildcard was our last character, then we should leave\n          }\n          else // we have more, but they don't!\n          {\n            this.seriesOfSymbolsIAbsorbedAndReplaced = [];\n            return [ 0, arrayOfSymbolsMatchedBeforeMe, sentenceOfSymbolsToMatch ];\n          }\n        } // end of wildcard loop\n\n        if (!done )\n        {\n          // do they match? i.e., the next character in the sentence -- does it match the next symbol in my internal list?\n          if( theirSymbol.type != mySymbol )\n          {\n            return [ 0, arrayOfSymbolsMatchedBeforeMe, sentenceOfSymbolsToMatch ];\n          }\n          else\n          {\n            if( care ) console.log(\"OK, we matched symbols and done is \" + done );\n            this.seriesOfSymbolsIAbsorbedAndReplaced.push( theirSymbol );\n          }\n        }\n      }// bottom of seriesOfSymbolsIMustMatchClone.length loop\n\n      if( care ) console.log(\"ALL IS WELL SO FAR\");\n      // we made it through -- matched everything we needed to -- but maybe there's a problem after all...\n      // now, there's an edge case -- good for operator precedence enforcement\n      // -- the lookahead tokens.\n      // maybe we matched everything we needed, and that's great,\n      // but maybe the next token in the sentence is a dealbreaker!\n      // for example, 1 + 2 * 3\n      // if we're NUMERIC + NUMERIC, we'll find a match\n      // but that is wrong! because the next token *after* our possible match is a *\n      // and that has higher precedence than +\n\n      if( this.lookaheadTokensToAvoid )\n      {\n        if(care) console.log(\"LOOKAHEADS!!!\" + this.lookaheadTokensToAvoid);\n        if( sentenceOfSymbolsToMatchClone.length > 0 )\n        {\n          let theirNextSymbol = sentenceOfSymbolsToMatchClone[0];\n          if( this.lookaheadTokensToAvoid.indexOf( theirNextSymbol.type ) > -1 )\n          {\n            return [ 0, arrayOfSymbolsMatchedBeforeMe, sentenceOfSymbolsToMatch ];\n          }\n        }\n      }\n      // we made it here! must be a basically perfect match.\n      // but let's see if there's a context stack for this parser\n      // e.g., an XML parser keeps a stack of open nodes\n      // so that when you hit a closing tag for a node\n      // the parser can know if it's the most recently opened tag\n      if( ! parseTimeVisitor || parseTimeVisitor.execute( this ) )\n      {\n        arrayOfSymbolsMatchedBeforeMe.push( this.getFrozenClone() );\n        return [ this.length, arrayOfSymbolsMatchedBeforeMe, sentenceOfSymbolsToMatchClone ];\n      }\n      else\n      {\n        return [ 0, arrayOfSymbolsMatchedBeforeMe, sentenceOfSymbolsToMatch ];\n      }\n    }\n\n    getFrozenClone(){\n\n      let frozenClone = new Nonterminal( this.seriesOfSymbolsIMustMatch, this.type );\n\n      frozenClone.seriesOfSymbolsIAbsorbedAndReplaced = this.seriesOfSymbolsIAbsorbedAndReplaced;\n\n      return frozenClone;\n    }\n\n}\n\n\n// WEBPACK FOOTER //\n// ./js/nonterminal.js","import Symbol from './symbol'\n\nexport default class Token extends Symbol{\n\n  /***\n   * We are one of the two types of Symbol this parser deals with:\n   * Tokens and Nonterminals.\n   * A Token is basically a Symbol that contains one or more string characters.\n   * A Nonterminal is basically a Symbol that contains one or more Symbols\n   * (each of which can be either a Token or a Nonterminal).\n   *\n   * First argument will be a regex that will match some of the raw input stream.\n   * Second argument will be the internal representation I will use for myself\n   * (a string).\n   *\n   */\n  constructor( regexOfThingsIMustMatch, type, leng, stringIActuallyMatched, ignore, startIndex = -1 ){\n    super();\n    this.regexOfThingsIMustMatch = regexOfThingsIMustMatch;\n    this._type = type;\n    this.start = startIndex;\n    this._length = leng ? leng : 0;\n    this._stringIMatched = stringIActuallyMatched;\n    this._ignore = ignore;\n  }\n\n  get type(){\n    return this._type;\n  }\n\n  toStringSimple(){\n      return \" \" +  this._type + \" \" ;\n  }\n\n  get length(){\n    return this._length;\n  }\n\n  visit( evaluationVisitor ) {\n    return evaluationVisitor.execute( this );\n  }\n\n  matchYourselfToStartOfThisStringAndAddSelfToArray( symbolArray, stringToMatch, startingIndex ){\n      this._length = 0;\n      let match = this.regexOfThingsIMustMatch.exec( stringToMatch );\n      if( match != null && match.index == 0 ){\n        this._length = match[0].length;\n        // a frozen clone to record this moment,\n        // so that our data can go on to be reused without breaking things\n        let frozenToken = new Token( this.regexOfThingsIMustMatch, this.type, this._length,  match[0], this._ignore, startingIndex );\n        if( !this._ignore) symbolArray.push( frozenToken );\n        stringToMatch = stringToMatch.substring( this.length );\n      }\n      return [ this._length, symbolArray, stringToMatch ];\n  }\n\n  toString(){\n    return this.type + \"(\" + this.regexOfThingsIMustMatch.toString() + \")<\" + this._stringIMatched + \".\" + this.start + \">\";\n  }\n\n}\n\n\n\n\n// WEBPACK FOOTER //\n// ./js/token.js","import Token from '../token';\n\nclass XMLJSONVisitor{\n  constructor( state ){\n    this.state = state;\n  }\n  setState( newstate ){\n    this.state = newstate;\n  }\n\n  execute( thingToEvaluate )\n  {\n        var ob = {};\n        ob.name = thingToEvaluate.type;\n        ob.value = this.getValue( thingToEvaluate );\n        let symbolsMatched = thingToEvaluate.symbolsMatched;\n\n        switch( thingToEvaluate.type )\n        {\n\n            case \"TOKEN\":\n                return { name : thingToEvaluate.stringIActuallyMatched, value: this.getValue( thingToEvaluate ), condition: \"Condition Text Goes Here\" };\n            case \"XMLNODE\":\n\n                ob.children = [];\n                // opentag is first item, and that gives us our name\n                ob.name = this.getValue( symbolsMatched[ 0 ] );\n                var optionalAttributes = this.getAttributes( symbolsMatched[ 0 ] );\n\n                if( optionalAttributes )\n                {\n                  ob.attributes = optionalAttributes;\n                }\n\n                symbolsMatched = this.consolidateChildrenThatAreTokens( symbolsMatched );\n\n                for( var i = 1; i < symbolsMatched.length - 1; i++ ) // -1, because the last match will be a closetag, which is irrelevant\n                {\n                  ob.children.push( this.execute( symbolsMatched[ i ]) );\n                }\n\n\n                break;\n\n            case \"IDENT\": // basically a passthrough. Assume our first child is a real operator, and return *its* json.\n                ob.name = thingToEvaluate._stringIMatched;\n        }\n        return ob;\n  }\n\n  // good for the wildcard globbing we do inside open and close tags\n  consolidateChildrenThatAreTokens( arrayOfSymbolsThatMightBeTokens ) {\n    let symbolChildrenOnly = [];\n    let runningStringOfTokenText = \"\";\n    for( var symbol of arrayOfSymbolsThatMightBeTokens ){\n      if( symbol.constructor.name != \"Token\" )\n      {\n        if( runningStringOfTokenText.length > 0 ) // we've been building up a text string!\n        {\n          let tokenConsolidatingStrings = this.makeTokenWrappingString( runningStringOfTokenText );\n          symbolChildrenOnly.push( tokenConsolidatingStrings );\n          runningStringOfTokenText = \"\";\n          symbolChildrenOnly.push( symbol );\n        }\n        else\n        {\n          symbolChildrenOnly.push( symbol );\n        }\n      }\n      else // it's a token!\n      {\n\n         runningStringOfTokenText += symbol._stringIMatched;\n\n      }\n    }\n\n    if( runningStringOfTokenText.length > 0 )\n    {\n      let tokenConsolidatingStrings = this.makeTokenWrappingString( runningStringOfTokenText );\n      symbolChildrenOnly.push( tokenConsolidatingStrings );\n    }\n\n    return symbolChildrenOnly;\n  }\n\n  makeTokenWrappingString( stringToWrap ){\n    let newSymbol = new Token( /.+/, \"TEXTNODE\", stringToWrap.length, stringToWrap );\n    return newSymbol;\n  }\n\n  // sent either an opentag or an opentagstart\n  getAttributes( childOfXMLNode ) {\n\n    if( childOfXMLNode.type == \"OPENTAGSTART\" )\n    {\n      // could be nested\n      // or could just be <, IDENT, IDENT, =, ', WILDCARD, '\n      let atts = {};\n      if( childOfXMLNode.symbolsMatched[0].constructor.name == \"Token\" ) // could only be \"<\"\n      {\n        let name = this.getValue( childOfXMLNode.symbolsMatched[2] );\n        let val = this.getValue( childOfXMLNode.symbolsMatched[5] );\n        atts[ name ] = val;\n        return atts;\n      }\n      else if(childOfXMLNode.symbolsMatched[0].type == \"OPENTAGSTART\")\n      {\n        atts = this.getAttributes( childOfXMLNode.symbolsMatched[0] );\n        let name = this.getValue( childOfXMLNode.symbolsMatched[1] );\n        let val = this.getValue( childOfXMLNode.symbolsMatched[4] );\n        atts[ name ] = val;\n        return atts;\n      }\n    }\n    else if(childOfXMLNode.symbolsMatched[0].type == \"OPENTAGSTART\")\n    {\n      let returnAtts = this.getAttributes( childOfXMLNode.symbolsMatched[0] );\n      return returnAtts;\n    }\n    return null;\n  }\n\n  getValue( nonterminalOrToken ){\n\n    if(nonterminalOrToken.constructor.name == \"Nonterminal\" )\n    {\n        let symbolsMatched = nonterminalOrToken.symbolsMatched;\n\n        let value = \"FOO\"; // declare this and, hey, initialize it with something we'll notice if there's an error.\n\n        if( nonterminalOrToken.type == \"XMLNODE\")\n        {\n          // our first child will be our opentag, which is where our name comes from.\n          let returnVal = this.getValue( symbolsMatched[0] );\n          return returnVal;\n        }\n\n        if( nonterminalOrToken.type == \"OPENTAG\" || nonterminalOrToken.type == \"OPENTAGSTART\")\n        {\n          var returnVal;\n          // symbolsMatched[1] will either be an IDENT or an OPENTAGSTART (the wrapper for attribute definitions)\n          if( symbolsMatched[0].type == \"OPENTAGSTART\" )\n          {\n            returnVal = this.getValue( symbolsMatched[0] );\n            return returnVal;\n          }\n          returnVal = this.getValue( symbolsMatched[1] );\n          return returnVal;\n        }\n\n        if( nonterminalOrToken.type == \"CLOSETAG\")\n        {\n            return this.getValue( symbolsMatched[2] ); // after < and /\n        }\n\n        if( nonterminalOrToken.type == \"COMMENT\")\n        {\n          console.error(\"COMMENT is \" + nonterminalOrToken.toString() );\n          let commentstring = \"\";\n          for(var kid of nonterminalOrToken.symbolsMatched )\n          {\n            if( kid.type == \"OPENCOMMENT\" || kid.type == \"CLOSECOMMENT\") continue;\n            commentstring += this.getValue( kid );\n          }\n            return commentstring;\n        }\n\n        throw new Error(\"XMLJSONVISITOR UNKNOWN LENGTH OF SYMBOLSMATCHED for \" + nonterminalOrToken.type + \":\" + JSON.stringify( symbolsMatched ));\n      }\n      else // it's a token\n      {\n        if( nonterminalOrToken.type.toUpperCase().indexOf( \"TRUE\" ) > -1 )\n        {\n          return true;\n        }\n        if( nonterminalOrToken.type.toUpperCase().indexOf( \"TEXTNODE\" ) > -1 )\n        {\n          return nonterminalOrToken._stringIMatched;\n        }\n        if( nonterminalOrToken.type.toUpperCase().indexOf( \"IDENT\" ) > -1 )\n        {\n          return nonterminalOrToken._stringIMatched;\n        }\n        return nonterminalOrToken._stringIMatched;\n//        throw new Error(\"nonterminalOrToken.type is \" + nonterminalOrToken.type );\n//        return null;\n      }\n  }\n}\n\nmodule.exports = XMLJSONVisitor;\n\n\n// WEBPACK FOOTER //\n// ./js/visitors/xmljsonvisitor.js","\nclass XMLParseTimeVisitor{\n  constructor( state ){\n    this.state = state;\n  }\n  setState( newstate ){\n    this.state = newstate;\n  }\n\n  execute( nonterm )\n  {\n\n    if( nonterm.type == \"XMLNODE\")\n    {\n      return this.verifyOpeningAndCloseTagsMatch( nonterm ) && this.verifyTagContentIsLegal( nonterm );\n    }\n    else if( nonterm.type == \"OPENTAG\")\n    {\n      return this.verifyAttributeContentIsLegal( nonterm );\n    }\n    else return true;\n  }\n\n  verifyOpeningAndCloseTagsMatch( thingToEvaluate ) {\n      \n      \n      let openTagName   = this.getTagName( thingToEvaluate.symbolsMatched[ 0 ] );\n       let closeTagName;\n      if( thingToEvaluate.symbolsMatched.length == 2 )\n      {\n        closeTagName = this.getTagName( thingToEvaluate.symbolsMatched[ 1 ] );\n      }\n      else if( thingToEvaluate.symbolsMatched.length > 2 )\n      {\n        closeTagName  = this.getTagName( thingToEvaluate.symbolsMatched[ thingToEvaluate.symbolsMatched.length - 1] );\n      }\n      \n      return openTagName == closeTagName;\n  }\n\n  verifyAttributeContentIsLegal( nonterm ){\n    // remember that OPENTAG can contain optional OPENTAGSTART nodes\n    // each of which can enclose other OPENTAGSTART nodes in perpetuity\n    return true;\n  }\n\n  verifyTagContentIsLegal( thingToEvaluate ){\n    return true;\n  }\n\n\n  getTagName( thingToEvaluate ){\n\n\n    while( thingToEvaluate.type != \"IDENT\" )\n    {\n      \n      if( thingToEvaluate.type == \"OPENTAG\")\n      {\n        if( thingToEvaluate.symbolsMatched)\n        {\n          if(  thingToEvaluate.symbolsMatched[0].type == \"<\")\n          {\n            \n            return thingToEvaluate.symbolsMatched[1]._stringIMatched;\n          }\n        }\n      }\n      else if( thingToEvaluate.type == \"CLOSETAG\")\n      {\n        \n        if( thingToEvaluate.symbolsMatched)\n        {\n          if(  thingToEvaluate.symbolsMatched[0].type == \"<\")\n          {\n            // element [1] will be \"/\" so we'll skip to [2]\n            \n            return thingToEvaluate.symbolsMatched[2]._stringIMatched;\n          }\n        }\n      }\n      else if( thingToEvaluate.type == \"OPENTAGSTART\")\n      {\n        \n        if( thingToEvaluate.symbolsMatched)\n        {\n          if(  thingToEvaluate.symbolsMatched[0].type == \"<\")\n          {\n            return thingToEvaluate.symbolsMatched[1]._stringIMatched;\n          }\n        }\n      }\n      thingToEvaluate = thingToEvaluate.symbolsMatched[0]\n    }\n    return thingToEvaluate._stringIMatched;\n    }\n}\n\n\n\nmodule.exports = XMLParseTimeVisitor;\n\n\n// WEBPACK FOOTER //\n// ./js/visitors/xmlparsetimevisitor.js","//import Token from './token';\n//import Symbol from './token';\nimport Lexer from './lexer';\nimport Parser from './parser';\nimport XMLParseTimeVisitor from './visitors/xmlparsetimevisitor';\nimport XMLJSONVisitor from './visitors/xmljsonvisitor';\nimport TokenFactory from './factories/tokenfactory';\nimport NonterminalFactory from './factories/nonterminalfactory';\n\nexport default class Mathius{\n  constructor( tokenDefinitions, grammarObject ){\n\n\n\n    // we set the state so that the parser knows the data type of each of these variables\n    // (in this case, boolean)\n    // and later so that the visitor can evaluate each node to determine if it is true or false.\n    this.state = {\"a\":false,\"b\":true,\"c\":false,\"d\":true,\"e\":false,\"f\":true,\"g\":false,\"h\":true,\"i\":false};\n\n    this.visitor = new NumericVisitor(  this.state );\n    // lay the groundwork for lexical analysis\n    this.lexer = new Lexer( tokenDefinitions );\n    this.parser = new Parser( grammarObject );\n    this.parser.setState( this.state );\n  }\n\n\n  parse( sentenceToParse ){\n    try\n    {\n      let sentenceOfTokens = this.lexer.tokenize( sentenceToParse );\n      this.parseTree = this.parser.parse( sentenceOfTokens );\n      return this.evaluateParseTree();\n    }\n    catch( e )\n    {\n      console.error( \"ERROR PARSING OR EVALUATING:\" + e );\n    }\n  }\n\n  evaluateParseTree(){\n    let result = this.parseTree[0].visit( this.visitor );\n    return result;\n  }\n}\n\n\nwindow.Mathius = Mathius;\n\n\n\n// WEBPACK FOOTER //\n// ./js/mathius.js","\nclass BooleanJSONVisitor{\n  constructor( state ){\n    this.state = state;\n  }\n  setState( newstate ){\n    this.state = newstate;\n  }\n\n  execute( thingToEvaluate )\n  {\n        var ob = {};\n        ob.name = thingToEvaluate.type;\n        ob.value = thingToEvaluate.value = this.getBoolean( thingToEvaluate );\n        let symbolsMatched = thingToEvaluate.seriesOfSymbolsIAbsorbedAndReplaced;\n\n        switch( thingToEvaluate.type )\n        {\n            case \"TOKEN\":\n                return { name : thingToEvaluate.stringIActuallyMatched, value: this.getBoolean( thingToEvaluate ), condition: \"Condition Text Goes Here\" };\n            case \"BOOLEAN\":\n\n                ob.children = [];\n                if( symbolsMatched.length == 3 ) // there's a binary operator\n                {\n\n                  // either a binary operator or \"(\" + boolean + \")\"\n                  if( ( symbolsMatched[0].type == \"(\") && ( symbolsMatched[2].type == \")\") )\n                  {\n                    // we'll pass it through transparently\n                    // in other words, allow our middle child to represent us completely\n                    // since the user isn't interested in seeing each \"(\" represented with its own node onscreen\n                    return this.execute( symbolsMatched[ 1 ] );\n                  }\n                  else\n                  {\n                    ob.name = this.getNameForOperator( symbolsMatched[ 1 ].type );\n                    ob.children.push( this.execute( symbolsMatched[ 0 ]) );\n                    ob.children.push( this.execute( symbolsMatched[ 2 ]) );\n                  }\n                  \n                }\n                else if( symbolsMatched.length == 2 ) // there's a unary operator\n                {\n                  // the only unary operator\n                  ob.name = this.getNameForOperator( symbolsMatched[ 0 ].type ); \n                  ob.children.push( this.execute( symbolsMatched[ 1 ]) );\n                }\n                else\n                {\n                  return this.execute( symbolsMatched[ 0 ]);\n                }\n\n                break;\n\n            case \"IDENT\": // basically a passthrough. Assume our first child is a real operator, and return *its* json.\n                ob.name = thingToEvaluate._stringIMatched;\n        }\n        return ob;\n  }\n\n  getBoolean( nonterminalOrToken ){\n\n    if(nonterminalOrToken.constructor.name == \"Nonterminal\" )\n    {\n        let symbolsMatched = nonterminalOrToken.seriesOfSymbolsIAbsorbedAndReplaced;\n        let value = \"FOO\"; // declare this and, hey, initialize it with something we'll notice if there's an error.\n        if( symbolsMatched.length == 1 ) // we're a nonterminal that absorbed one other thing\n        {\n          value = this.getBoolean( symbolsMatched[0] );\n          return value;\n        }\n        else if( symbolsMatched.length == 3 )// we're a boolean comprising an operator and two operands\n        {\n          if( symbolsMatched[1].type == \"|\")\n          {\n            return this.getBoolean( symbolsMatched[0] ) || this.getBoolean( symbolsMatched[2] );\n          }\n          else if( symbolsMatched[1].type == \"&\")\n          {\n            return this.getBoolean( symbolsMatched[0] ) && this.getBoolean( symbolsMatched[2] );\n          }\n          else if( ( symbolsMatched[0].type == \"(\") && ( symbolsMatched[2].type == \")\") )\n          {\n            return this.getBoolean( symbolsMatched[1] );\n          }\n          else\n          {\n            throw new Error(\"DON'T KNOW WHAT THE OPERATOR OF THIS 3-ELEMENT SYMBOLSMATCHED IS:\" + JSON.stringify( symbolsMatched ));\n          }\n        }\n        else if( symbolsMatched.length == 2 )// we're a boolean with one operator -- probably a not\n        {\n          if( symbolsMatched[0].type == \"!\")\n          {\n            return ! this.getBoolean( symbolsMatched[1] );\n          }\n          else\n          {\n            throw new Error(\"DON'T KNOW WHAT THE OPERATOR OF THIS 2-ELEMENT SYMBOLSMATCHED IS:\" + JSON.stringify( symbolsMatched ));\n          }\n        }\n\n        throw new Error(\"UNKNOWN LENGTH OF SYMBOLSMATCHED:\" + JSON.stringify( symbolsMatched ));\n      }\n      else // it's a token\n      {\n        if( nonterminalOrToken.type.toUpperCase().indexOf( \"TRUE\" ) > -1 )\n        {\n          return true;\n        }\n        if( nonterminalOrToken.type.toUpperCase().indexOf( \"FALSE\" ) > -1 )\n        {\n          return false;\n        }\n        if( nonterminalOrToken.type.toUpperCase().indexOf( \"IDENT\" ) > -1 )\n        {\n          return this.state[ nonterminalOrToken._stringIMatched ];\n        }\n\n        throw new Error(\"nonterminalOrToken.type is \" + nonterminalOrToken.type );\n        return null;\n      }\n  }\n\n  getNameForOperator( operatorSymbol ){\n    if( operatorSymbol == \"|\" ) return \"OR\";\n    if( operatorSymbol == \"&\" ) return \"AND\";\n    if( operatorSymbol == \"^\" ) return \"XOR\";\n    if( operatorSymbol == \"!\" ) return \"NOT\";\n  }\n}\n\nmodule.exports = BooleanJSONVisitor;\n\n\n// WEBPACK FOOTER //\n// ./js/visitors/booleanjsonvisitor.js","//import Token from './token';\n//import Symbol from './token';\nimport Lexer from './lexer';\nimport Parser from './parser';\nimport XMLParseTimeVisitor from './visitors/xmlparsetimevisitor';\nimport XMLJSONVisitor from './visitors/xmljsonvisitor';\nimport TokenFactory from './factories/tokenfactory';\nimport NonterminalFactory from './factories/nonterminalfactory';\n\nexport default class XMLius{\n  constructor( tokenDefinitions, grammarObject ){\n\n\n\n    // we set the state so that the parser knows the data type of each of these variables\n    // (in this case, boolean)\n    // and later so that the visitor can evaluate each node to determine if it is true or false.\n    this.state = {\"a\":false,\"b\":true,\"c\":false,\"d\":true,\"e\":false,\"f\":true,\"g\":false,\"h\":true,\"i\":false};\n\n    this.xmlParseTimeVisitor = new XMLParseTimeVisitor();\n\n    this.visitor = new XMLJSONVisitor(  this.state );\n    // lay the groundwork for lexical analysis\n    this.lexer = new Lexer( tokenDefinitions );\n    this.parser = new Parser( grammarObject );\n    this.parser.setState( this.state );\n  }\n\n  parse( sentenceToParse ){\n    try\n    {\n      let sentenceOfTokens = this.lexer.tokenize( sentenceToParse );\n      this.parseTree = this.parser.parse( sentenceOfTokens, this.xmlParseTimeVisitor );\n      return this.evaluateParseTree();\n    }\n    catch( e )\n    {\n      console.error( \"ERROR PARSING OR EVALUATING:\" + e );\n    }\n  }\n\n  evaluateParseTree(){\n    let result = this.parseTree[0].visit( this.visitor );\n    return result;\n  }\n}\n\n\nwindow.XMLius = XMLius;\n\n\n\n// WEBPACK FOOTER //\n// ./js/xmlius.js","//import Token from './token';\n//import Symbol from './token';\nimport Lexer from './lexer';\nimport Parser from './parser';\nimport XMLius from './xmlius';\nimport Mathius from './mathius';\nimport BooleanJSONVisitor from './visitors/booleanjsonvisitor';\nimport TokenFactory from './factories/tokenfactory';\nimport NonterminalFactory from './factories/nonterminalfactory';\n\nexport default class Boolius{\n  constructor( tokenDefinitions, grammarObject ){\n\n    // we set the state so that the parser knows the data type of each of these variables\n    // (in this case, boolean)\n    // and later so that the visitor can evaluate each node to determine if it is true or false.\n    this.state = {\"a\":false,\"b\":true,\"c\":false,\"d\":true,\"e\":false,\"f\":true,\"g\":false,\"h\":true,\"i\":false};\n    this.visitor = new BooleanJSONVisitor( this.state );\n    // lay the groundwork for lexical analysis\n    this.lexer = new Lexer( tokenDefinitions );\n    this.parser = new Parser( grammarObject );\n    this.parser.setState( this.state );\n  }\n\n  parse( sentenceToParse ){\n    try\n    {\n      let sentenceOfTokens = this.lexer.tokenize( sentenceToParse );\n      this.parseTree = this.parser.parse( sentenceOfTokens );\n      return this.evaluateParseTree();\n    }\n    catch( e )\n    {\n      alert( e );\n    }\n  }\n\n  evaluateParseTree(){\n    let result = this.parseTree[0].visit( this.visitor );\n    return result;\n  }\n}\nwindow.Boolius = Boolius;\n\n\n\n// WEBPACK FOOTER //\n// ./js/boolius.js"],"sourceRoot":""}