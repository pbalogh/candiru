{"version":3,"sources":["webpack:///webpack/bootstrap 4e90daf4deedcefd3e65","webpack:///./js/symbol.js","webpack:///./js/nonterminal.js","webpack:///./js/factories/nonterminalfactory.js","webpack:///./js/factories/tokenfactory.js","webpack:///./js/lexer.js","webpack:///./js/parser.js","webpack:///./js/visitors/booleanjsonvisitor.js","webpack:///./js/token.js","webpack:///./js/boolius.js"],"names":["Symbol","_name","someName","Nonterminal","seriesOfSymbolsIMustMatch","type","seriesOfSymbolsIAbsorbedAndReplaced","wildcardMode","lookaheadTokensToAvoid","join","returnString","symbol","toString","evaluationVisitor","execute","arrayOfSymbolsMatchedBeforeMe","sentenceOfSymbolsToMatch","care","toStringSimple","sentenceOfSymbolsToMatchClone","slice","console","log","seriesOfSymbolsIMustMatchClone","done","symbolThatBreaksWildcard","length","mySymbol","shift","theirSymbol","push","getFrozenClone","theirNextSymbol","indexOf","frozenClone","NonterminalFactory","grammarObject","nonterminals","grammarRule","nonterminal","TokenFactory","tokens","regex","name","ignore","token","IGNORE","makeToken","Lexer","sentenceToTokenize","arrayOfTokens","startingLetter","stringToMatch","foundAMatchSomewhere","lengthOfMatch","matchYourselfToStartOfThisStringAndAddSelfToArray","Error","charAt","Parser","state","sentenceOfSymbols","resolvedSymbols","constructor","_stringIMatched","nonterm","traceString","resolveIdentifiersToTypes","finished","madeAMatch","getSimpleStringForSentence","BooleanJSONVisitor","newstate","thingToEvaluate","ob","value","getBoolean","symbolsMatched","stringIActuallyMatched","condition","children","getNameForOperator","nonterminalOrToken","JSON","stringify","toUpperCase","operatorSymbol","module","exports","Token","regexOfThingsIMustMatch","leng","startIndex","_type","start","_length","_ignore","symbolArray","startingIndex","match","exec","index","frozenToken","substring","Boolius","visitor","tokenFactory","getTokens","nonterminalFactory","getNonterminals","lexer","parser","setState","sentenceToParse","sentenceOfTokens","tokenize","parseTree","parse","evaluateParseTree","e","alert","result","visit","window"],"mappings":"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","file":"boolius.bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/build/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 8);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 4e90daf4deedcefd3e65","export default class Symbol{\n  constructor(){\n\n  }\n  get name(){\n    return this._name;\n  }\n  set name( someName ){\n    this._name = someName;\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ./js/symbol.js","import Symbol from './symbol'\n\nexport default class Nonterminal extends Symbol{\n\n    constructor( seriesOfSymbolsIMustMatch, type ){\n      super();\n      this.seriesOfSymbolsIMustMatch  = seriesOfSymbolsIMustMatch;\n      this.type                       = type;\n      this.seriesOfSymbolsIAbsorbedAndReplaced = [];\n      this.wildcardMode = false;\n      this.lookaheadTokensToAvoid = null;\n    }\n\n    toStringSimple(){\n      return this.seriesOfSymbolsIMustMatch.join( ' ' );\n    }\n\n    toString(){\n      let returnString = this.type + \" (\";\n\n      for( var symbol of this.seriesOfSymbolsIAbsorbedAndReplaced )\n      {\n        returnString += \" \" + symbol.toString();\n      }\n      return returnString;\n    }\n\n    get length(){\n      return this.seriesOfSymbolsIAbsorbedAndReplaced.length;\n    }\n\n    visit( evaluationVisitor ) {\n      return evaluationVisitor.execute( this );\n    }\n\n    matchYourselfToStartOfThisStringAndAddSelfToArray( arrayOfSymbolsMatchedBeforeMe, sentenceOfSymbolsToMatch ){\n\n      let care = false;\n\n      if( this.toStringSimple() == \"BOOLEAN & BOOLEAN\" )\n      {\n        //care = true;\n      }\n      // clone it so we don't destroy the original in case we're only a partial match\n\n      let sentenceOfSymbolsToMatchClone = sentenceOfSymbolsToMatch.slice(0);\n\n      if( care ) console.log(\"sentenceOfSymbolsToMatchClone is \" + sentenceOfSymbolsToMatchClone );\n\n      // same with ours\n\n      let seriesOfSymbolsIMustMatchClone = this.seriesOfSymbolsIMustMatch.slice(0);\n\n      if( care ) console.log(\"seriesOfSymbolsIMustMatchClone is \" + seriesOfSymbolsIMustMatchClone );\n\n      this.seriesOfSymbolsIAbsorbedAndReplaced = [];\n\n      let done = false;\n\n      // in case of wildcard, we need to know what the previous symbol was\n\n      let symbolThatBreaksWildcard = null;\n\n      while( seriesOfSymbolsIMustMatchClone.length > 0 )\n      {\n        if( care ) console.log(\"at top of seriesOfSymbolsIMustMatchClone.length loop, where seriesOfSymbolsIMustMatchClone.length is \" + seriesOfSymbolsIMustMatchClone.length );\n        let mySymbol = seriesOfSymbolsIMustMatchClone.shift();\n        let theirSymbol = sentenceOfSymbolsToMatchClone.shift();\n\n        if( care ) console.log(\"mySymbol is \" + mySymbol );\n        if( care ) console.log(\"theirSymbol is \" + theirSymbol );\n\n        // if they ran out of symbols, then we're obviously not a match. UNLESS we were in wildcard mode.\n        if( ! theirSymbol )\n        {\n            this.seriesOfSymbolsIAbsorbedAndReplaced = [];\n            return [ 0, arrayOfSymbolsMatchedBeforeMe, sentenceOfSymbolsToMatch ];\n        }\n\n\n\n        if( mySymbol == \"WILDCARD\" )\n        {\n          this.wildcardMode = true;\n          symbolThatBreaksWildcard = seriesOfSymbolsIMustMatchClone.shift();\n          while( theirSymbol.type != symbolThatBreaksWildcard )\n          {\n            this.seriesOfSymbolsIAbsorbedAndReplaced.push( theirSymbol );\n\n            if( sentenceOfSymbolsToMatchClone.length == 0 ) // they ran out of symbols in their sentence!\n            {\n              if( seriesOfSymbolsIMustMatchClone.length == 0 ) // that wildcard was my last character\n              {\n                arrayOfSymbolsMatchedBeforeMe.push( this.getFrozenClone() );\n                return [ this.length, arrayOfSymbolsMatchedBeforeMe, sentenceOfSymbolsToMatchClone ];\n              }\n              else // failure -- we had more to match but they ran out first\n              {\n                this.seriesOfSymbolsIAbsorbedAndReplaced = [];\n                return [ 0, arrayOfSymbolsMatchedBeforeMe, sentenceOfSymbolsToMatch ];\n              }\n            }\n            else\n            {\n              theirSymbol = sentenceOfSymbolsToMatchClone.shift();\n\n            }\n          } //end of tight loop inside wildcard mode, but still in wildcard mode\n\n          // absorb the one that got us out of the wildcard\n          // i.e., it matched the symbol of ours that follows (and thus ends) the wildcard\n\n          this.seriesOfSymbolsIAbsorbedAndReplaced.push( theirSymbol );\n\n          // we made it through!\n          // if that was the last one, then we should skip the rest of the matching and go right to success\n          // if not, keep the process going -- get a new symbol from them\n          if( seriesOfSymbolsIMustMatchClone.length == 0 ) // we don't have any more\n          {\n            done = true;\n          }\n          else if( sentenceOfSymbolsToMatchClone.length > 0 ) // we have more, and they have more things that need matching\n          {\n            theirSymbol = sentenceOfSymbolsToMatchClone.shift();\n            // but if our wildcard was our last character, then we should leave\n          }\n          else // we have more, but they don't!\n          {\n            this.seriesOfSymbolsIAbsorbedAndReplaced = [];\n            return [ 0, arrayOfSymbolsMatchedBeforeMe, sentenceOfSymbolsToMatch ];\n          }\n        } // end of wildcard loop\n\n        if (!done )\n        {\n          // do they match? i.e., the next character in the sentence -- does it match the next symbol in my internal list?\n          if( theirSymbol.type != mySymbol )\n          {\n            return [ 0, arrayOfSymbolsMatchedBeforeMe, sentenceOfSymbolsToMatch ];\n          }\n          else\n          {\n            if( care ) console.log(\"OK, we matched symbols and done is \" + done );\n            this.seriesOfSymbolsIAbsorbedAndReplaced.push( theirSymbol );\n          }\n        }\n      }// bottom of seriesOfSymbolsIMustMatchClone.length loop\n\n      if( care ) console.log(\"ALL IS WELL SO FAR\");\n      // we made it through -- matched everything we needed to -- but maybe there's a problem after all...\n      // now, there's an edge case -- good for operator precedence enforcement\n      // -- the lookahead tokens.\n      // maybe we matched everything we needed, and that's great,\n      // but maybe the next token in the sentence is a dealbreaker!\n      // for example, 1 + 2 * 3\n      // if we're NUMERIC + NUMERIC, we'll find a match\n      // but that is wrong! because the next token *after* our possible match is a *\n      // and that has higher precedence than +\n\n      if( this.lookaheadTokensToAvoid )\n      {\n        if(care) console.log(\"LOOKAHEADS!!!\" + this.lookaheadTokensToAvoid);\n        if( sentenceOfSymbolsToMatchClone.length > 0 )\n        {\n          let theirNextSymbol = sentenceOfSymbolsToMatchClone[0];\n          if( this.lookaheadTokensToAvoid.indexOf( theirNextSymbol.type ) > -1 )\n          {\n            return [ 0, arrayOfSymbolsMatchedBeforeMe, sentenceOfSymbolsToMatch ];\n          }\n        }\n      }\n\n      arrayOfSymbolsMatchedBeforeMe.push( this.getFrozenClone() );\n      return [ this.length, arrayOfSymbolsMatchedBeforeMe, sentenceOfSymbolsToMatchClone ];\n    }\n\n    getFrozenClone(){\n\n      let frozenClone = new Nonterminal( this.seriesOfSymbolsIMustMatch, this.type );\n\n      frozenClone.seriesOfSymbolsIAbsorbedAndReplaced = this.seriesOfSymbolsIAbsorbedAndReplaced;\n\n      return frozenClone;\n    }\n\n}\n\n\n// WEBPACK FOOTER //\n// ./js/nonterminal.js","import Nonterminal from '../nonterminal';\n\nexport default class NonterminalFactory{\n  constructor(grammarObject){\n    this.grammarObject = grammarObject;\n    this.nonterminals = [];\n    for( let grammarRule of grammarObject )\n    {\n      let nonterminal = new Nonterminal( grammarRule[0], grammarRule[1] );\n      if( grammarRule.length > 2 ) // it has an array of lookaheadTokensToAvoid\n      {\n        nonterminal.lookaheadTokensToAvoid = grammarRule[2];\n      }\n      this.nonterminals.push( nonterminal );\n    }\n  }\n\n  getNonterminals(){\n    return this.nonterminals;\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ./js/factories/nonterminalfactory.js","import Token from '../token';\n\nexport default class TokenFactory{\n   constructor(){\n     this.tokens = [];\n   }\n\n    makeToken( regex, name, ignore = false )\n    {\n      var token = new Token( regex, name, 0, \"\", ignore );\n      this.tokens.push( token );\n      return token;\n    }\n\n    getTokens()\n    {\n      let IGNORE = true;\n      //this.makeToken( \"[0-9]+\", \"INT\" ); // second arg is how this token will present itself to the parser. Must be one character!\n      this.makeToken( /\\s+/, \"\", IGNORE );\n      this.makeToken( /&&/, \"&\" );\n      this.makeToken( /AND/i, \"&\" );\n      this.makeToken( /\\|\\|/, \"|\" ); // this is the escaped form of ||\n      this.makeToken( /XOR/i, \"^\" );\n      this.makeToken( /OR/i, \"|\" );\n      this.makeToken( /\\^/, \"^\" ); // this is the escaped form of ^\n      this.makeToken( /\\!/, \"!\" ); // this is the escaped form of !\n      this.makeToken( /NOT/i, \"!\" );\n      this.makeToken( /\\(/, \"(\" );\n      this.makeToken( /\\)/, \")\" );\n      this.makeToken( /\\+/, \"+\" );\n      this.makeToken( /-/, \"-\" );\n      this.makeToken( /\\*/, \"*\" );\n      this.makeToken( /\\//, \"/\" );\n      this.makeToken( /(true)(?![a-zA-Z0-9])/i, \"TRUE\" );\n      this.makeToken( /(false)(?![a-zA-Z0-9])/i, \"FALSE\" );\n      this.makeToken( /[-+]?[0-9]*\\.?[0-9]+/, \"NUM_LIT\" ); // second arg is how this token will present itself to the parser. Must be one character!\n      this.makeToken( /[a-zA-Z]+/, \"IDENT\" ); // second arg is how this token will present itself to the parser. Must be one character!\n      return this.tokens;\n    }\n}\n\n\n// WEBPACK FOOTER //\n// ./js/factories/tokenfactory.js","\nexport default class Lexer{\n\n  constructor( tokens ){\n    this.tokens = tokens;\n  }\n\n  tokenize( sentenceToTokenize ){\n    let arrayOfTokens = [];\n    var startingLetter = 0;\n    let stringToMatch = sentenceToTokenize; // want to keep original sentence for length/reference\n\n    while(  startingLetter < sentenceToTokenize.length )\n    {\n      let foundAMatchSomewhere = false;\n      for (var token of this.tokens)\n      {\n        let lengthOfMatch = 0;\n        [lengthOfMatch, arrayOfTokens, stringToMatch ] =\n        token.matchYourselfToStartOfThisStringAndAddSelfToArray( arrayOfTokens, stringToMatch, startingLetter );\n        if( lengthOfMatch > 0 )\n        {\n          foundAMatchSomewhere = true;\n          startingLetter += lengthOfMatch;\n          break; // START AT THE TOP OF OUR TOKEN LIST!!\n          // That is IMPORTANT.\n          // Some of our later tokens, like IDENT, are catch-alls that will greedily snatch up keywords like NOT\n        }\n      }\n      if(! foundAMatchSomewhere)\n      {\n        throw new Error(\"Illegal character \" + stringToMatch.charAt(0) + \" at position \" + startingLetter );\n      }\n    }\n    return arrayOfTokens;\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ./js/lexer.js","import Symbol from './symbol'\nimport Nonterminal from './nonterminal'\n\nexport default class Parser{\n  constructor( nonterminals ){\n    this.nonterminals = nonterminals;\n    this.state = {};\n  }\n\n  setState( state ) {\n    this.state = state; // generally just a lookup table for declared/initialized variables\n  }\n\n  // What does this do? Well, if there's a token of type IDENT, it's a variable.\n  // If that variable hasn't been declared, then how are we supposed to know what type it is?\n  // We'll be strongly-typed so that even a simple grammar can work effectively.\n  resolveIdentifiersToTypes( sentenceOfSymbols ){\n    let resolvedSymbols = [];\n    while( sentenceOfSymbols.length > 0 )\n    {\n      let symbol = sentenceOfSymbols.shift();\n      // we only care about tokens\n      if( symbol.constructor.name == \"Token\")\n      {\n        if( symbol.type == \"IDENT\")\n        {\n          // so now we can wrap our variable in the appropriate nonterminal type\n          if( typeof this.state[symbol._stringIMatched] == \"boolean\")\n          {\n            let nonterm = new Nonterminal( [\"IDENT\"], \"BOOLEAN\" );\n            nonterm.seriesOfSymbolsIAbsorbedAndReplaced = [ symbol ];\n            symbol = nonterm;\n          }\n          resolvedSymbols.push( symbol );\n          continue;\n        }\n        else\n        {\n          resolvedSymbols.push( symbol );\n        }\n      }\n      else\n      {\n        resolvedSymbols.push( symbol );\n      }\n    }\n    return resolvedSymbols;\n  }\n\n  getSimpleStringForSentence( sentenceOfSymbols ) {\n          let traceString = \"\";\n          for( var symbol of sentenceOfSymbols )\n          {\n            traceString += symbol.type + \" \";\n          }\n          return traceString;\n  }\n\n  parse( sentenceOfSymbols ){\n\n    sentenceOfSymbols = this.resolveIdentifiersToTypes( sentenceOfSymbols );\n    let arrayOfSymbolsMatchedBeforeMe = [];\n    let lengthOfMatch = 0;\n    let finished = false;\n    while( !finished ){\n        let madeAMatch = false;\n        //console.log(\"------- Starting at top of nonterminals list -------\" );\n        for( var nonterminal of this.nonterminals )\n        {\n          // we'll go through the input sentence\n          // and try to match this nonterminal to the beginning of it.\n          // if there's a match, then our nonterminal will be part of the future sentence.\n          // (replacing whatever portion it matched.)\n          // if there's no match, we want to pop a symbol off the start of the input sentence\n          // (moving it into the future sentence, since we )\n          let traceString = this.getSimpleStringForSentence( sentenceOfSymbols );\n          while( sentenceOfSymbols.length > 0 )\n          {\n            //console.log(\"USING nonterminal \" + nonterminal.toStringSimple() + \" to look at \" + traceString );\n            [lengthOfMatch, arrayOfSymbolsMatchedBeforeMe, sentenceOfSymbols ] =\n            nonterminal.matchYourselfToStartOfThisStringAndAddSelfToArray( arrayOfSymbolsMatchedBeforeMe, sentenceOfSymbols );\n\n            // if we matched, then the good news is, the input sentence is now changed\n            // so we don't have to worry about changing it.\n            // otherwise, we didn't match the beginning of the input sentence,\n            // so let's pop a symbol off it and try again.\n            if( lengthOfMatch == 0 )\n            {\n\n              arrayOfSymbolsMatchedBeforeMe.push( sentenceOfSymbols.shift() );\n              traceString = this.getSimpleStringForSentence( sentenceOfSymbols );\n            }\n            else\n            {\n              //console.log(\"MATCHED nonterminal \" + nonterminal.toStringSimple() + \" to sentence \" + traceString );\n              madeAMatch = true;\n            }\n          }\n\n          // ok, we did what we could. let's gather our processed items and hand them to the next nonterminal to process.\n          sentenceOfSymbols = arrayOfSymbolsMatchedBeforeMe.slice(0); // make sure we copy the items over and keep these two arrays discrete!\n          arrayOfSymbolsMatchedBeforeMe = [];\n\n          // are we done? if so, then don't bother looking at other nonterminals!\n          if( sentenceOfSymbols.length <= 1 )\n          {\n            finished == true;\n            break;\n          }\n\n          // we need to start from the top of our nonterminals if we made a match!\n          // order MATTERS.\n          if( madeAMatch ) break;\n\n        } // end of cycling through our array of nonterminals\n\n        if( sentenceOfSymbols.length <= 1 )\n        {\n          finished = true;\n        }\n\n    }  // end of our \"while\" loop going through sentenceOfSymbols until finished == true\n\n    return sentenceOfSymbols;\n  }\n\n\n\n\n}\n\n\n// WEBPACK FOOTER //\n// ./js/parser.js","\nclass BooleanJSONVisitor{\n  constructor( state ){\n    this.state = state;\n  }\n  setState( newstate ){\n    this.state = newstate;\n  }\n\n  execute( thingToEvaluate )\n  {\n        var ob = {};\n        ob.name = thingToEvaluate.type;\n        ob.value = thingToEvaluate.value = this.getBoolean( thingToEvaluate );\n        let symbolsMatched = thingToEvaluate.seriesOfSymbolsIAbsorbedAndReplaced;\n\n        switch( thingToEvaluate.type )\n        {\n            case \"TOKEN\":\n                return { name : thingToEvaluate.stringIActuallyMatched, value: this.getBoolean( thingToEvaluate ), condition: \"Condition Text Goes Here\" };\n            case \"BOOLEAN\":\n\n                ob.children = [];\n                if( symbolsMatched.length == 3 ) // there's a binary operator\n                {\n\n                  // either a binary operator or \"(\" + boolean + \")\"\n                  if( ( symbolsMatched[0].type == \"(\") && ( symbolsMatched[2].type == \")\") )\n                  {\n                    // we'll pass it through transparently\n                    // in other words, allow our middle child to represent us completely\n                    // since the user isn't interested in seeing each \"(\" represented with its own node onscreen\n                    return this.execute( symbolsMatched[ 1 ] );\n                  }\n                  else\n                  {\n                    ob.name = this.getNameForOperator( symbolsMatched[ 1 ].type );\n                    ob.children.push( this.execute( symbolsMatched[ 0 ]) );\n                    ob.children.push( this.execute( symbolsMatched[ 2 ]) );\n                  }\n                  \n                }\n                else if( symbolsMatched.length == 2 ) // there's a unary operator\n                {\n                  // the only unary operator\n                  ob.name = this.getNameForOperator( symbolsMatched[ 0 ].type ); \n                  ob.children.push( this.execute( symbolsMatched[ 1 ]) );\n                }\n                else\n                {\n                  return this.execute( symbolsMatched[ 0 ]);\n                }\n\n                break;\n\n            case \"IDENT\": // basically a passthrough. Assume our first child is a real operator, and return *its* json.\n                ob.name = thingToEvaluate._stringIMatched;\n        }\n        return ob;\n  }\n\n  getBoolean( nonterminalOrToken ){\n\n    if(nonterminalOrToken.constructor.name == \"Nonterminal\" )\n    {\n        let symbolsMatched = nonterminalOrToken.seriesOfSymbolsIAbsorbedAndReplaced;\n        let value = \"FOO\"; // declare this and, hey, initialize it with something we'll notice if there's an error.\n        if( symbolsMatched.length == 1 ) // we're a nonterminal that absorbed one other thing\n        {\n          value = this.getBoolean( symbolsMatched[0] );\n          return value;\n        }\n        else if( symbolsMatched.length == 3 )// we're a boolean comprising an operator and two operands\n        {\n          if( symbolsMatched[1].type == \"|\")\n          {\n            return this.getBoolean( symbolsMatched[0] ) || this.getBoolean( symbolsMatched[2] );\n          }\n          else if( symbolsMatched[1].type == \"&\")\n          {\n            return this.getBoolean( symbolsMatched[0] ) && this.getBoolean( symbolsMatched[2] );\n          }\n          else if( ( symbolsMatched[0].type == \"(\") && ( symbolsMatched[2].type == \")\") )\n          {\n            return this.getBoolean( symbolsMatched[1] );\n          }\n          else\n          {\n            throw new Error(\"DON'T KNOW WHAT THE OPERATOR OF THIS 3-ELEMENT SYMBOLSMATCHED IS:\" + JSON.stringify( symbolsMatched ));\n          }\n        }\n        else if( symbolsMatched.length == 2 )// we're a boolean with one operator -- probably a not\n        {\n          if( symbolsMatched[0].type == \"!\")\n          {\n            return ! this.getBoolean( symbolsMatched[1] );\n          }\n          else\n          {\n            throw new Error(\"DON'T KNOW WHAT THE OPERATOR OF THIS 2-ELEMENT SYMBOLSMATCHED IS:\" + JSON.stringify( symbolsMatched ));\n          }\n        }\n\n        throw new Error(\"UNKNOWN LENGTH OF SYMBOLSMATCHED:\" + JSON.stringify( symbolsMatched ));\n      }\n      else // it's a token\n      {\n        if( nonterminalOrToken.type.toUpperCase().indexOf( \"TRUE\" ) > -1 )\n        {\n          return true;\n        }\n        if( nonterminalOrToken.type.toUpperCase().indexOf( \"FALSE\" ) > -1 )\n        {\n          return false;\n        }\n        if( nonterminalOrToken.type.toUpperCase().indexOf( \"IDENT\" ) > -1 )\n        {\n          return this.state[ nonterminalOrToken._stringIMatched ];\n        }\n\n        throw new Error(\"nonterminalOrToken.type is \" + nonterminalOrToken.type );\n        return null;\n      }\n  }\n\n  getNameForOperator( operatorSymbol ){\n    if( operatorSymbol == \"|\" ) return \"OR\";\n    if( operatorSymbol == \"&\" ) return \"AND\";\n    if( operatorSymbol == \"^\" ) return \"XOR\";\n    if( operatorSymbol == \"!\" ) return \"NOT\";\n  }\n}\n\nmodule.exports = BooleanJSONVisitor;\n\n\n// WEBPACK FOOTER //\n// ./js/visitors/booleanjsonvisitor.js","import Symbol from './symbol'\n\nexport default class Token extends Symbol{\n\n  /***\n   * We are one of the two types of Symbol this parser deals with:\n   * Tokens and Nonterminals.\n   * A Token is basically a Symbol that contains one or more string characters.\n   * A Nonterminal is basically a Symbol that contains one or more Symbols\n   * (each of which can be either a Token or a Nonterminal).\n   *\n   * First argument will be a regex that will match some of the raw input stream.\n   * Second argument will be the internal representation I will use for myself\n   * (a string).\n   *\n   */\n  constructor( regexOfThingsIMustMatch, type, leng, stringIActuallyMatched, ignore, startIndex = -1 ){\n    super();\n    this.regexOfThingsIMustMatch = regexOfThingsIMustMatch;\n    this._type = type;\n    this.start = startIndex;\n    this._length = leng ? leng : 0;\n    this._stringIMatched = stringIActuallyMatched;\n    this._ignore = ignore;\n  }\n\n  get type(){\n    return this._type;\n  }\n\n  toStringSimple(){\n      return \" \" +  this._type + \" \" ;\n  }\n\n  get length(){\n    return this._length;\n  }\n\n  visit( evaluationVisitor ) {\n    return evaluationVisitor.execute( this );\n  }\n\n  matchYourselfToStartOfThisStringAndAddSelfToArray( symbolArray, stringToMatch, startingIndex ){\n      this._length = 0;\n      let match = this.regexOfThingsIMustMatch.exec( stringToMatch );\n      if( match != null && match.index == 0 ){\n        this._length = match[0].length;\n        // a frozen clone to record this moment,\n        // so that our data can go on to be reused without breaking things\n        let frozenToken = new Token( this.regexOfThingsIMustMatch, this.type, this._length,  match[0], this._ignore, startingIndex );\n        if( !this._ignore) symbolArray.push( frozenToken );\n        stringToMatch = stringToMatch.substring( this.length );\n      }\n      return [ this._length, symbolArray, stringToMatch ];\n  }\n\n  toString(){\n    return this.type + \"(\" + this.regexOfThingsIMustMatch.toString() + \")<\" + this._stringIMatched + \".\" + this.startingIndex + \">\";\n  }\n\n}\n\n\n\n\n// WEBPACK FOOTER //\n// ./js/token.js","//import Token from './token';\n//import Symbol from './token';\nimport Lexer from './lexer';\nimport Parser from './parser';\nimport BooleanJSONVisitor from './visitors/booleanjsonvisitor';\nimport TokenFactory from './factories/tokenfactory';\nimport NonterminalFactory from './factories/nonterminalfactory';\n\nexport default class Boolius{\n  constructor(){\n    let grammarObject = [\n      [  [\"TRUE\" ], \"BOOLEAN\" ],\n      [  [\"FALSE\" ], \"BOOLEAN\" ],\n      [  [\"!\", \"BOOLEAN\" ], \"BOOLEAN\" ],\n      [  [\"BOOLEAN\", \"&\", \"BOOLEAN\" ], \"BOOLEAN\" ],\n      [  [\"BOOLEAN\", \"|\", \"BOOLEAN\" ], \"BOOLEAN\" ],\n      [  [\"(\", \"BOOLEAN\", \")\" ], \"BOOLEAN\" ],\n      [  [\"NUMERIC\", \"^\", \"NUMERIC\" ], \"NUMERIC\" ],\n      [  [\"NUMERIC\", \"*\", \"NUMERIC\" ], \"NUMERIC\" ],\n      [  [\"NUMERIC\", \"+\", \"NUMERIC\" ], \"NUMERIC\", [\"*\", \"/\", \"^\"] ],\n      [  [\"NUMERIC\", \"-\", \"NUMERIC\" ], \"NUMERIC\", [\"*\", \"/\", \"^\"] ],\n      [  [\"NUM_LIT\" ], \"NUMERIC\" ],\n      [  [\"(\", \"NUMERIC\", \")\" ], \"NUMERIC\" ]\n    ];\n\n    // we set the state so that the parser knows the data type of each of these variables \n    // (in this case, boolean)\n    // and later so that the visitor can evaluate each node to determine if it is true or false.\n    this.state = {\"a\":false,\"b\":true,\"c\":false,\"d\":true,\"e\":false,\"f\":true,\"g\":false,\"h\":true,\"i\":false};\n    this.visitor = new BooleanJSONVisitor( this.state );\n    let tokenFactory = new TokenFactory();\n    let tokens = tokenFactory.getTokens();\n    let nonterminalFactory = new NonterminalFactory( grammarObject );\n    let nonterminals = nonterminalFactory.getNonterminals();\n    this.lexer = new Lexer( tokens );\n    this.parser = new Parser( nonterminals );\n    this.parser.setState( this.state );\n  }\n\n  parse( sentenceToParse ){\n    try\n    {\n      let sentenceOfTokens = this.lexer.tokenize( sentenceToParse );\n      this.parseTree = this.parser.parse( sentenceOfTokens );\n      return this.evaluateParseTree();\n    }\n    catch( e )\n    {\n      alert( e );\n    }\n  }\n\n  evaluateParseTree(){\n    let result = this.parseTree[0].visit( this.visitor );\n    return result;\n  }\n}\nwindow.Boolius = Boolius;\n\n\n\n// WEBPACK FOOTER //\n// ./js/boolius.js"],"sourceRoot":""}