{"version":3,"sources":["webpack://boolius/./src/visitors/booleanjsonvisitor.js","webpack://boolius/./src/boolius.js","webpack://boolius/./src/factories/tokenfactory.js","webpack://boolius/./src/lexer.js","webpack://boolius/./src/visitors/mathjsonvisitor.js","webpack://boolius/./src/mathius.js","webpack://boolius/./src/nonterminal.js","webpack://boolius/./src/factories/nonterminalfactory.js","webpack://boolius/./src/parser.js","webpack://boolius/./src/symbol.js","webpack://boolius/./src/token.js","webpack://boolius/./src/visualizer.js","webpack://boolius/./src/visitors/xmlparsetimevisitor.js","webpack://boolius/./src/visitors/xmljsonvisitor.js","webpack://boolius/./src/xmlius.js","webpack://boolius/webpack/bootstrap","webpack://boolius/webpack/runtime/define property getters","webpack://boolius/webpack/runtime/hasOwnProperty shorthand","webpack://boolius/webpack/startup"],"names":["BooleanJSONVisitor","state","this","newstate","thingToEvaluate","ob","name","type","value","getBoolean","symbolsMatched","seriesOfSymbolsIAbsorbedAndReplaced","stringIActuallyMatched","condition","children","length","execute","getNameForOperator","push","_stringIMatched","nonterminalOrToken","Nonterminal","Error","JSON","stringify","toUpperCase","indexOf","operatorSymbol","Boolius","tokenDefinitions","grammarObject","visitor","lexer","Lexer","parser","Parser","setState","sentenceToParse","sentenceOfTokens","tokenize","parseTree","parse","evaluateParseTree","e","alert","visit","TokenFactory","tokens","tokenDefinition","makeToken","regex","ignore","token","Token","makeTokenFromDefinition","tokenFactory","getTokens","sentenceToTokenize","arrayOfTokens","startingLetter","stringToMatch","foundAMatchSomewhere","lengthOfMatch","matchYourselfToStartOfThisStringAndAddSelfToArray","charAt","MathJSONVisitor","getValue","Math","pow","parseInt","Mathius","console","error","seriesOfSymbolsIMustMatch","wildcardMode","lookaheadTokensToAvoid","join","returnString","toString","evaluationVisitor","arrayOfSymbolsMatchedBeforeMe","sentenceOfSymbolsToMatch","parseTimeVisitor","sentenceOfSymbolsToMatchClone","slice","seriesOfSymbolsIMustMatchClone","done","symbolThatBreaksWildcard","mySymbol","shift","theirSymbol","getFrozenClone","theirNextSymbol","frozenClone","Symbol","NonterminalFactory","nonterminals","grammarRule","nonterminal","nonterminalFactory","getNonterminals","sentenceOfSymbols","resolvedSymbols","symbol","nonterm","traceString","finished","resolveIdentifiersToTypes","madeAMatch","getSimpleStringForSentence","stringAndPosition","getLastTokenDescriptionOfSymbol","errorString","string","position","getStringAndPositionOfTokensOfSymbol","earliestPosition","start","tokenString","kid","_name","someName","regexOfThingsIMustMatch","givenType","leng","startIndex","_type","_length","_ignore","symbolArray","startingIndex","match","exec","index","frozenToken","substring","window","onload","changeMode","newMode","evaluator","makeEvaluatorAndInitialize","XMLius","newEvaluator","statement","hintText","constructor","assignEvaluator","d3","select","node","text","evaluateStatement","on","toLowerCase","max","innerWidth","document","querySelector","root","winHeight","innerHeight","m","w","h","i","tree","layout","size","diagonal","svg","projection","d","y","x","vis","append","attr","json","x0","y0","property","expressionString","forEach","delay","toggle","_children","update","showOverlay","undefined","hasNoChildren","myVar","updateObjectAndItsChildren","attributeText","attributes","showValueOverlay","val","$","html","modal","newObjectTemp","rootTemp","source","duration","event","altKey","nodes","reverse","widthInPixels","style","replace","widthPerNode","depth","transition","modalOverlayTimeout","selectAll","data","id","nodeEnter","enter","clearTimeout","setTimeout","nodeUpdate","nodeExit","exit","remove","link","links","target","insert","o","keyCode","XMLParseTimeVisitor","verifyOpeningAndCloseTagsMatch","verifyTagContentIsLegal","verifyAttributeContentIsLegal","closeTagName","openTagName","getTagName","XMLJSONVisitor","trim","executedSymbol","parentnode","optionalAttributes","getAttributes","consolidateChildrenThatAreTokens","child","Array","isArray","concat","arrayOfSymbolsThatMightBeTokens","symbolChildrenOnly","runningStringOfTokenText","tokenConsolidatingStrings","makeTokenWrappingString","stringToWrap","childOfXMLNode","atts","valueForName","attributeValueIndex","commentstring","contentstring","xmlParseTimeVisitor","__webpack_module_cache__","__webpack_require__","moduleId","exports","module","__webpack_modules__","definition","key","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call"],"mappings":"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","file":"boolius.bundle.js","sourcesContent":["import Nonterminal from '../nonterminal';\n\nexport default class BooleanJSONVisitor {\n  constructor(state) {\n    this.state = state;\n  }\n  setState(newstate) {\n    this.state = newstate;\n  }\n\n  execute(thingToEvaluate) {\n\n    var ob = {};\n    ob.name = thingToEvaluate.type;\n\n    ob.value = thingToEvaluate.value = this.getBoolean(thingToEvaluate);\n    let symbolsMatched = thingToEvaluate.seriesOfSymbolsIAbsorbedAndReplaced;\n\n    switch (thingToEvaluate.type) {\n      case \"TOKEN\":\n        return {\n          name: thingToEvaluate.stringIActuallyMatched,\n          value: this.getBoolean(thingToEvaluate),\n          condition: \"Condition Text Goes Here\",\n        };\n      case \"BOOLEAN\":\n\n        ob.children = [];\n        if (symbolsMatched.length == 3) {\n          // there's a binary operator\n          // either a binary operator or \"(\" + boolean + \")\"\n          if (symbolsMatched[0].type == \"(\" && symbolsMatched[2].type == \")\") {\n            // we'll pass it through transparently\n            // in other words, allow our middle child to represent us completely\n            // since the user isn't interested in seeing each \"(\" represented with its own node onscreen\n            return this.execute(symbolsMatched[1]);\n          } else {\n            ob.name = this.getNameForOperator(symbolsMatched[1].type);\n            ob.children.push(this.execute(symbolsMatched[0]));\n            ob.children.push(this.execute(symbolsMatched[2]));\n          }\n        } else if (symbolsMatched.length == 2) {\n          // there's a unary operator\n          // the only unary operator\n          ob.name = this.getNameForOperator(symbolsMatched[0].type);\n          ob.children.push(this.execute(symbolsMatched[1]));\n        } else {\n          return this.execute(symbolsMatched[0]);\n        }\n\n        break;\n\n      case \"IDENT\": // basically a passthrough. Assume our first child is a real operator, and return *its* json.\n        ob.name = thingToEvaluate._stringIMatched;\n    }\n    return ob;\n  }\n\n  getBoolean(nonterminalOrToken) {\n     if (nonterminalOrToken instanceof Nonterminal) {\n      let symbolsMatched =\n        nonterminalOrToken.seriesOfSymbolsIAbsorbedAndReplaced;\n      let value = \"FOO\"; // declare this and, hey, initialize it with something we'll notice if there's an error.\n      if (symbolsMatched.length == 1) {\n        // we're a nonterminal that absorbed one other thing\n        value = this.getBoolean(symbolsMatched[0]);\n        return value;\n      } else if (symbolsMatched.length == 3) {\n        // we're a boolean comprising an operator and two operands\n        if (symbolsMatched[1].type == \"|\") {\n          return (\n            this.getBoolean(symbolsMatched[0]) ||\n            this.getBoolean(symbolsMatched[2])\n          );\n        } else if (symbolsMatched[1].type == \"&\") {\n          return (\n            this.getBoolean(symbolsMatched[0]) &&\n            this.getBoolean(symbolsMatched[2])\n          );\n        } else if (\n          symbolsMatched[0].type == \"(\" &&\n          symbolsMatched[2].type == \")\"\n        ) {\n          return this.getBoolean(symbolsMatched[1]);\n        } else {\n          throw new Error(\n            \"DON'T KNOW WHAT THE OPERATOR OF THIS 3-ELEMENT SYMBOLSMATCHED IS:\" +\n              JSON.stringify(symbolsMatched)\n          );\n        }\n      } else if (symbolsMatched.length == 2) {\n        // we're a boolean with one operator -- probably a not\n        if (symbolsMatched[0].type == \"!\") {\n          return !this.getBoolean(symbolsMatched[1]);\n        } else {\n          throw new Error(\n            \"DON'T KNOW WHAT THE OPERATOR OF THIS 2-ELEMENT SYMBOLSMATCHED IS:\" +\n              JSON.stringify(symbolsMatched)\n          );\n        }\n      }\n\n      throw new Error(\n        \"UNKNOWN LENGTH OF SYMBOLSMATCHED:\" + JSON.stringify(symbolsMatched)\n      );\n    } // it's a token\n    else {\n      if (nonterminalOrToken.type.toUpperCase().indexOf(\"TRUE\") > -1) {\n        return true;\n      }\n      if (nonterminalOrToken.type.toUpperCase().indexOf(\"FALSE\") > -1) {\n        return false;\n      }\n      if (nonterminalOrToken.type.toUpperCase().indexOf(\"IDENT\") > -1) {\n        return this.state[nonterminalOrToken._stringIMatched];\n      }\n\n      throw new Error(\"In booleanjsonvisitor, nonterminalOrToken.type is \" + nonterminalOrToken.type);\n      return null;\n    }\n  }\n\n  getNameForOperator(operatorSymbol) {\n    if (operatorSymbol == \"|\") return \"OR\";\n    if (operatorSymbol == \"&\") return \"AND\";\n    if (operatorSymbol == \"^\") return \"XOR\";\n    if (operatorSymbol == \"!\") return \"NOT\";\n  }\n}\n","import Lexer from './lexer';\nimport Parser from './parser';\nimport BooleanJSONVisitor from './visitors/booleanjsonvisitor';\n\nexport default class Boolius{\n\n  constructor( tokenDefinitions, grammarObject ){\n\n    // we set the state so that the parser knows the data type of each of these variables\n    // (in this case, boolean)\n    // and later so that the visitor can evaluate each node to determine if it is true or false.\n    this.state = {\"a\":false,\"b\":true,\"c\":false,\"d\":true,\"e\":false,\"f\":true,\"g\":false,\"h\":true,\"i\":false};\n    this.visitor = new BooleanJSONVisitor( this.state );\n    // lay the groundwork for lexical analysis\n    this.lexer = new Lexer( tokenDefinitions );\n    this.parser = new Parser( grammarObject );\n    this.parser.setState( this.state );\n  }\n  \n  parse( sentenceToParse ){\n    try\n    {\n      let sentenceOfTokens = this.lexer.tokenize( sentenceToParse );\n      this.parseTree = this.parser.parse( sentenceOfTokens );\n      return this.evaluateParseTree();\n    }\n    catch( e )\n    {\n      alert(\"Here is the boolius error:\"  + e + \" because sentenceToParse is \" + sentenceToParse );\n    }\n  }\n\n  evaluateParseTree(){\n    let result = this.parseTree[0].visit( this.visitor );\n    return result;\n  }\n}\n","import Token from '../token';\n\nexport default class TokenFactory{\n   constructor( tokenDefinitions ){\n     this.tokens = [];\n     this.tokenDefinitions = tokenDefinitions;\n   }\n\n   makeTokenFromDefinition( tokenDefinition ){\n     return this.makeToken( tokenDefinition[0], tokenDefinition[1], tokenDefinition.length > 2 ? tokenDefinition[2] : false );\n   }\n    makeToken( regex, name, ignore = false )\n    {\n      var token = new Token( regex, name, 0, \"\", ignore );\n      this.tokens.push( token );\n      return token;\n    }\n\n    getTokens()\n    {\n      let IGNORE = true;\n\n      for( let tokenDefinition of this.tokenDefinitions )\n      {\n        this.makeTokenFromDefinition( tokenDefinition )\n      }\n      return this.tokens;\n\n    }\n}","import TokenFactory from \"./factories/tokenfactory\";\n\nexport default class Lexer {\n  constructor(tokenDefinitions) {\n    let tokenFactory = new TokenFactory(tokenDefinitions);\n    this.tokens = tokenFactory.getTokens();\n  }\n\n  tokenize(sentenceToTokenize) {\n    let arrayOfTokens = [];\n    var startingLetter = 0;\n    let stringToMatch = sentenceToTokenize; // want to keep original sentence for length/reference\n\n    while (startingLetter < sentenceToTokenize.length) {\n      let foundAMatchSomewhere = false;\n      for (var token of this.tokens) {\n        let lengthOfMatch = 0;\n        [\n          lengthOfMatch,\n          arrayOfTokens,\n          stringToMatch\n        ] = token.matchYourselfToStartOfThisStringAndAddSelfToArray(\n          arrayOfTokens,\n          stringToMatch,\n          startingLetter\n        );\n        if (lengthOfMatch > 0) {\n          foundAMatchSomewhere = true;\n          startingLetter += lengthOfMatch;\n          break; // START AT THE TOP OF OUR TOKEN LIST!!\n          // That is IMPORTANT.\n          // Some of our later tokens, like IDENT, are catch-alls that will greedily snatch up keywords like NOT\n        }\n      }\n      if (!foundAMatchSomewhere) {\n        throw new Error(\n          \"Illegal character \" +\n            stringToMatch.charAt(0) +\n            \" at position \" +\n            startingLetter\n        );\n      }\n    }\n    return arrayOfTokens;\n  }\n}\n","import Nonterminal from \"../nonterminal\";\n\nexport default class MathJSONVisitor{\n  constructor( state ){\n    this.state = state;\n  }\n  setState( newstate ){\n    this.state = newstate;\n  }\n\n  execute( thingToEvaluate )\n  {\n        var ob = {};\n        ob.name = thingToEvaluate.type;\n        ob.value = thingToEvaluate.value = this.getValue( thingToEvaluate );\n\n        let symbolsMatched = thingToEvaluate.seriesOfSymbolsIAbsorbedAndReplaced;\n\n        switch( thingToEvaluate.type )\n        {\n            case \"NUM_LIT\":\n                return { name : this.getValue( thingToEvaluate ), value: this.getValue( thingToEvaluate ), condition: \"Condition Text Goes Here\" };\n            case \"NUMERIC\":\n\n                ob.children = [];\n                if( symbolsMatched.length == 3 ) // there's a binary operator\n                {\n\n                  // either a binary operator or \"(\" + boolean + \")\"\n                  if( ( symbolsMatched[0].type == \"(\") && ( symbolsMatched[2].type == \")\") )\n                  {\n                    // we'll pass it through transparently\n                    // in other words, allow our middle child to represent us completely\n                    // since the user isn't interested in seeing each \"(\" represented with its own node onscreen\n                    return this.execute( symbolsMatched[ 1 ] );\n                  }\n                  else\n                  {\n                    ob.name = symbolsMatched[ 1 ].type;\n                    ob.children.push( this.execute( symbolsMatched[ 0 ]) );\n                    ob.children.push( this.execute( symbolsMatched[ 2 ]) );\n                  }\n\n                }\n                else if( symbolsMatched.length == 2 ) // there's a unary operator\n                {\n                  // the only unary operator\n                  ob.name = symbolsMatched[ 0 ].type;\n                  ob.children.push( this.execute( symbolsMatched[ 1 ]) );\n                }\n                else\n                {\n                  return this.execute( symbolsMatched[ 0 ]);\n                }\n\n                break;\n\n            case \"IDENT\": // basically a passthrough. Assume our first child is a real operator, and return *its* json.\n                ob.name = thingToEvaluate._stringIMatched;\n        }\n        return ob;\n  }\n\n  getValue( nonterminalOrToken ){\n    if(nonterminalOrToken instanceof Nonterminal)\n    {\n        let symbolsMatched = nonterminalOrToken.seriesOfSymbolsIAbsorbedAndReplaced;\n        let value = \"FOO\"; // declare this and, hey, initialize it with something we'll notice if there's an error.\n        if( symbolsMatched.length == 1 ) // we're a nonterminal that absorbed one other thing\n        {\n          value = this.getValue( symbolsMatched[0] );\n          return value;\n        }\n        else if( symbolsMatched.length == 3 )// we're a boolean comprising an operator and two operands\n        {\n          // or maybe we're just a numeric wrapped in parens!\n\n          if( ( symbolsMatched[0].type == \"(\") && ( symbolsMatched[2].type == \")\") )\n          {\n            return this.getValue( symbolsMatched[1] );\n          }\n\n          if( symbolsMatched[1].type == \"+\")\n          {\n            return this.getValue( symbolsMatched[0] ) + this.getValue( symbolsMatched[2] );\n          }\n          else if( symbolsMatched[1].type == \"-\")\n          {\n            return this.getValue( symbolsMatched[0] ) - this.getValue( symbolsMatched[2] );\n          }\n          else if( symbolsMatched[1].type == \"*\")\n          {\n            return this.getValue( symbolsMatched[0] ) * this.getValue( symbolsMatched[2] );\n          }\n          else if( symbolsMatched[1].type == \"/\")\n          {\n            return this.getValue( symbolsMatched[0] ) / this.getValue( symbolsMatched[2] );\n          }\n          else if( symbolsMatched[1].type == \"^\")\n          {\n            return Math.pow( this.getValue( symbolsMatched[0] ), this.getValue( symbolsMatched[2] ));\n          }\n          else\n          {\n            throw new Error(\"WE HAVE 3 SYMBOLS BUT I DON'T KNOW WHAT THIS IS:\" + JSON.stringify( symbolsMatched ));\n          }\n        }\n        else if( symbolsMatched.length == 2 )// we're a boolean with one operator\n        {\n          if( symbolsMatched[0].type == \"+\")\n          {\n            return this.getValue( symbolsMatched[1] );\n          }\n          if( symbolsMatched[0].type == \"-\")\n          {\n            return -1 * this.getValue( symbolsMatched[1] );\n          }\n          else\n          {\n            throw new Error(\"IN NUMERICVISITOR, DON'T KNOW WHAT THE OPERATOR OF THIS 2-ELEMENT SYMBOLSMATCHED IS:\" + JSON.stringify( symbolsMatched ));\n          }\n        }\n\n\n        throw new Error(\"UNKNOWN LENGTH OF SYMBOLSMATCHED:\" + JSON.stringify( symbolsMatched ));\n      }\n      else // it's a token\n      {\n        if( nonterminalOrToken.type.toUpperCase().indexOf( \"NUM_LIT\" ) > -1 )\n        {\n          return parseInt( nonterminalOrToken._stringIMatched );\n        }\n        throw new Error(\"nonterminalOrToken.type is \" + nonterminalOrToken.type );\n        return null;\n      }\n  }\n\n  getNameForOperator( operatorSymbol ){\n    if( operatorSymbol == \"|\" ) return \"OR\";\n    if( operatorSymbol == \"&\" ) return \"AND\";\n    if( operatorSymbol == \"^\" ) return \"XOR\";\n    if( operatorSymbol == \"!\" ) return \"NOT\";\n  }\n}\n","//import Token from './token';\n//import Symbol from './token';\nimport Lexer from './lexer';\nimport Parser from './parser';\nimport NumericVisitor from './visitors/numericvisitor';\nimport MathJSONVisitor from './visitors/mathjsonvisitor';\nimport TokenFactory from './factories/tokenfactory';\nimport NonterminalFactory from './factories/nonterminalfactory';\n\nexport default class Mathius{\n  constructor( tokenDefinitions, grammarObject ){\n\n    // we set the state so that the parser knows the data type of each of these variables\n    // (in this case, boolean)\n    // and later so that the visitor can evaluate each node to determine if it is true or false.\n    this.state = {\"a\":false,\"b\":true,\"c\":false,\"d\":true,\"e\":false,\"f\":true,\"g\":false,\"h\":true,\"i\":false};\n\n    this.visitor = new MathJSONVisitor(  this.state );\n    // lay the groundwork for lexical analysis\n    this.lexer = new Lexer( tokenDefinitions );\n    this.parser = new Parser( grammarObject );\n    this.parser.setState( this.state );\n  }\n\n\n\n  parse( sentenceToParse ){\n    try\n    {\n      let sentenceOfTokens = this.lexer.tokenize( sentenceToParse );\n      this.parseTree = this.parser.parse( sentenceOfTokens );\n      return this.evaluateParseTree();\n    }\n    catch( e )\n    {\n      console.error( \"ERROR PARSING OR EVALUATING:\" + e );\n    }\n  }\n\n  evaluateParseTree(){\n    let result = this.parseTree[0].visit( this.visitor );\n    return result;\n  }\n}\n","import Symbol from './symbol'\n\nexport default class Nonterminal extends Symbol{\n\n    constructor( seriesOfSymbolsIMustMatch, type ){\n      super();\n      this.seriesOfSymbolsIMustMatch  = seriesOfSymbolsIMustMatch;\n      this.type                       = type;\n      this.seriesOfSymbolsIAbsorbedAndReplaced = [];\n      this.wildcardMode = false;\n      this.lookaheadTokensToAvoid = null;\n    }\n\n    toStringSimple(){\n      return this.type + \"(\" + this.seriesOfSymbolsIMustMatch.join( ' ' ) + \")\";\n    }\n\n    toString(){\n      let returnString = this.type + \" (\";\n\n      for( var symbol of this.seriesOfSymbolsIAbsorbedAndReplaced )\n      {\n        returnString += \" \" + symbol.toString();\n      }\n      return returnString;\n    }\n\n    get symbolsMatched(){\n      return this.seriesOfSymbolsIAbsorbedAndReplaced;\n    }\n\n    get length(){\n      return this.seriesOfSymbolsIAbsorbedAndReplaced.length;\n    }\n\n    visit( evaluationVisitor ) {\n      return evaluationVisitor.execute( this );\n    }\n\n    matchYourselfToStartOfThisStringAndAddSelfToArray( arrayOfSymbolsMatchedBeforeMe, sentenceOfSymbolsToMatch, parseTimeVisitor ){\n\n      // clone it so we don't destroy the original in case we're only a partial match\n\n      let sentenceOfSymbolsToMatchClone = sentenceOfSymbolsToMatch.slice(0);\n\n      \n\n      // same with ours\n\n      let seriesOfSymbolsIMustMatchClone = this.seriesOfSymbolsIMustMatch.slice(0);\n\n      this.seriesOfSymbolsIAbsorbedAndReplaced = [];\n\n      let done = false;\n\n      // in case of wildcard, we need to know what the previous symbol was\n\n      let symbolThatBreaksWildcard = null;\n\n      while( seriesOfSymbolsIMustMatchClone.length > 0 )\n      {\n        let mySymbol = seriesOfSymbolsIMustMatchClone.shift();\n        let theirSymbol = sentenceOfSymbolsToMatchClone.shift();\n        // if they ran out of symbols, then we're obviously not a match. UNLESS we were in wildcard mode.\n        if( ! theirSymbol )\n        {\n            this.seriesOfSymbolsIAbsorbedAndReplaced = [];\n            return [ 0, arrayOfSymbolsMatchedBeforeMe, sentenceOfSymbolsToMatch ];\n        }\n\n        if( mySymbol == \"WILDCARD\" )\n        {\n          this.wildcardMode = true;\n          symbolThatBreaksWildcard = seriesOfSymbolsIMustMatchClone.shift();\n          while( theirSymbol.type != symbolThatBreaksWildcard )\n          {\n            this.seriesOfSymbolsIAbsorbedAndReplaced.push( theirSymbol );\n\n            if( sentenceOfSymbolsToMatchClone.length == 0 ) // they ran out of symbols in their sentence!\n            {\n              if( seriesOfSymbolsIMustMatchClone.length == 0 ) // that wildcard was my last character\n              {\n                arrayOfSymbolsMatchedBeforeMe.push( this.getFrozenClone() );\n                return [ this.length, arrayOfSymbolsMatchedBeforeMe, sentenceOfSymbolsToMatchClone ];\n              }\n              else // failure -- we had more to match but they ran out first\n              {\n                this.seriesOfSymbolsIAbsorbedAndReplaced = [];\n                return [ 0, arrayOfSymbolsMatchedBeforeMe, sentenceOfSymbolsToMatch ];\n              }\n            }\n            else\n            {\n              theirSymbol = sentenceOfSymbolsToMatchClone.shift();\n\n            }\n          } //end of tight loop inside wildcard mode, but still in wildcard mode\n\n          // absorb the one that got us out of the wildcard\n          // i.e., it matched the symbol of ours that follows (and thus ends) the wildcard\n\n          this.seriesOfSymbolsIAbsorbedAndReplaced.push( theirSymbol );\n\n          // we made it through!\n          // if that was the last one, then we should skip the rest of the matching and go right to success\n          // if not, keep the process going -- get a new symbol from them\n          if( seriesOfSymbolsIMustMatchClone.length == 0 ) // we don't have any more\n          {\n            done = true;\n          }\n          else if( sentenceOfSymbolsToMatchClone.length > 0 ) // we have more, and they have more things that need matching\n          {\n            theirSymbol = sentenceOfSymbolsToMatchClone.shift();\n            // but if our wildcard was our last character, then we should leave\n          }\n          else // we have more, but they don't!\n          {\n            this.seriesOfSymbolsIAbsorbedAndReplaced = [];\n            return [ 0, arrayOfSymbolsMatchedBeforeMe, sentenceOfSymbolsToMatch ];\n          }\n        } // end of wildcard loop\n\n        if (!done )\n        {\n          // do they match? i.e., the next character in the sentence -- does it match the next symbol in my internal list?\n          if( theirSymbol.type != mySymbol )\n          {\n            return [ 0, arrayOfSymbolsMatchedBeforeMe, sentenceOfSymbolsToMatch ];\n          }\n          else\n          {\n            this.seriesOfSymbolsIAbsorbedAndReplaced.push( theirSymbol );\n          }\n        }\n      }// bottom of seriesOfSymbolsIMustMatchClone.length loop\n\n      // we made it through -- matched everything we needed to -- but maybe there's a problem after all...\n      // now, there's an edge case -- good for operator precedence enforcement\n      // -- the lookahead tokens.\n      // maybe we matched everything we needed, and that's great,\n      // but maybe the next token in the sentence is a dealbreaker!\n      // for example, 1 + 2 * 3\n      // if we're NUMERIC + NUMERIC, we'll find a match\n      // but that is wrong! because the next token *after* our possible match is a *\n      // and that has higher precedence than +\n\n\n      if( this.lookaheadTokensToAvoid )\n      {\n        if( sentenceOfSymbolsToMatchClone.length > 0 )\n        {\n          let theirNextSymbol = sentenceOfSymbolsToMatchClone[0];\n          if( this.lookaheadTokensToAvoid.indexOf( theirNextSymbol.type ) > -1 )\n          {\n            return [ 0, arrayOfSymbolsMatchedBeforeMe, sentenceOfSymbolsToMatch ];\n          }\n        }\n      }\n      // we made it here! must be a basically perfect match.\n      // but let's see if there's a context stack for this parser\n      // e.g., an XML parser keeps a stack of open nodes\n      // so that when you hit a closing tag for a node\n      // the parser can know if it's the most recently opened tag\n      if( ! parseTimeVisitor || parseTimeVisitor.execute( this ) )\n      {\n        arrayOfSymbolsMatchedBeforeMe.push( this.getFrozenClone() );\n        return [ this.length, arrayOfSymbolsMatchedBeforeMe, sentenceOfSymbolsToMatchClone ];\n      }\n      else\n      {\n        return [ 0, arrayOfSymbolsMatchedBeforeMe, sentenceOfSymbolsToMatch ];\n      }\n    }\n\n    getFrozenClone(){\n\n      let frozenClone = new Nonterminal( this.seriesOfSymbolsIMustMatch, this.type );\n\n      frozenClone.seriesOfSymbolsIAbsorbedAndReplaced = this.seriesOfSymbolsIAbsorbedAndReplaced;\n\n      return frozenClone;\n    }\n\n}","import Nonterminal from '../nonterminal';\n\nexport default class NonterminalFactory{\n  constructor(grammarObject){\n    this.grammarObject = grammarObject;\n    this.nonterminals = [];\n    for( let grammarRule of grammarObject )\n    {\n      let nonterminal = new Nonterminal( grammarRule[0], grammarRule[1] );\n      if( grammarRule.length > 2 ) // it has an array of lookaheadTokensToAvoid\n      {\n        nonterminal.lookaheadTokensToAvoid = grammarRule[2];\n      }\n      this.nonterminals.push( nonterminal );\n    }\n  }\n\n  getNonterminals(){\n    return this.nonterminals;\n  }\n}","import Symbol from \"./symbol\";\nimport Nonterminal from \"./nonterminal\";\nimport Token from \"./token\";\nimport NonterminalFactory from \"./factories/nonterminalfactory\";\n\nexport default class Parser {\n  constructor(grammarObject) {\n    let nonterminalFactory = new NonterminalFactory(grammarObject);\n    this.nonterminals = nonterminalFactory.getNonterminals();\n    this.state = {};\n  }\n\n  setState(state) {\n    this.state = state; // generally just a lookup table for declared/initialized variables\n  }\n\n  // What does this do? Well, if there's a token of type IDENT, it's a variable.\n  // If that variable hasn't been declared, then how are we supposed to know what type it is?\n  // We'll be strongly-typed so that even a simple grammar can work effectively.\n  resolveIdentifiersToTypes(sentenceOfSymbols) {\n    let resolvedSymbols = [];\n    while (sentenceOfSymbols.length > 0) {\n      // comments might have been turned into null symbols\n      // in which case we should skip them\n      let symbol = sentenceOfSymbols.shift();\n      // we only care about tokens\n      if (symbol instanceof Token) {\n        if (symbol.type == \"IDENT\") {\n          // so now we can wrap our variable in the appropriate nonterminal type\n          if (typeof this.state[symbol._stringIMatched] == \"boolean\") {\n            let nonterm = new Nonterminal([\"IDENT\"], \"BOOLEAN\");\n            nonterm.seriesOfSymbolsIAbsorbedAndReplaced = [symbol];\n            symbol = nonterm;\n          }\n          resolvedSymbols.push(symbol);\n          continue;\n        } else {\n          resolvedSymbols.push(symbol);\n        }\n      } else {\n        resolvedSymbols.push(symbol);\n      }\n    }\n    return resolvedSymbols;\n  }\n\n  getSimpleStringForSentence(sentenceOfSymbols) {\n    let traceString = \"\";\n    for (var symbol of sentenceOfSymbols) {\n      traceString += symbol.type + \" \";\n    }\n    return traceString;\n  }\n\n  parse(sentenceOfSymbols, parseTimeVisitor = null) {\n    sentenceOfSymbols = this.resolveIdentifiersToTypes(sentenceOfSymbols);\n    let arrayOfSymbolsMatchedBeforeMe = [];\n    let lengthOfMatch = 0;\n    let finished = false;\n\n    // actually, if our sentence only has one symbol, it may very well be finished already\n    if (sentenceOfSymbols.length == 1) finished = true;\n    while (!finished) {\n      let madeAMatch = false;\n      for (var nonterminal of this.nonterminals) {\n        // we'll go through the input sentence\n        // and try to match this nonterminal to the beginning of it.\n        // if there's a match, then our nonterminal will be part of the future sentence.\n        // (replacing whatever portion it matched.)\n        // if there's no match, we want to pop a symbol off the start of the input sentence\n        // (moving it into the future sentence, since we )\n        let traceString = this.getSimpleStringForSentence(sentenceOfSymbols);\n        while (sentenceOfSymbols.length > 0) {\n          //            console.log(\"USING nonterminal \" + nonterminal.toStringSimple() + \" to look at \" + traceString );\n          [\n            lengthOfMatch,\n            arrayOfSymbolsMatchedBeforeMe,\n            sentenceOfSymbols\n          ] = nonterminal.matchYourselfToStartOfThisStringAndAddSelfToArray(\n            arrayOfSymbolsMatchedBeforeMe,\n            sentenceOfSymbols,\n            parseTimeVisitor\n          );\n\n          // if we matched, then the good news is, the input sentence is now changed\n          // so we don't have to worry about changing it.\n          // otherwise, we didn't match the beginning of the input sentence,\n          // so let's pop a symbol off it and try again.\n          if (lengthOfMatch === 0) {\n            arrayOfSymbolsMatchedBeforeMe.push(sentenceOfSymbols.shift());\n            traceString = this.getSimpleStringForSentence(sentenceOfSymbols);\n          } else {\n            //console.log(\"MATCHED nonterminal \" + nonterminal.toStringSimple() + \" to sentence \" + traceString );\n            madeAMatch = true;\n          }\n        }\n\n        // ok, we did what we could. let's gather our processed items and hand them to the next nonterminal to process.\n        sentenceOfSymbols = arrayOfSymbolsMatchedBeforeMe.slice(0); // make sure we copy the items over and keep these two arrays discrete!\n        arrayOfSymbolsMatchedBeforeMe = [];\n        //console.log(\"sentenceOfSymbols is now \" + sentenceOfSymbols );\n        // are we done? if so, then don't bother looking at other nonterminals!\n        if (sentenceOfSymbols.length <= 1) {\n          finished == true;\n          break;\n        }\n\n        // we need to start from the top of our nonterminals if we made a match!\n        // order MATTERS.\n        if (madeAMatch) break;\n      } // end of cycling through our array of nonterminals\n\n      // what if we made it through all our nonterminals and didn't make a match?\n      // error, that's what!\n      if (!madeAMatch) {\n\n        let stringAndPosition = this.getLastTokenDescriptionOfSymbol(\n          sentenceOfSymbols[0]\n        );\n        let errorString =\n          \"\\nSyntax error:\" +\n          stringAndPosition.string +\n          \" at position \" +\n          stringAndPosition.position;\n        throw new Error(errorString);\n        finished = true;\n      }\n\n      if (sentenceOfSymbols.length <= 1) {\n        finished = true;\n      }\n    } // end of our \"while\" loop going through sentenceOfSymbols until finished == true\n\n    return sentenceOfSymbols;\n  }\n\n  getLastTokenDescriptionOfSymbol(symbol) {\n\n    return this.getStringAndPositionOfTokensOfSymbol(\n      symbol.symbolsMatched[symbol.symbolsMatched.length - 1]\n    );\n  }\n\n  getStringAndPositionOfTokensOfSymbol(symbol, earliestPosition = 100000000) {\n    if (symbol instanceof Token) {\n      return { string: symbol._stringIMatched, position: symbol.start };\n    } else if (symbol instanceof Nonterminal) {\n      let tokenString = \"\";\n      for (let kid of symbol.symbolsMatched) {\n        let stringAndPosition = this.getStringAndPositionOfTokensOfSymbol(\n          kid,\n          earliestPosition\n        );\n        tokenString += stringAndPosition.string;\n        if (stringAndPosition.position < earliestPosition) {\n          earliestPosition = stringAndPosition.position;\n        }\n      }\n      return { string: tokenString, position: earliestPosition };\n    }\n  }\n}\n","export default class Symbol{\n  constructor(){\n\n  }\n  get name(){\n    return this._name;\n  }\n  set name( someName ){\n    this._name = someName;\n  }\n}","import Symbol from './symbol'\n\nexport default class Token extends Symbol{\n\n  /***\n   * We are one of the two types of Symbol this parser deals with:\n   * Tokens and Nonterminals.\n   * A Token is basically a Symbol that contains one or more string characters.\n   * A Nonterminal is basically a Symbol that contains one or more Symbols\n   * (each of which can be either a Token or a Nonterminal).\n   *\n   * First argument will be a regex that will match some of the raw input stream.\n   * Second argument will be the internal representation I will use for myself\n   * (a string).\n   *\n   */\n  constructor( regexOfThingsIMustMatch, givenType, leng, stringIActuallyMatched, ignore, startIndex = -1 ){\n    super();\n    this.regexOfThingsIMustMatch = regexOfThingsIMustMatch;\n    this._type = givenType;\n    this.start = startIndex;\n    this._length = leng ? leng : 0;\n    this._stringIMatched = stringIActuallyMatched;\n    this._ignore = ignore;\n  }\n\n  get type(){\n    return this._type;\n  }\n\n  toStringSimple(){\n      return \" \" +  this._type + \" \" ;\n  }\n\n  get length(){\n    return this._length;\n  }\n\n  visit( evaluationVisitor ) {\n    return evaluationVisitor.execute( this );\n  }\n\n  matchYourselfToStartOfThisStringAndAddSelfToArray( symbolArray, stringToMatch, startingIndex ){\n      this._length = 0;\n      let match = this.regexOfThingsIMustMatch.exec( stringToMatch );\n      if( match != null && match.index == 0 ){\n\n        this._length = match[0].length;\n        // a frozen clone to record this moment,\n        // so that our data can go on to be reused without breaking things\n        let frozenToken = new Token( this.regexOfThingsIMustMatch, this.type, this._length,  match[0], this._ignore, startingIndex );\n        if( !this._ignore) symbolArray.push( frozenToken );\n        stringToMatch = stringToMatch.substring( this.length );\n      }\n      return [ this._length, symbolArray, stringToMatch ];\n  }\n\n  toString(){\n    return this.type + \"(\" + this.regexOfThingsIMustMatch.toString() + \")<\" + this._stringIMatched + \".\" + this.start + \">\";\n  }\n\n}\n\n","import Boolius from \"./boolius\"; // which in turn imports all the classes it depends upon\nimport XMLius from \"./xmlius\";\nimport Mathius from \"./mathius\";\n\nwindow.onload = function () {\n  d3.select(\"#modeSelect\").on(\"change\", function (e) {\n    var selectedMode = d3.select(\"#modeSelect\").node().value.toLowerCase();\n    changeMode(selectedMode);\n  });\n\n  function changeMode(newMode) {\n\n    if (newMode.indexOf(\"arithmetic\") > -1) {\n      // the user wants to look at arithmetic expressions.\n      // is boolius already loaded?\n      if (!evaluator || !(evaluator instanceof Mathius)) {\n        var grammarObject = [\n          [[\"NUMERIC\", \"^\", \"NUMERIC\"], \"NUMERIC\"],\n          [[\"NUMERIC\", \"*\", \"NUMERIC\"], \"NUMERIC\"],\n          [[\"NUMERIC\", \"+\", \"NUMERIC\"], \"NUMERIC\", [\"*\", \"/\", \"^\"]],\n          [[\"NUMERIC\", \"-\", \"NUMERIC\"], \"NUMERIC\", [\"*\", \"/\", \"^\"]],\n          [[\"NUM_LIT\"], \"NUMERIC\"],\n          [[\"(\", \"NUMERIC\", \")\"], \"NUMERIC\"],\n        ];\n\n        let IGNORE = true;\n\n        let tokenDefinitions = [\n          [/\\s+/, \"\", IGNORE], // ignore whitespace\n          [/\\^/, \"^\"], // this is the escaped form of ^\n          [/\\(/, \"(\"],\n          [/\\)/, \")\"],\n          [/\\+/, \"+\"],\n          [/-/, \"-\"],\n          [/\\*/, \"*\"],\n          [/\\//, \"/\"],\n          [/[-+]?[0-9]*\\.?[0-9]+/, \"NUM_LIT\"],\n          [/[a-zA-Z]+/, \"IDENT\"],\n          [/.+/, \"DIRTYTEXT\"],\n        ];\n        makeEvaluatorAndInitialize(\n          new Mathius(tokenDefinitions, grammarObject),\n          \"1 + 2 ^ (5 - 2) * 3\",\n          \"Click operators to expand or collapse.\"\n        );\n      }\n    } else if (newMode.indexOf(\"boolean\") > -1) {\n      // the user wants to look at boolean expressions.\n      // is boolius already loaded?\n      if (!evaluator || !(evaluator instanceof Boolius)) {\n        var grammarObject = [\n          [[\"TRUE\"], \"BOOLEAN\"],\n          [[\"FALSE\"], \"BOOLEAN\"],\n          [[\"IDENT\"], \"BOOLEAN\"],\n          [[\"!\", \"BOOLEAN\"], \"BOOLEAN\"],\n          [[\"BOOLEAN\", \"&\", \"BOOLEAN\"], \"BOOLEAN\"],\n          [[\"BOOLEAN\", \"|\", \"BOOLEAN\"], \"BOOLEAN\"],\n          [[\"(\", \"BOOLEAN\", \")\"], \"BOOLEAN\"],\n        ];\n\n        let IGNORE = true;\n\n        let tokenDefinitions = [\n          [/\\s+/, \"\", IGNORE], // ignore whitespace\n          [/&&/, \"&\"],\n          [/AND/i, \"&\"],\n          [/\\|\\|/, \"|\"], // this is the escaped form of ||\n          [/XOR/i, \"^\"],\n          [/OR/i, \"|\"],\n          [/\\^/, \"^\"], // this is the escaped form of ^\n          [/\\!/, \"!\"], // this is the escaped form of !\n          [/NOT/i, \"!\"],\n          [/\\(/, \"(\"],\n          [/\\)/, \")\"],\n          [/(true)(?![a-zA-Z0-9])/i, \"TRUE\"],\n          [/(false)(?![a-zA-Z0-9])/i, \"FALSE\"],\n          [/[a-zA-Z]+/, \"IDENT\"],\n          [/.+/, \"DIRTYTEXT\"],\n        ];\n        makeEvaluatorAndInitialize(\n          new Boolius(tokenDefinitions, grammarObject),\n          \"((d && c)) || (!b && a) && (!d || !a) && (!c || !b)\",\n          \"Click operators to expand or collapse. Click leaf nodes to toggle true/false.\"\n        );\n      }\n    } else if (newMode.indexOf(\"xml\") > -1) {\n      // the user wants to look at boolean expressions.\n      // is boolius already loaded?\n      if (!evaluator || !(evaluator instanceof XMLius)) {\n        let grammarObject = [\n          [[\"OPENCOMMENT\", \"WILDCARD\", \"CLOSECOMMENT\"], \"COMMENT\"],\n          // comments will be engulfed by the text of a node\n          // and ignored when the node is asked for its text as a string\n          [[\"COMMENT\"], \"#TEXT_NODE\"],\n          [[\"<\", \"/\", \"IDENT\", \">\"], \"CLOSETAG\"],\n          [[\"<\", \"IDENT\", \">\"], \"OPENTAG\"],\n          [[\"<\", \"IDENT\", \"/\", \">\"], \"XMLNODE\"],\n          [[\"<\", \"IDENT\", \"IDENT\", \"=\", '\"', \"WILDCARD\", '\"'], \"OPENTAGSTART\"],\n          /* Some recursive self-nesting here */\n          [\n            [\"OPENTAGSTART\", \"IDENT\", \"=\", '\"', \"WILDCARD\", '\"'],\n            \"OPENTAGSTART\",\n          ],\n          [[\"OPENTAGSTART\", \">\"], \"OPENTAG\"],\n          // can't have two identifiers in a row, unless we're between an opening and closing tag\n          // a/k/a node.text\n          [[\"IDENT\", \"IDENT\"], \"#TEXT_NODE\"],\n          [[\"IDENT\", \"#TEXT_NODE\"], \"#TEXT_NODE\"],\n          [[\"#TEXT_NODE\", \"#TEXT_NODE\"], \"#TEXT_NODE\"],\n          // let's also have nested nodes engulfed in the NODETEXT\n          [[\"XMLNODE\", \"#TEXT_NODE\"], \"#TEXT_NODE\"],\n          [[\"XMLNODES\", \"#TEXT_NODE\"], \"#TEXT_NODE\"],\n          [[\"#TEXT_NODE\", \"XMLNODE\"], \"#TEXT_NODE\"],\n          [[\"#TEXT_NODE\", \"XMLNODES\"], \"#TEXT_NODE\"],\n          [[\"OPENTAG\", \"CLOSETAG\"], \"XMLNODE\"],\n          [[\"OPENTAG\", \"#TEXT_NODE\", \"CLOSETAG\"], \"XMLNODE\"],\n          [[\"OPENTAG\", \"XMLNODE\", \"CLOSETAG\"], \"XMLNODE\"],\n          [[\"XMLNODE\", \"XMLNODE\"], \"XMLNODES\"],\n          [[\"OPENTAG\", \"XMLNODES\", \"CLOSETAG\"], \"XMLNODE\"],\n        ];\n\n        let IGNORE = true;\n\n        let tokenDefinitions = [\n          [/\\s+/, \"\", IGNORE],\n          [/<!--/, \"OPENCOMMENT\"],\n          [/-->/, \"CLOSECOMMENT\"],\n          [/\\//, \"/\"],\n          [/>/, \">\"],\n          [/</, \"<\"],\n          [/=/, \"=\"],\n          [/\"/, '\"'],\n          [/'/, '\"'],\n          [/[-+]?[0-9]*\\.?[0-9]+/, \"NUM_LIT\"],\n          [/[a-zA-Z]+[a-zA-Z0-9-]*/, \"IDENT\"],\n          // having trapped all these things, what's left is nodetext\n          [/[^<]+/, \"#TEXT_NODE\"],\n        ];\n\n        makeEvaluatorAndInitialize(\n          new XMLius(tokenDefinitions, grammarObject),\n          `<div class=\"hintwrapper\"><div class=\"hint\">Click operators to expand or collapse. Click leaf nodes to toggle true/false.</div><div class=\"styled-select green semi-square\" style=\"bold\"></div></div>`,\n          \"Mouseover nodes to see attributes. Click nodetext to see content.\"\n        );\n      }\n    }\n  }\n\n  function makeEvaluatorAndInitialize(newEvaluator, statement, hintText) {\n    assignEvaluator(newEvaluator);\n    d3.select(\"#statement\").node().value = statement;\n    d3.select(\"div.hint\").text(hintText);\n    evaluateStatement();\n  }\n\n  function assignEvaluator(newEvaluator) {\n    // don't change if the user wants what they already have\n    if (evaluator && newEvaluator.constructor === evaluator.constructor) return;\n    evaluator = newEvaluator;\n  }\n\n  var evaluator;\n  var winWidth = Math.max(1000, window.innerWidth);\n\n  let header = document.querySelector(\"header\")[0];\n  var winHeight = Math.max(500, window.innerHeight - 240);\n\n  var winWidth = Math.max(800, window.innerWidth);\n\n  var m = [0, 120, 140, 120],\n    w = winWidth - m[1] - m[3],\n    h = winHeight - m[0] - m[2],\n    i = 0,\n    root;\n\n  var tree = d3.layout.tree().size([h, w]);\n\n  var diagonal = d3.svg.diagonal().projection(function (d) {\n    return [d.y, d.x];\n  });\n\n  var vis = d3\n    .select(\"#body\")\n    .append(\"svg:svg\")\n    .attr(\"width\", w + m[1] + m[3])\n    .attr(\"height\", h + m[0] + m[2])\n    .append(\"svg:g\")\n    .attr(\"transform\", \"translate(\" + m[3] + \",\" + m[0] + \")\");\n\n  vis\n    .append(\"text\")\n    .attr(\"opacity\", 1)\n    .attr(\"y\", 246)\n    .attr(\"dy\", \"1.71em\")\n    .style(\"font-size\", \"34px\")\n    .style(\"text-anchor\", \"end\")\n    .attr(\"id\", \"result\")\n    .text(\"\");\n\n  d3.select(\"#testbutton\").on(\"click\", function (e) {\n    evaluateStatement();\n  });\n\n  d3.select(\"#statement\").on(\"keyup\", function () {\n    if (d3.event.keyCode == 13) {\n      d3.select(\"#testbutton\").on(\"click\")();\n    }\n  });\n\n  var parseTree;\n\n  function evaluateStatement() {\n    var statement = d3.select(\"#statement\").node().value;\n    parseTree = evaluator.parse(statement);\n    displayJSON(parseTree);\n  }\n\n  function displayJSON(json) {\n    if (json == null) return;\n    root = json;\n    root.x0 = h / 2;\n    root.y0 = 0;\n    //d3.select(\"#statement\").val( root.title );\n    d3.select(\"#statement\").property(\"value\", root.expressionString);\n\n    d3.select(\"#result\").text(root.value);\n\n    function toggleAll(d, delay) {\n      if (!delay) delay = 1;\n\n      if (d.children) {\n        toggle(d);\n      }\n\n      if (d._children) {\n        toggle(d);\n      }\n    }\n    // Initialize the display to show all nodes.\n    root.children.forEach(toggleAll, 444);\n\n    update(root);\n  }\n\n  // Toggle children.\n  function toggle(d, showOverlay) {\n    if (d == undefined) return;\n    //boolean\n    if (d.value === true || d.value === false) {\n      if (d.children) {\n        // hide the children by moving them into _children\n        d._children = d.children;\n        d.children = null;\n      } else {\n        // bring back the hidden children\n        d.children = d._children;\n        d._children = null;\n      }\n\n      var hasNoChildren = !d.children && !d._children;\n      if (!hasNoChildren) {\n        // has an array in d.children or d._children\n        // but it might be empty!\n\n        if (d.children && d.children.length == 0) hasNoChildren = true;\n        if (d._children && d._children.length == 0) hasNoChildren = true;\n      }\n      if (hasNoChildren) {\n        // it's a leaf\n        // toggle true/false\n        if (d.value === true || d.value === false) {\n          d.value = !d.value;\n          //var myInt = parseInt( d.name );\n          //conditionTruthValues[ myInt ] = d.value;\n          var myVar = d.name;\n          evaluator.state[myVar] = d.value;\n          updateWithoutDeleting(root);\n        }\n      }\n    } // you clicked something that isn't in a boolean flow\n    else {\n      if (showOverlay) {\n        var attributeText = d.attributes\n          ? JSON.stringify(d.attributes)\n          : \"None\";\n        if (!d.children && !d._children) {\n          // it's a leaf\n          //showValueOverlay( d.value );\n\n          showValueOverlay(\n            \"Attributes: \" + attributeText + \"</br>Content: \" + d.value\n          );\n        } //oops, we wanted to collapse this thing\n        else {\n          //showValueOverlay( \"Attributes: \" + attributeText + \"</br>Content: \" + d.value );\n          if (d.children) {\n            // hide the children by moving them into _children\n            d._children = d.children;\n            d.children = null;\n          } else {\n            // bring back the hidden children\n            d.children = d._children;\n            d._children = null;\n          }\n        }\n      }\n    }\n  }\n\n  function showValueOverlay(val) {\n    $(\"#valueModalText\").html(val);\n    $(\"#valueModal\").modal(\"show\");\n  }\n\n  function updateWithoutDeleting() {\n    parseTree = evaluator.evaluateParseTree();\n    updateObjectAndItsChildren(parseTree, root);\n\n    d3.select(\"#result\").text(root.value);\n  }\n\n  function updateObjectAndItsChildren(newObjectTemp, rootTemp) {\n    rootTemp.value = newObjectTemp.value;\n    if (!newObjectTemp.children) return;\n    for (var i = 0; i < newObjectTemp.children.length; i++) {\n      if (rootTemp.children) {\n        updateObjectAndItsChildren(\n          newObjectTemp.children[i],\n          rootTemp.children[i]\n        );\n      } else {\n        if (rootTemp._children) {\n          updateObjectAndItsChildren(\n            newObjectTemp.children[i],\n            rootTemp._children[i]\n          );\n        }\n      }\n    }\n  }\n\n  function update(source) {\n    var duration = d3.event && d3.event.altKey ? 5000 : 500;\n\n    // Compute the new tree layout.\n    var nodes = tree.nodes(root).reverse();\n\n    // Normalize for fixed-depth.\n    // OK -- why is d.y correlated with the horizontal position here???\n\n    widthPerNode = 110;\n    var body = d3.select(\"body\");\n    var svg = body.select(\"svg\");\n    var widthInPixels = svg.style(\"width\").replace(\"px\", \"\");\n    widthInPixels = parseInt(widthInPixels);\n    var widthPerNode = widthInPixels / nodes.length;\n    nodes.forEach(function (d) {\n      d.y = d.depth * widthPerNode;\n    });\n\n    d3.select(\"#result\")\n      .transition()\n      .duration(duration)\n      .attr(\"x\", nodes[nodes.length - 1].y - 40)\n      .attr(\"y\", function (d) {\n        return nodes[nodes.length - 1].x - 48;\n      });\n\n    // Update the nodes\n    var node = vis.selectAll(\"g.node\").data(nodes, function (d) {\n      return d.id || (d.id = ++i);\n    });\n\n    var modalOverlayTimeout;\n    // Enter any new nodes at the parent's previous position.\n    var nodeEnter = node\n      .enter()\n      .append(\"svg:g\")\n      .attr(\"class\", \"node\")\n      .attr(\"transform\", function (d) {\n        return \"translate(\" + source.y0 + \",\" + source.x0 + \")\";\n      })\n      .on(\"click\", function (d) {\n        if (modalOverlayTimeout != null) clearTimeout(modalOverlayTimeout);\n        toggle(d, true);\n        update(d);\n      })\n      .on(\"mouseover\", function (d) {\n        var attributeText = d.attributes ? JSON.stringify(d.attributes) : \"\";\n\n        if (attributeText.length > 0) {\n          if (modalOverlayTimeout != null) clearTimeout(modalOverlayTimeout);\n          modalOverlayTimeout = setTimeout(() => {\n            showValueOverlay(\n              \"Attributes: \" + attributeText + \"</br>Content: \" + d.value\n            );\n          }, 800);\n        }\n      });\n\n    nodeEnter\n      .append(\"svg:circle\")\n      .attr(\"r\", 1e-6)\n      .style(\"stroke\", function (d) {\n        return d.value ? \"green\" : \"red\";\n      })\n      .style(\"fill\", function (d) {\n        return d._children ? \"grey\" : \"#fff\";\n      });\n\n    nodeEnter\n      .append(\"svg:text\")\n      .attr(\"x\", function (d) {\n        return d.children || d._children ? -1 : 17;\n      })\n      .attr(\"y\", function (d) {\n        return d.children || d._children ? 18 : -1;\n      })\n      .attr(\"dy\", \".35em\")\n      .attr(\"text-anchor\", function (d) {\n        return d.children || d._children ? \"middle\" : \"left\";\n      })\n      //      .attr(\"text-anchor\", function(d) { return d.children || d._children ? \"end\" : \"start\"; })\n      .text(function (d) {\n        return d.name;\n      })\n      .style(\"fill-opacity\", 1e-6);\n\n    // Transition nodes to their new position.\n    var nodeUpdate = node\n      .transition()\n      .duration(duration)\n      .style(\"stroke\", function (d) {\n        return d.value ? \"green\" : \"red\";\n      })\n      .attr(\"transform\", function (d) {\n        return \"translate(\" + d.y + \",\" + d.x + \")\";\n      });\n\n    nodeUpdate\n      .select(\"circle\")\n      .attr(\"r\", 8.5)\n      .style(\"stroke\", function (d) {\n        return d.value ? \"green\" : \"red\";\n      })\n      .style(\"fill\", function (d) {\n        return d._children ? \"lightsteelblue\" : \"#fff\";\n      });\n\n    nodeUpdate.select(\"text\").style(\"fill-opacity\", 1);\n\n    // Transition exiting nodes to the parent's new position.\n    var nodeExit = node\n      .exit()\n      .transition()\n      .duration(duration)\n      .attr(\"transform\", function (d) {\n        return \"translate(\" + source.y + \",\" + source.x + \")\";\n      })\n      .remove();\n\n    nodeExit.select(\"circle\").attr(\"r\", 1e-6);\n\n    nodeExit.select(\"text\").style(\"fill-opacity\", 1e-6);\n\n    // Update the links\n    var link = vis.selectAll(\"path.link\").data(tree.links(nodes), function (d) {\n      return d.target.id;\n    });\n\n    // Enter any new links at the parent's previous position.\n    link\n      .enter()\n      .insert(\"svg:path\", \"g\")\n      .attr(\"class\", \"link\")\n      .attr(\"d\", function (d) {\n        var o = { x: source.x0, y: source.y0 };\n        return diagonal({ source: o, target: o });\n      })\n      .transition()\n      .duration(duration)\n      .attr(\"d\", diagonal);\n\n    // Transition links to their new position.\n    link.transition().duration(duration).attr(\"d\", diagonal);\n\n    // Transition exiting nodes to the parent's new position.\n    link\n      .exit()\n      .transition()\n      .duration(duration)\n      .attr(\"d\", function (d) {\n        var o = { x: source.x, y: source.y };\n        return diagonal({ source: o, target: o });\n      })\n      .remove();\n\n    // Stash the old positions for transition.\n    nodes.forEach(function (d) {\n      d.x0 = d.x;\n      d.y0 = d.y;\n    });\n  }\n\n  changeMode(\"boolean\");\n  evaluateStatement();\n};\n","export default class XMLParseTimeVisitor{\n  constructor( state ){\n    this.state = state;\n  }\n  setState( newstate ){\n    this.state = newstate;\n  }\n\n  execute( nonterm )\n  {\n\n    if( nonterm.type == \"XMLNODE\")\n    {\n      return this.verifyOpeningAndCloseTagsMatch( nonterm ) && this.verifyTagContentIsLegal( nonterm );\n    }\n    else if( nonterm.type == \"OPENTAG\")\n    {\n      return this.verifyAttributeContentIsLegal( nonterm );\n    }\n    else return true;\n  }\n\n  verifyOpeningAndCloseTagsMatch( thingToEvaluate ) {\n      \n      \n      let openTagName   = this.getTagName( thingToEvaluate.symbolsMatched[ 0 ] );\n       let closeTagName;\n      if( thingToEvaluate.symbolsMatched.length == 2 )\n      {\n        closeTagName = this.getTagName( thingToEvaluate.symbolsMatched[ 1 ] );\n      }\n      else if( thingToEvaluate.symbolsMatched.length > 2 )\n      {\n        closeTagName  = this.getTagName( thingToEvaluate.symbolsMatched[ thingToEvaluate.symbolsMatched.length - 1] );\n      }\n      \n      return openTagName == closeTagName;\n  }\n\n  verifyAttributeContentIsLegal( nonterm ){\n    // remember that OPENTAG can contain optional OPENTAGSTART nodes\n    // each of which can enclose other OPENTAGSTART nodes in perpetuity\n    return true;\n  }\n\n  verifyTagContentIsLegal( thingToEvaluate ){\n    return true;\n  }\n\n\n  getTagName( thingToEvaluate ){\n\n\n    while( thingToEvaluate.type != \"IDENT\" )\n    {\n      \n      if( thingToEvaluate.type == \"OPENTAG\")\n      {\n        if( thingToEvaluate.symbolsMatched)\n        {\n          if(  thingToEvaluate.symbolsMatched[0].type == \"<\")\n          {\n            \n            return thingToEvaluate.symbolsMatched[1]._stringIMatched;\n          }\n        }\n      }\n      else if( thingToEvaluate.type == \"CLOSETAG\")\n      {\n        \n        if( thingToEvaluate.symbolsMatched)\n        {\n          if(  thingToEvaluate.symbolsMatched[0].type == \"<\")\n          {\n            // element [1] will be \"/\" so we'll skip to [2]\n            \n            return thingToEvaluate.symbolsMatched[2]._stringIMatched;\n          }\n        }\n      }\n      else if( thingToEvaluate.type == \"OPENTAGSTART\")\n      {\n        \n        if( thingToEvaluate.symbolsMatched)\n        {\n          if(  thingToEvaluate.symbolsMatched[0].type == \"<\")\n          {\n            return thingToEvaluate.symbolsMatched[1]._stringIMatched;\n          }\n        }\n      }\n      thingToEvaluate = thingToEvaluate.symbolsMatched[0]\n    }\n    return thingToEvaluate._stringIMatched;\n    }\n}\n","import Token from '../token';\nimport Nonterminal from \"../nonterminal\";\n\nexport default class XMLJSONVisitor{\n  constructor( state ){\n    this.state = state;\n  }\n  setState( newstate ){\n    this.state = newstate;\n  }\n\n  execute( thingToEvaluate )\n  {\n        var ob = {};\n        ob.name = thingToEvaluate.type;\n        ob.value = this.getValue( thingToEvaluate ).trim();\n        let symbolsMatched = thingToEvaluate.symbolsMatched;\n\n        switch( thingToEvaluate.type )\n        {\n\n            case \"TOKEN\":\n                return { name : thingToEvaluate.stringIActuallyMatched, value: this.getValue( thingToEvaluate ), condition: \"Condition Text Goes Here\" };\n\n            case \"XMLNODES\":\n                ob.name = \"nodelist\";\n                ob.children = [];\n                for( var i = 0; i < symbolsMatched.length; i++ )\n                {\n                  let executedSymbol = this.execute( symbolsMatched[ i ]);\n                  ob.children.push( executedSymbol );\n                }\n                return ob.children;\n                break;\n\n            case \"XMLNODE\":\n\n                this.parentnode = ob;\n                ob.children = [];\n                // opentag is first item, and that gives us our name\n                ob.name = this.getValue( symbolsMatched[ 0 ] );\n\n                var optionalAttributes = this.getAttributes( symbolsMatched[ 0 ] );\n\n                if( optionalAttributes )\n                {\n                  ob.attributes = optionalAttributes;\n                }\n\n                symbolsMatched = this.consolidateChildrenThatAreTokens( symbolsMatched );\n\n                for( var i = 1; i < symbolsMatched.length - 1; i++ ) // -1, because the last match will be a closetag, which is irrelevant\n                {\n                  let child = this.execute( symbolsMatched[ i ]);\n                  // if a child was a nodelist, then it will return an array of divs.\n                  // we should not push that array as an element onto our array!\n                  // we should concat all its children onto our children (if we have any)\n                  if( Array.isArray( child ) )\n                  {\n                      ob.children = ob.children.concat( child );\n                  }\n                  else\n                  {\n                      ob.children.push( child );\n                  }\n                }\n\n\n                break;\n\n            case \"IDENT\": // basically a passthrough. Assume our first child is a real operator, and return *its* json.\n                ob.name = thingToEvaluate._stringIMatched;\n        }\n        return ob;\n  }\n\n  // good for the wildcard globbing we do inside open and close tags\n  consolidateChildrenThatAreTokens( arrayOfSymbolsThatMightBeTokens ) {\n    let symbolChildrenOnly = [];\n    let runningStringOfTokenText = \"\";\n    for( var symbol of arrayOfSymbolsThatMightBeTokens ){\n\n      if( !(symbol instanceof Token))\n      {\n        if( runningStringOfTokenText.length > 0 ) // we've been building up a text string!\n        {\n          let tokenConsolidatingStrings = this.makeTokenWrappingString( runningStringOfTokenText );\n          symbolChildrenOnly.push( tokenConsolidatingStrings );\n          runningStringOfTokenText = \"\";\n          symbolChildrenOnly.push( symbol );\n        }\n        else\n        {\n          symbolChildrenOnly.push( symbol );\n        }\n      }\n      else // it's a token!\n      {\n         runningStringOfTokenText += symbol._stringIMatched;\n      }\n    }\n\n    if( runningStringOfTokenText.length > 0 )\n    {\n      let tokenConsolidatingStrings = this.makeTokenWrappingString( runningStringOfTokenText );\n      symbolChildrenOnly.push( tokenConsolidatingStrings );\n    }\n\n    return symbolChildrenOnly;\n  }\n\n  makeTokenWrappingString( stringToWrap ){\n    let newSymbol = new Token( /.+/, \"TEXTNODE\", stringToWrap.length, stringToWrap );\n    return newSymbol;\n  }\n\n  // sent either an opentag or an opentagstart\n  getAttributes( childOfXMLNode ) {\n\n    if( childOfXMLNode.type == \"OPENTAGSTART\" )\n    {\n      // could be nested\n      // or could be <, IDENT, IDENT, =, ', WILDCARD, '\n      // or could be <, IDENT, IDENT, =, ', IDENT, '\n      // or could be <, IDENT, IDENT, =, ', IDENT, IDENT, '\n      let atts = {};\n      if( childOfXMLNode.symbolsMatched[0] instanceof Token) // could only be \"<\"\n      {\n        let name = this.getValue( childOfXMLNode.symbolsMatched[2] );\n        let valueForName = \"\";\n        for( let attributeValueIndex = 5; attributeValueIndex < childOfXMLNode.symbolsMatched.length - 1; attributeValueIndex++ )\n        {\n          valueForName += this.getValue( childOfXMLNode.symbolsMatched[ attributeValueIndex ] );\n          let notLast = attributeValueIndex < childOfXMLNode.symbolsMatched.length - 2;\n          if( notLast ) valueForName += \" \";\n        }\n        atts[ name ] = valueForName;\n        return atts;\n      }\n      else if(childOfXMLNode.symbolsMatched[0].type == \"OPENTAGSTART\") // nested opentagstarts! multiple attributes\n      {\n        atts = this.getAttributes( childOfXMLNode.symbolsMatched[0] );\n        let name = this.getValue( childOfXMLNode.symbolsMatched[1] );\n        let val = this.getValue( childOfXMLNode.symbolsMatched[4] );\n        atts[ name ] = val;\n        return atts;\n      }\n    }\n    else if(childOfXMLNode.symbolsMatched[0].type == \"OPENTAGSTART\")\n    {\n      let returnAtts = this.getAttributes( childOfXMLNode.symbolsMatched[0] );\n      return returnAtts;\n    }\n    return null;\n  }\n\n  getValue( nonterminalOrToken ){\n    if(nonterminalOrToken instanceof Nonterminal)\n    {\n        let symbolsMatched = nonterminalOrToken.symbolsMatched;\n\n        let value = \"FOO\"; // declare this and, hey, initialize it with something we'll notice if there's an error.\n\n        if( nonterminalOrToken.type == \"XMLNODE\")\n        {\n          // our first child will be our opentag, which is where our name comes from.\n          let returnVal = this.getValue( symbolsMatched[0] );\n          return returnVal;\n        }\n\n        if( nonterminalOrToken.type == \"XMLNODES\")\n        {\n          let returnVal = \"NODELIST\";\n          return returnVal;\n        }\n\n        if( nonterminalOrToken.type == \"OPENTAG\" || nonterminalOrToken.type == \"OPENTAGSTART\")\n        {\n          var returnVal;\n          // symbolsMatched[1] will either be an IDENT or an OPENTAGSTART (the wrapper for attribute definitions)\n          if( symbolsMatched[0].type == \"OPENTAGSTART\" )\n          {\n            returnVal = this.getValue( symbolsMatched[0] );\n            return returnVal;\n          }\n          returnVal = this.getValue( symbolsMatched[1] );\n          return returnVal;\n        }\n\n        if( nonterminalOrToken.type == \"CLOSETAG\")\n        {\n            return this.getValue( symbolsMatched[2] ); // after < and /\n        }\n\n        if( nonterminalOrToken.type == \"COMMENT\")\n        {\n          let commentstring = \"\";\n          for(var kid of nonterminalOrToken.symbolsMatched )\n          {\n            if( kid.type == \"OPENCOMMENT\" || kid.type == \"CLOSECOMMENT\") continue;\n            commentstring += this.getValue( kid );\n          }\n            return commentstring;\n        }\n\n        if( nonterminalOrToken.type == \"#TEXT_NODE\")\n        {\n          let contentstring = \"\";\n          for(var kid of nonterminalOrToken.symbolsMatched )\n          {\n            if( ( kid.type == \"#TEXT_NODE\" )  || ( kid.type == \"IDENT\" )  )\n              // IDENT generally means it was preceded and/or followed by some kind of whitespace\n              // so we should restore that delimiter\n              if( kid.type == \"IDENT\" )\n              {\n                contentstring += \" \" + this.getValue( kid );\n              }\n              else\n              {\n                contentstring += this.getValue( kid );\n              }\n          }\n          return contentstring;\n        }\n\n        throw new Error(\"XMLJSONVISITOR UNKNOWN LENGTH OF SYMBOLSMATCHED for \" + nonterminalOrToken.type + \":\" + JSON.stringify( symbolsMatched ));\n      }\n      else // it's a token\n      {\n        if( nonterminalOrToken.type.toUpperCase().indexOf( \"TRUE\" ) > -1 )\n        {\n          return true;\n        }\n        if( nonterminalOrToken.type.toUpperCase().indexOf( \"TEXTNODE\" ) > -1 )\n        {\n          return nonterminalOrToken._stringIMatched;\n        }\n        if( nonterminalOrToken.type.toUpperCase().indexOf( \"IDENT\" ) > -1 )\n        {\n          return nonterminalOrToken._stringIMatched;\n        }\n        return nonterminalOrToken._stringIMatched;\n//        throw new Error(\"nonterminalOrToken.type is \" + nonterminalOrToken.type );\n//        return null;\n      }\n  }\n}\n","import Lexer from './lexer';\nimport Parser from './parser';\nimport XMLParseTimeVisitor from './visitors/xmlparsetimevisitor';\nimport XMLJSONVisitor from './visitors/xmljsonvisitor';\n// import TokenFactory from './factories/tokenfactory';\n// import NonterminalFactory from './factories/nonterminalfactory';\n\nexport default class XMLius{\n  constructor( tokenDefinitions, grammarObject ){\n\n    // we set the state so that the parser knows the data type of each of these variables\n    // (in this case, boolean)\n    // and later so that the visitor can evaluate each node to determine if it is true or false.\n    this.state = {};\n\n    this.xmlParseTimeVisitor = new XMLParseTimeVisitor();\n\n    this.visitor = new XMLJSONVisitor(  this.state );\n    // lay the groundwork for lexical analysis\n    this.lexer = new Lexer( tokenDefinitions );\n    this.parser = new Parser( grammarObject );\n    this.parser.setState( this.state );\n  }\n\n  parse( sentenceToParse ){\n    try\n    {\n      let sentenceOfTokens = this.lexer.tokenize( sentenceToParse );\n      this.parser.setState( this.state );\n      this.parseTree = this.parser.parse( sentenceOfTokens, this.xmlParseTimeVisitor );\n      return this.evaluateParseTree();\n    }\n    catch( e )\n    {\n      console.error( \"ERROR PARSING OR EVALUATING:\" + e );\n    }\n  }\n\n  evaluateParseTree(){\n    let result = this.parseTree[0].visit( this.visitor );\n    return result;\n  }\n}\n\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tif(__webpack_module_cache__[moduleId]) {\n\t\treturn __webpack_module_cache__[moduleId].exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop)","// startup\n// Load entry module\n// This entry module is referenced by other modules so it can't be inlined\n__webpack_require__(194);\n__webpack_require__(412);\n__webpack_require__(154);\n__webpack_require__(339);\n"],"sourceRoot":""}