{"version":3,"sources":["webpack:///webpack/bootstrap 73ce1e895fe7ba5e14d3","webpack:///./js/factories/nonterminalfactory.js","webpack:///./js/factories/tokenfactory.js","webpack:///./js/lexer.js","webpack:///./js/parser.js","webpack:///./js/symbol.js","webpack:///./js/boolius.js","webpack:///./js/mathius.js","webpack:///./js/nonterminal.js","webpack:///./js/token.js","webpack:///./js/visitors/evaluationvisitor.js","webpack:///./js/visitors/numericvisitor.js","webpack:///./js/xmlius.js","webpack:///./js/visualizer.js","webpack:///./js/visitors/booleanjsonvisitor.js","webpack:///./js/visitors/booleanvisitor.js","webpack:///./js/visitors/mathjsonvisitor.js","webpack:///./js/visitors/xmljsonvisitor.js","webpack:///./js/visitors/xmlparsetimevisitor.js"],"names":["NonterminalFactory","grammarObject","nonterminals","grammarRule","nonterminal","length","lookaheadTokensToAvoid","push","TokenFactory","tokenDefinitions","tokens","tokenDefinition","makeToken","regex","name","ignore","token","IGNORE","makeTokenFromDefinition","Lexer","tokenFactory","getTokens","sentenceToTokenize","arrayOfTokens","startingLetter","stringToMatch","foundAMatchSomewhere","lengthOfMatch","matchYourselfToStartOfThisStringAndAddSelfToArray","Error","charAt","Parser","nonterminalFactory","getNonterminals","state","sentenceOfSymbols","resolvedSymbols","symbol","shift","constructor","type","_stringIMatched","nonterm","seriesOfSymbolsIAbsorbedAndReplaced","traceString","parseTimeVisitor","resolveIdentifiersToTypes","arrayOfSymbolsMatchedBeforeMe","finished","madeAMatch","getSimpleStringForSentence","slice","stringAndPosition","getLastTokenDescriptionOfSymbol","errorString","string","position","console","log","getStringAndPositionOfTokensOfSymbol","symbolsMatched","earliestPosition","start","tokenString","kid","Symbol","_name","someName","Boolius","visitor","lexer","parser","setState","sentenceToParse","sentenceOfTokens","tokenize","parseTree","parse","evaluateParseTree","e","alert","result","visit","module","exports","Mathius","error","Nonterminal","seriesOfSymbolsIMustMatch","wildcardMode","join","returnString","toString","evaluationVisitor","execute","sentenceOfSymbolsToMatch","sentenceOfSymbolsToMatchClone","seriesOfSymbolsIMustMatchClone","done","symbolThatBreaksWildcard","mySymbol","theirSymbol","getFrozenClone","theirNextSymbol","indexOf","frozenClone","Token","regexOfThingsIMustMatch","leng","stringIActuallyMatched","startIndex","_type","_length","_ignore","symbolArray","startingIndex","match","exec","index","frozenToken","substring","EvaluationVisitor","booleanVisitor","numericVisitor","newstate","nonterminalOrToken","toUpperCase","NumericVisitor","value","Math","pow","JSON","stringify","parseInt","XMLius","xmlParseTimeVisitor","window","onload","d3","select","on","selectedMode","node","toLowerCase","changeMode","newMode","evaluator","makeEvaluatorAndInitialize","newEvaluator","statement","hintText","assignEvaluator","text","evaluateStatement","winHeight","max","innerHeight","winWidth","innerWidth","m","w","h","i","root","tree","layout","size","diagonal","svg","projection","d","y","x","vis","append","attr","style","event","keyCode","displayJSON","json","x0","y0","property","expressionString","toggleAll","delay","children","toggle","_children","forEach","update","showOverlay","undefined","myVar","updateWithoutDeleting","attributeText","attributes","showValueOverlay","val","$","html","modal","updateObjectAndItsChildren","newObjectTemp","rootTemp","source","duration","altKey","nodes","reverse","widthPerNode","body","widthInPixels","replace","depth","transition","selectAll","data","id","nodeEnter","enter","nodeUpdate","nodeExit","exit","remove","link","links","target","insert","o","BooleanJSONVisitor","thingToEvaluate","ob","getBoolean","condition","getNameForOperator","operatorSymbol","BooleanVisitor","MathJSONVisitor","getValue","XMLJSONVisitor","optionalAttributes","getAttributes","consolidateChildrenThatAreTokens","arrayOfSymbolsThatMightBeTokens","symbolChildrenOnly","runningStringOfTokenText","tokenConsolidatingStrings","makeTokenWrappingString","stringToWrap","newSymbol","childOfXMLNode","atts","returnAtts","returnVal","commentstring","contentstring","XMLParseTimeVisitor","verifyOpeningAndCloseTagsMatch","verifyTagContentIsLegal","verifyAttributeContentIsLegal","openTagName","getTagName","closeTagName"],"mappings":"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","file":"boolius.bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/build/js\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 18);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 73ce1e895fe7ba5e14d3","import Nonterminal from '../nonterminal';\n\nexport default class NonterminalFactory{\n  constructor(grammarObject){\n    this.grammarObject = grammarObject;\n    this.nonterminals = [];\n    for( let grammarRule of grammarObject )\n    {\n      let nonterminal = new Nonterminal( grammarRule[0], grammarRule[1] );\n      if( grammarRule.length > 2 ) // it has an array of lookaheadTokensToAvoid\n      {\n        nonterminal.lookaheadTokensToAvoid = grammarRule[2];\n      }\n      this.nonterminals.push( nonterminal );\n    }\n  }\n\n  getNonterminals(){\n    return this.nonterminals;\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ./js/factories/nonterminalfactory.js","import Token from '../token';\n\nexport default class TokenFactory{\n   constructor( tokenDefinitions ){\n     this.tokens = [];\n     this.tokenDefinitions = tokenDefinitions;\n   }\n\n   makeTokenFromDefinition( tokenDefinition ){\n     return this.makeToken( tokenDefinition[0], tokenDefinition[1], tokenDefinition.length > 2 ? tokenDefinition[2] : false );\n   }\n    makeToken( regex, name, ignore = false )\n    {\n      var token = new Token( regex, name, 0, \"\", ignore );\n      this.tokens.push( token );\n      return token;\n    }\n\n    getTokens()\n    {\n      let IGNORE = true;\n\n      for( let tokenDefinition of this.tokenDefinitions )\n      {\n        this.makeTokenFromDefinition( tokenDefinition )\n      }\n      return this.tokens;\n\n    }\n}\n\n\n// WEBPACK FOOTER //\n// ./js/factories/tokenfactory.js","import TokenFactory from './factories/tokenfactory';\n\nexport default class Lexer{\n\n  constructor( tokenDefinitions ){\n    let tokenFactory = new TokenFactory( tokenDefinitions );\n    this.tokens = tokenFactory.getTokens();\n  }\n\n  tokenize( sentenceToTokenize ){\n    let arrayOfTokens = [];\n    var startingLetter = 0;\n    let stringToMatch = sentenceToTokenize; // want to keep original sentence for length/reference\n\n    while(  startingLetter < sentenceToTokenize.length )\n    {\n      let foundAMatchSomewhere = false;\n      for (var token of this.tokens)\n      {\n        let lengthOfMatch = 0;\n        [lengthOfMatch, arrayOfTokens, stringToMatch ] =\n        token.matchYourselfToStartOfThisStringAndAddSelfToArray( arrayOfTokens, stringToMatch, startingLetter );\n        if( lengthOfMatch > 0 )\n        {\n          foundAMatchSomewhere = true;\n          startingLetter += lengthOfMatch;\n          break; // START AT THE TOP OF OUR TOKEN LIST!!\n          // That is IMPORTANT.\n          // Some of our later tokens, like IDENT, are catch-alls that will greedily snatch up keywords like NOT\n        }\n      }\n      if(! foundAMatchSomewhere)\n      {\n        throw new Error(\"Illegal character \" + stringToMatch.charAt(0) + \" at position \" + startingLetter );\n      }\n    }\n    return arrayOfTokens;\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ./js/lexer.js","import Symbol from './symbol'\nimport Nonterminal from './nonterminal'\nimport NonterminalFactory from '../js/factories/nonterminalfactory';\n\nexport default class Parser{\n  constructor( grammarObject ){\n    let nonterminalFactory = new NonterminalFactory( grammarObject );\n    this.nonterminals = nonterminalFactory.getNonterminals();\n    this.state = {};\n  }\n\n  setState( state ) {\n    this.state = state; // generally just a lookup table for declared/initialized variables\n  }\n\n  // What does this do? Well, if there's a token of type IDENT, it's a variable.\n  // If that variable hasn't been declared, then how are we supposed to know what type it is?\n  // We'll be strongly-typed so that even a simple grammar can work effectively.\n  resolveIdentifiersToTypes( sentenceOfSymbols ){\n    let resolvedSymbols = [];\n    while( sentenceOfSymbols.length > 0 )\n    {\n      // comments might have been turned into null symbols\n      // in which case we should skip them\n      let symbol = sentenceOfSymbols.shift();\n      // we only care about tokens\n      if( symbol.constructor.name == \"Token\")\n      {\n        if( symbol.type == \"IDENT\")\n        {\n          // so now we can wrap our variable in the appropriate nonterminal type\n          if( typeof this.state[symbol._stringIMatched] == \"boolean\")\n          {\n            let nonterm = new Nonterminal( [\"IDENT\"], \"BOOLEAN\" );\n            nonterm.seriesOfSymbolsIAbsorbedAndReplaced = [ symbol ];\n            symbol = nonterm;\n          }\n          resolvedSymbols.push( symbol );\n          continue;\n        }\n        else\n        {\n          resolvedSymbols.push( symbol );\n        }\n      }\n      else\n      {\n        resolvedSymbols.push( symbol );\n      }\n    }\n    return resolvedSymbols;\n  }\n\n  getSimpleStringForSentence( sentenceOfSymbols ) {\n          let traceString = \"\";\n          for( var symbol of sentenceOfSymbols )\n          {\n            traceString += symbol.type + \" \";\n          }\n          return traceString;\n  }\n\n  parse( sentenceOfSymbols, parseTimeVisitor = null ){\n\n    sentenceOfSymbols = this.resolveIdentifiersToTypes( sentenceOfSymbols );\n    let arrayOfSymbolsMatchedBeforeMe = [];\n    let lengthOfMatch = 0;\n    let finished = false;\n    // actually, if our sentence only has one symbol, it may very well be finished already\n    if ( sentenceOfSymbols.length == 1 ) finished = true;\n    while( !finished ){\n        let madeAMatch = false;\n        //console.log(\"============\");\n        for( var nonterminal of this.nonterminals )\n        {\n\n          // we'll go through the input sentence\n          // and try to match this nonterminal to the beginning of it.\n          // if there's a match, then our nonterminal will be part of the future sentence.\n          // (replacing whatever portion it matched.)\n          // if there's no match, we want to pop a symbol off the start of the input sentence\n          // (moving it into the future sentence, since we )\n          let traceString = this.getSimpleStringForSentence( sentenceOfSymbols );\n          while( sentenceOfSymbols.length > 0 )\n          {\n//            console.log(\"USING nonterminal \" + nonterminal.toStringSimple() + \" to look at \" + traceString );\n            [lengthOfMatch, arrayOfSymbolsMatchedBeforeMe, sentenceOfSymbols ] =\n            nonterminal.matchYourselfToStartOfThisStringAndAddSelfToArray( arrayOfSymbolsMatchedBeforeMe, sentenceOfSymbols, parseTimeVisitor );\n\n            // if we matched, then the good news is, the input sentence is now changed\n            // so we don't have to worry about changing it.\n            // otherwise, we didn't match the beginning of the input sentence,\n            // so let's pop a symbol off it and try again.\n            if( lengthOfMatch == 0 )\n            {\n              arrayOfSymbolsMatchedBeforeMe.push( sentenceOfSymbols.shift() );\n              traceString = this.getSimpleStringForSentence( sentenceOfSymbols );\n            }\n            else\n            {\n              //console.log(\"MATCHED nonterminal \" + nonterminal.toStringSimple() + \" to sentence \" + traceString );\n              madeAMatch = true;\n            }\n          }\n\n          // ok, we did what we could. let's gather our processed items and hand them to the next nonterminal to process.\n          sentenceOfSymbols = arrayOfSymbolsMatchedBeforeMe.slice(0); // make sure we copy the items over and keep these two arrays discrete!\n          arrayOfSymbolsMatchedBeforeMe = [];\n          //console.log(\"sentenceOfSymbols is now \" + sentenceOfSymbols );\n          // are we done? if so, then don't bother looking at other nonterminals!\n          if( sentenceOfSymbols.length <= 1 )\n          {\n            finished == true;\n            break;\n          }\n\n          // we need to start from the top of our nonterminals if we made a match!\n          // order MATTERS.\n          if( madeAMatch ) break;\n\n        } // end of cycling through our array of nonterminals\n\n        // what if we made it through all our nonterminals and didn't make a match?\n        // error, that's what!\n        if( ! madeAMatch )\n        {\n          let stringAndPosition = this.getLastTokenDescriptionOfSymbol( sentenceOfSymbols[0] );\n          let errorString = \"\\nSyntax error:\" + stringAndPosition.string + \" at position \" + stringAndPosition.position;\n          console.log(\"sentenceOfSymbols is \" + sentenceOfSymbols);\n          throw new Error( errorString );\n          finished = true;\n        }\n\n        if( sentenceOfSymbols.length <= 1 )\n        {\n          finished = true;\n        }\n    }  // end of our \"while\" loop going through sentenceOfSymbols until finished == true\n\n    return sentenceOfSymbols;\n  }\n\n  getLastTokenDescriptionOfSymbol( symbol ){\n     return this.getStringAndPositionOfTokensOfSymbol( symbol.symbolsMatched[ symbol.symbolsMatched.length - 1] );\n  }\n\n  getStringAndPositionOfTokensOfSymbol( symbol, earliestPosition = 100000000 ){\n    if (symbol.constructor.name == \"Token\" )\n    {\n      return { string: symbol._stringIMatched, position: symbol.start };\n    }\n    else if (symbol.constructor.name == \"Nonterminal\" )\n    {\n      let tokenString = \"\";\n      for( let kid of symbol.symbolsMatched )\n      {\n        let stringAndPosition = this.getStringAndPositionOfTokensOfSymbol( kid, earliestPosition );\n        tokenString += stringAndPosition.string;\n        if( stringAndPosition.position < earliestPosition )\n        {\n          earliestPosition = stringAndPosition.position;\n        }\n      }\n      return { string: tokenString, position: earliestPosition };\n    }\n  }\n\n\n}\n\n\n// WEBPACK FOOTER //\n// ./js/parser.js","export default class Symbol{\n  constructor(){\n\n  }\n  get name(){\n    return this._name;\n  }\n  set name( someName ){\n    this._name = someName;\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ./js/symbol.js","//import Token from './token';\n//import Symbol from './token';\nimport Lexer from './lexer';\nimport Parser from './parser';\nimport XMLius from './xmlius';\nimport Mathius from './mathius';\nimport BooleanJSONVisitor from './visitors/booleanjsonvisitor';\nimport TokenFactory from './factories/tokenfactory';\nimport NonterminalFactory from './factories/nonterminalfactory';\n\nexport class Boolius{\n\n  constructor( tokenDefinitions, grammarObject ){\n\n    // we set the state so that the parser knows the data type of each of these variables\n    // (in this case, boolean)\n    // and later so that the visitor can evaluate each node to determine if it is true or false.\n    this.state = {\"a\":false,\"b\":true,\"c\":false,\"d\":true,\"e\":false,\"f\":true,\"g\":false,\"h\":true,\"i\":false};\n    this.visitor = new BooleanJSONVisitor( this.state );\n    // lay the groundwork for lexical analysis\n    this.lexer = new Lexer( tokenDefinitions );\n    this.parser = new Parser( grammarObject );\n    this.parser.setState( this.state );\n  }\n\n  parse( sentenceToParse ){\n    try\n    {\n      let sentenceOfTokens = this.lexer.tokenize( sentenceToParse );\n      this.parseTree = this.parser.parse( sentenceOfTokens );\n      return this.evaluateParseTree();\n    }\n    catch( e )\n    {\n      alert( e );\n    }\n  }\n\n  evaluateParseTree(){\n    let result = this.parseTree[0].visit( this.visitor );\n    return result;\n  }\n}\n//window.Boolius = Boolius;\nmodule.exports = Boolius;\n\n\n// WEBPACK FOOTER //\n// ./js/boolius.js","//import Token from './token';\n//import Symbol from './token';\nimport Lexer from './lexer';\nimport Parser from './parser';\nimport NumericVisitor from './visitors/numericvisitor';\nimport MathJSONVisitor from './visitors/mathjsonvisitor';\nimport TokenFactory from './factories/tokenfactory';\nimport NonterminalFactory from './factories/nonterminalfactory';\n\nexport default class Mathius{\n  constructor( tokenDefinitions, grammarObject ){\n\n    // we set the state so that the parser knows the data type of each of these variables\n    // (in this case, boolean)\n    // and later so that the visitor can evaluate each node to determine if it is true or false.\n    this.state = {\"a\":false,\"b\":true,\"c\":false,\"d\":true,\"e\":false,\"f\":true,\"g\":false,\"h\":true,\"i\":false};\n\n    this.visitor = new MathJSONVisitor(  this.state );\n    // lay the groundwork for lexical analysis\n    this.lexer = new Lexer( tokenDefinitions );\n    this.parser = new Parser( grammarObject );\n    this.parser.setState( this.state );\n  }\n\n\n\n  parse( sentenceToParse ){\n    try\n    {\n      let sentenceOfTokens = this.lexer.tokenize( sentenceToParse );\n      this.parseTree = this.parser.parse( sentenceOfTokens );\n      return this.evaluateParseTree();\n    }\n    catch( e )\n    {\n      console.error( \"ERROR PARSING OR EVALUATING:\" + e );\n    }\n  }\n\n  evaluateParseTree(){\n    let result = this.parseTree[0].visit( this.visitor );\n    return result;\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./js/mathius.js","import Symbol from './symbol'\n\nexport default class Nonterminal extends Symbol{\n\n    constructor( seriesOfSymbolsIMustMatch, type ){\n      super();\n      this.seriesOfSymbolsIMustMatch  = seriesOfSymbolsIMustMatch;\n      this.type                       = type;\n      this.seriesOfSymbolsIAbsorbedAndReplaced = [];\n      this.wildcardMode = false;\n      this.lookaheadTokensToAvoid = null;\n    }\n\n    toStringSimple(){\n      return this.type + \"(\" + this.seriesOfSymbolsIMustMatch.join( ' ' ) + \")\";\n    }\n\n    toString(){\n      let returnString = this.type + \" (\";\n\n      for( var symbol of this.seriesOfSymbolsIAbsorbedAndReplaced )\n      {\n        returnString += \" \" + symbol.toString();\n      }\n      return returnString;\n    }\n\n    get symbolsMatched(){\n      return this.seriesOfSymbolsIAbsorbedAndReplaced;\n    }\n\n    get length(){\n      return this.seriesOfSymbolsIAbsorbedAndReplaced.length;\n    }\n\n    visit( evaluationVisitor ) {\n      return evaluationVisitor.execute( this );\n    }\n\n    matchYourselfToStartOfThisStringAndAddSelfToArray( arrayOfSymbolsMatchedBeforeMe, sentenceOfSymbolsToMatch, parseTimeVisitor ){\n\n      // clone it so we don't destroy the original in case we're only a partial match\n\n      let sentenceOfSymbolsToMatchClone = sentenceOfSymbolsToMatch.slice(0);\n\n      // same with ours\n\n      let seriesOfSymbolsIMustMatchClone = this.seriesOfSymbolsIMustMatch.slice(0);\n\n      this.seriesOfSymbolsIAbsorbedAndReplaced = [];\n\n      let done = false;\n\n      // in case of wildcard, we need to know what the previous symbol was\n\n      let symbolThatBreaksWildcard = null;\n\n      while( seriesOfSymbolsIMustMatchClone.length > 0 )\n      {\n        let mySymbol = seriesOfSymbolsIMustMatchClone.shift();\n        let theirSymbol = sentenceOfSymbolsToMatchClone.shift();\n\n        // if they ran out of symbols, then we're obviously not a match. UNLESS we were in wildcard mode.\n        if( ! theirSymbol )\n        {\n            this.seriesOfSymbolsIAbsorbedAndReplaced = [];\n            return [ 0, arrayOfSymbolsMatchedBeforeMe, sentenceOfSymbolsToMatch ];\n        }\n\n\n\n        if( mySymbol == \"WILDCARD\" )\n        {\n          this.wildcardMode = true;\n          symbolThatBreaksWildcard = seriesOfSymbolsIMustMatchClone.shift();\n          while( theirSymbol.type != symbolThatBreaksWildcard )\n          {\n            this.seriesOfSymbolsIAbsorbedAndReplaced.push( theirSymbol );\n\n            if( sentenceOfSymbolsToMatchClone.length == 0 ) // they ran out of symbols in their sentence!\n            {\n              if( seriesOfSymbolsIMustMatchClone.length == 0 ) // that wildcard was my last character\n              {\n                arrayOfSymbolsMatchedBeforeMe.push( this.getFrozenClone() );\n                return [ this.length, arrayOfSymbolsMatchedBeforeMe, sentenceOfSymbolsToMatchClone ];\n              }\n              else // failure -- we had more to match but they ran out first\n              {\n                this.seriesOfSymbolsIAbsorbedAndReplaced = [];\n                return [ 0, arrayOfSymbolsMatchedBeforeMe, sentenceOfSymbolsToMatch ];\n              }\n            }\n            else\n            {\n              theirSymbol = sentenceOfSymbolsToMatchClone.shift();\n\n            }\n          } //end of tight loop inside wildcard mode, but still in wildcard mode\n\n          // absorb the one that got us out of the wildcard\n          // i.e., it matched the symbol of ours that follows (and thus ends) the wildcard\n\n          this.seriesOfSymbolsIAbsorbedAndReplaced.push( theirSymbol );\n\n          // we made it through!\n          // if that was the last one, then we should skip the rest of the matching and go right to success\n          // if not, keep the process going -- get a new symbol from them\n          if( seriesOfSymbolsIMustMatchClone.length == 0 ) // we don't have any more\n          {\n            done = true;\n          }\n          else if( sentenceOfSymbolsToMatchClone.length > 0 ) // we have more, and they have more things that need matching\n          {\n            theirSymbol = sentenceOfSymbolsToMatchClone.shift();\n            // but if our wildcard was our last character, then we should leave\n          }\n          else // we have more, but they don't!\n          {\n            this.seriesOfSymbolsIAbsorbedAndReplaced = [];\n            return [ 0, arrayOfSymbolsMatchedBeforeMe, sentenceOfSymbolsToMatch ];\n          }\n        } // end of wildcard loop\n\n        if (!done )\n        {\n          // do they match? i.e., the next character in the sentence -- does it match the next symbol in my internal list?\n          if( theirSymbol.type != mySymbol )\n          {\n            return [ 0, arrayOfSymbolsMatchedBeforeMe, sentenceOfSymbolsToMatch ];\n          }\n          else\n          {\n            this.seriesOfSymbolsIAbsorbedAndReplaced.push( theirSymbol );\n          }\n        }\n      }// bottom of seriesOfSymbolsIMustMatchClone.length loop\n\n      // we made it through -- matched everything we needed to -- but maybe there's a problem after all...\n      // now, there's an edge case -- good for operator precedence enforcement\n      // -- the lookahead tokens.\n      // maybe we matched everything we needed, and that's great,\n      // but maybe the next token in the sentence is a dealbreaker!\n      // for example, 1 + 2 * 3\n      // if we're NUMERIC + NUMERIC, we'll find a match\n      // but that is wrong! because the next token *after* our possible match is a *\n      // and that has higher precedence than +\n\n      if( this.lookaheadTokensToAvoid )\n      {\n        if( sentenceOfSymbolsToMatchClone.length > 0 )\n        {\n          let theirNextSymbol = sentenceOfSymbolsToMatchClone[0];\n          if( this.lookaheadTokensToAvoid.indexOf( theirNextSymbol.type ) > -1 )\n          {\n            return [ 0, arrayOfSymbolsMatchedBeforeMe, sentenceOfSymbolsToMatch ];\n          }\n        }\n      }\n      // we made it here! must be a basically perfect match.\n      // but let's see if there's a context stack for this parser\n      // e.g., an XML parser keeps a stack of open nodes\n      // so that when you hit a closing tag for a node\n      // the parser can know if it's the most recently opened tag\n      if( ! parseTimeVisitor || parseTimeVisitor.execute( this ) )\n      {\n        arrayOfSymbolsMatchedBeforeMe.push( this.getFrozenClone() );\n        return [ this.length, arrayOfSymbolsMatchedBeforeMe, sentenceOfSymbolsToMatchClone ];\n      }\n      else\n      {\n        return [ 0, arrayOfSymbolsMatchedBeforeMe, sentenceOfSymbolsToMatch ];\n      }\n    }\n\n    getFrozenClone(){\n\n      let frozenClone = new Nonterminal( this.seriesOfSymbolsIMustMatch, this.type );\n\n      frozenClone.seriesOfSymbolsIAbsorbedAndReplaced = this.seriesOfSymbolsIAbsorbedAndReplaced;\n\n      return frozenClone;\n    }\n\n}\n\n\n// WEBPACK FOOTER //\n// ./js/nonterminal.js","import Symbol from './symbol'\n\nexport default class Token extends Symbol{\n\n  /***\n   * We are one of the two types of Symbol this parser deals with:\n   * Tokens and Nonterminals.\n   * A Token is basically a Symbol that contains one or more string characters.\n   * A Nonterminal is basically a Symbol that contains one or more Symbols\n   * (each of which can be either a Token or a Nonterminal).\n   *\n   * First argument will be a regex that will match some of the raw input stream.\n   * Second argument will be the internal representation I will use for myself\n   * (a string).\n   *\n   */\n  constructor( regexOfThingsIMustMatch, type, leng, stringIActuallyMatched, ignore, startIndex = -1 ){\n    super();\n    this.regexOfThingsIMustMatch = regexOfThingsIMustMatch;\n    this._type = type;\n    this.start = startIndex;\n    this._length = leng ? leng : 0;\n    this._stringIMatched = stringIActuallyMatched;\n    this._ignore = ignore;\n  }\n\n  get type(){\n    return this._type;\n  }\n\n  toStringSimple(){\n      return \" \" +  this._type + \" \" ;\n  }\n\n  get length(){\n    return this._length;\n  }\n\n  visit( evaluationVisitor ) {\n    return evaluationVisitor.execute( this );\n  }\n\n  matchYourselfToStartOfThisStringAndAddSelfToArray( symbolArray, stringToMatch, startingIndex ){\n      this._length = 0;\n      let match = this.regexOfThingsIMustMatch.exec( stringToMatch );\n      if( match != null && match.index == 0 ){\n        this._length = match[0].length;\n        // a frozen clone to record this moment,\n        // so that our data can go on to be reused without breaking things\n        let frozenToken = new Token( this.regexOfThingsIMustMatch, this.type, this._length,  match[0], this._ignore, startingIndex );\n        if( !this._ignore) symbolArray.push( frozenToken );\n        stringToMatch = stringToMatch.substring( this.length );\n      }\n      return [ this._length, symbolArray, stringToMatch ];\n  }\n\n  toString(){\n    return this.type + \"(\" + this.regexOfThingsIMustMatch.toString() + \")<\" + this._stringIMatched + \".\" + this.start + \">\";\n  }\n\n}\n\n\n\n\n// WEBPACK FOOTER //\n// ./js/token.js","import BooleanVisitor from './booleanvisitor'\nimport NumericVisitor from './numericvisitor'\n\nclass EvaluationVisitor{\n  constructor( state ){\n    this.state = state;\n    this.booleanVisitor = new BooleanVisitor( state );\n    this.numericVisitor = new NumericVisitor( state );\n  }\n\n  setState( newstate ){\n    this.state = newstate;\n    this.booleanVisitor.setState( newstate );\n    this.numericVisitor.setState( newstate );\n  }\n\n  execute( nonterminalOrToken ) {\n    if(nonterminalOrToken.constructor.name == \"Nonterminal\" )\n    {\n      if( nonterminalOrToken.type == \"BOOLEAN\")\n        return this.booleanVisitor.execute( nonterminalOrToken );\n      if( nonterminalOrToken.type == \"NUMERIC\")\n        return this.numericVisitor.execute( nonterminalOrToken );\n    }\n    else // it's a token\n    {\n      if( nonterminalOrToken.type.toUpperCase().indexOf( \"TRUE\" ) > -1 )\n      {\n        return true;\n      }\n      if( nonterminalOrToken.type.toUpperCase().indexOf( \"FALSE\" ) > -1 )\n      {\n        return false;\n      }\n      throw new Error(\"nonterminalOrToken.type is \" + nonterminalOrToken.type );\n      return null;\n    }\n  }\n}\n\nmodule.exports = EvaluationVisitor;\n\n\n// WEBPACK FOOTER //\n// ./js/visitors/evaluationvisitor.js","import EvaluationVisitor from './evaluationvisitor';\n\nclass NumericVisitor{\n  constructor( state ){\n    this.state = state;\n  }\n\n  setState( newstate ){\n    this.state = newstate;\n  }\n  execute( nonterminalOrToken ){\n    if(nonterminalOrToken.constructor.name == \"Nonterminal\" )\n    {\n        let symbolsMatched = nonterminalOrToken.seriesOfSymbolsIAbsorbedAndReplaced;\n        let value = \"FOO\"; // declare this and, hey, initialize it with something we'll notice if there's an error.\n        if( symbolsMatched.length == 1 ) // we're a nonterminal that absorbed one other thing\n        {\n          value = symbolsMatched[0].visit( this );\n          return value;\n        }\n        else if( symbolsMatched.length == 3 )// we're a boolean comprising an operator and two operands\n        {\n          // or maybe we're just a numeric wrapped in parens!\n\n          if( ( symbolsMatched[0].type == \"(\") && ( symbolsMatched[2].type == \")\") )\n          {\n            return symbolsMatched[1].visit( this );\n          }\n\n\n          if( symbolsMatched[1].type == \"+\")\n          {\n            return symbolsMatched[0].visit( this ) + symbolsMatched[2].visit( this );\n          }\n          else if( symbolsMatched[1].type == \"-\")\n          {\n            return symbolsMatched[0].visit( this ) - symbolsMatched[2].visit( this );\n          }\n          else if( symbolsMatched[1].type == \"*\")\n          {\n            return symbolsMatched[0].visit( this ) * symbolsMatched[2].visit( this );\n          }\n          else if( symbolsMatched[1].type == \"/\")\n          {\n            return symbolsMatched[0].visit( this ) / symbolsMatched[2].visit( this );\n          }\n          else if( symbolsMatched[1].type == \"^\")\n          {\n            return Math.pow( symbolsMatched[0].visit( this ), symbolsMatched[2].visit( this ));\n          }\n          else\n          {\n            throw new Error(\"WE HAVE 3 SYMBOLS BUT I DON'T KNOW WHAT THIS IS:\" + JSON.stringify( symbolsMatched ));\n          }\n        }\n        else if( symbolsMatched.length == 2 )// we're a boolean with one operator -- probably a not\n        {\n          if( symbolsMatched[0].type == \"+\")\n          {\n            return symbolsMatched[1].visit( this );\n          }\n          if( symbolsMatched[0].type == \"-\")\n          {\n            return -1 * symbolsMatched[1].visit( this );\n          }\n          else\n          {\n            throw new Error(\"IN NUMERICVISITOR, DON'T KNOW WHAT THE OPERATOR OF THIS 2-ELEMENT SYMBOLSMATCHED IS:\" + JSON.stringify( symbolsMatched ));\n          }\n        }\n\n\n        throw new Error(\"UNKNOWN LENGTH OF SYMBOLSMATCHED:\" + JSON.stringify( symbolsMatched ));\n      }\n      else // it's a token\n      {\n        if( nonterminalOrToken.type.toUpperCase().indexOf( \"NUM_LIT\" ) > -1 )\n        {\n          return parseInt( nonterminalOrToken._stringIMatched );\n        }\n        throw new Error(\"nonterminalOrToken.type is \" + nonterminalOrToken.type );\n        return null;\n      }\n  }\n}\n\nmodule.exports = NumericVisitor;\n\n\n// WEBPACK FOOTER //\n// ./js/visitors/numericvisitor.js","//import Token from './token';\n//import Symbol from './token';\nimport Lexer from './lexer';\nimport Parser from './parser';\nimport XMLParseTimeVisitor from './visitors/xmlparsetimevisitor';\nimport XMLJSONVisitor from './visitors/xmljsonvisitor';\nimport TokenFactory from './factories/tokenfactory';\nimport NonterminalFactory from './factories/nonterminalfactory';\n\nexport default class XMLius{\n  constructor( tokenDefinitions, grammarObject ){\n\n\n\n    // we set the state so that the parser knows the data type of each of these variables\n    // (in this case, boolean)\n    // and later so that the visitor can evaluate each node to determine if it is true or false.\n    this.state = {\"a\":false,\"b\":true,\"c\":false,\"d\":true,\"e\":false,\"f\":true,\"g\":false,\"h\":true,\"i\":false};\n\n    this.xmlParseTimeVisitor = new XMLParseTimeVisitor();\n\n    this.visitor = new XMLJSONVisitor(  this.state );\n    // lay the groundwork for lexical analysis\n    this.lexer = new Lexer( tokenDefinitions );\n    this.parser = new Parser( grammarObject );\n    this.parser.setState( this.state );\n  }\n\n  parse( sentenceToParse ){\n    try\n    {\n      let sentenceOfTokens = this.lexer.tokenize( sentenceToParse );\n      this.parseTree = this.parser.parse( sentenceOfTokens, this.xmlParseTimeVisitor );\n      return this.evaluateParseTree();\n    }\n    catch( e )\n    {\n      console.error( \"ERROR PARSING OR EVALUATING:\" + e );\n    }\n  }\n\n  evaluateParseTree(){\n    let result = this.parseTree[0].visit( this.visitor );\n    return result;\n  }\n}\n\n\n\n\n// WEBPACK FOOTER //\n// ./js/xmlius.js","\nimport Boolius from './boolius'; // which in turn imports all the classes it depends upon\nimport XMLius from './xmlius';\nimport Mathius from './mathius';\n\nwindow.onload = function(){\n    d3.select('#modeSelect').on('change', function(e){\n        var selectedMode = d3.select('#modeSelect').node().value.toLowerCase();\n        changeMode( selectedMode );\n    });\n\n\n    function changeMode( newMode ){\n        if( newMode.indexOf( 'arithmetic' ) > -1 )\n        {\n            // the user wants to look at arithmetic expressions.\n            // is boolius already loaded?\n            if(  !evaluator || evaluator.constructor.name != \"Mathius\" )\n            {\n                var grammarObject = [\n                    [  [\"NUMERIC\", \"^\", \"NUMERIC\" ], \"NUMERIC\" ],\n                    [  [\"NUMERIC\", \"*\", \"NUMERIC\" ], \"NUMERIC\" ],\n                    [  [\"NUMERIC\", \"+\", \"NUMERIC\" ], \"NUMERIC\", [\"*\", \"/\", \"^\"] ],\n                    [  [\"NUMERIC\", \"-\", \"NUMERIC\" ], \"NUMERIC\", [\"*\", \"/\", \"^\"] ],\n                    [  [\"NUM_LIT\" ], \"NUMERIC\" ],\n                    [  [\"(\", \"NUMERIC\", \")\" ], \"NUMERIC\" ]\n                ];\n\n                let IGNORE = true;\n\n                let tokenDefinitions = [\n                    [ /\\s+/, \"\", IGNORE ], // ignore whitespace\n                    [ /\\^/, \"^\" ], // this is the escaped form of ^\n                    [ /\\(/, \"(\" ],\n                    [ /\\)/, \")\" ],\n                    [ /\\+/, \"+\" ],\n                    [ /-/, \"-\" ],\n                    [ /\\*/, \"*\" ],\n                    [ /\\//, \"/\" ],\n                    [ /[-+]?[0-9]*\\.?[0-9]+/, \"NUM_LIT\" ],\n                    [ /[a-zA-Z]+/, \"IDENT\" ],\n                    [ /.+/, \"DIRTYTEXT\"]\n                ];\n                makeEvaluatorAndInitialize( new Mathius( tokenDefinitions, grammarObject ), \"1 + 2 ^ (5 - 2) * 3\",\n                \"Click operators to expand or collapse.\" );\n            }\n        }\n        else if( newMode.indexOf( 'boolean' ) > -1 )\n        {\n            // the user wants to look at boolean expressions.\n            // is boolius already loaded?\n            if(  !evaluator || evaluator.constructor.name != \"Boolius\" )\n            {\n                var grammarObject = [\n                    [  [\"TRUE\" ], \"BOOLEAN\" ],\n                    [  [\"FALSE\" ], \"BOOLEAN\" ],\n                    [  [\"!\", \"BOOLEAN\" ], \"BOOLEAN\" ],\n                    [  [\"BOOLEAN\", \"&\", \"BOOLEAN\" ], \"BOOLEAN\" ],\n                    [  [\"BOOLEAN\", \"|\", \"BOOLEAN\" ], \"BOOLEAN\" ],\n                    [  [\"(\", \"BOOLEAN\", \")\" ], \"BOOLEAN\" ]\n                ];\n\n                let IGNORE = true;\n\n                let tokenDefinitions = [\n                    [ /\\s+/, \"\", IGNORE ], // ignore whitespace\n                    [ /&&/, \"&\" ],\n                    [ /AND/i, \"&\" ],\n                    [ /\\|\\|/, \"|\" ], // this is the escaped form of ||\n                    [ /XOR/i, \"^\" ],\n                    [ /OR/i, \"|\" ],\n                    [ /\\^/, \"^\" ], // this is the escaped form of ^\n                    [ /\\!/, \"!\" ], // this is the escaped form of !\n                    [ /NOT/i, \"!\" ],\n                    [ /\\(/, \"(\" ],\n                    [ /\\)/, \")\" ],\n                    [ /(true)(?![a-zA-Z0-9])/i, \"TRUE\" ],\n                    [ /(false)(?![a-zA-Z0-9])/i, \"FALSE\" ],\n                    [ /[a-zA-Z]+/, \"IDENT\" ],\n                    [ /.+/, \"DIRTYTEXT\"]\n                ];\n                makeEvaluatorAndInitialize( new Boolius( tokenDefinitions, grammarObject ), \"((d && c)) || (!b && a) && (!d || !a) && (!c || !b)\",\n                \"Click operators to expand or collapse. Click leaf nodes to toggle true/false.\" );\n            }\n        }\n        else if( newMode.indexOf( 'xml' ) > -1 )\n        {\n            // the user wants to look at boolean expressions.\n            // is boolius already loaded?\n            if(  !evaluator || evaluator.constructor.name != \"XMLius\" )\n            {\n                                var grammarObject = [\n                    [  [\"OPENCOMMENT\", \"WILDCARD\", \"CLOSECOMMENT\" ], \"COMMENT\" ],\n                    [  [\"<\", \"/\", \"IDENT\", \">\" ], \"CLOSETAG\" ],\n                    [  [\"<\", \"IDENT\", \">\" ], \"OPENTAG\" ],\n                    [  [\"<\", \"IDENT\", \"/\", \">\" ], \"XMLNODE\" ],\n                    [  [\"<\", \"IDENT\", \"IDENT\", \"=\", \"\\\"\", \"WILDCARD\", \"\\\"\" ], \"OPENTAGSTART\" ],\n                    /* Some recursive self-nesting here */\n                    [  [\"OPENTAGSTART\", \"IDENT\", \"=\", \"\\\"\", \"WILDCARD\", \"\\\"\" ], \"OPENTAGSTART\" ],\n                    [  [\"OPENTAGSTART\", \">\"], \"OPENTAG\" ],\n                    [  [\"OPENTAG\", \"CLOSETAG\" ], \"XMLNODE\" ],\n                    [  [\"OPENTAG\", \"WILDCARD\", \"CLOSETAG\" ], \"XMLNODE\" ]\n                ];\n\n                let IGNORE = true;\n\n                let tokenDefinitions = [\n                    [  /\\s+/, \"\", IGNORE ],\n                    [  /<!--/, 'OPENCOMMENT' ],\n                    [  /-->/, 'CLOSECOMMENT' ],\n                    [  /\\//, \"/\" ],\n                    [  />/, \">\" ],\n                    [  /</, \"<\" ],\n                    [  /=/, \"=\" ],\n                    [  /\"/, '\"' ],\n                    [  /'/, '\"' ],\n                    [  /[-+]?[0-9]*\\.?[0-9]+/, \"NUM_LIT\" ],\n                    [  /[a-zA-Z]+/, \"IDENT\" ],\n                    [ /[^<]+/, \"DIRTYTEXT\"]\n                ];\n                makeEvaluatorAndInitialize( new XMLius( tokenDefinitions, grammarObject ),\n                \"<top foo='bar'>Hello!<simpleChildNode></simpleChildNode>There!<complexNode><simpleChildNode></simpleChildNode><simpleChildNode></simpleChildNode></complexNode></top>\",\n                \"Click nodes to expand or collapse. Click nodes to see attributes and/or content.\" );\n            }\n        }\n    }\n\n    function makeEvaluatorAndInitialize( newEvaluator, statement, hintText ){\n        assignEvaluator( newEvaluator );\n        d3.select('#statement').node().value = statement;\n        d3.select('div.hint').text( hintText );\n        evaluateStatement();\n    }\n\n    function assignEvaluator( newEvaluator ) {\n        // don't change if the user wants what they already have\n        if( evaluator && newEvaluator.constructor.name == evaluator.constructor.name ) return;\n        evaluator = newEvaluator;\n    }\n\nvar evaluator;\n\n\n\nvar winHeight = Math.max( 600, window.innerHeight );\nvar winWidth = Math.max( 1000, window.innerWidth );\n\nvar m = [0, 120, 140, 120],\n    w = winWidth - m[1] - m[3],\n    h = winHeight - m[0] - m[2],\n    i = 0,\n    root;\n\nvar tree = d3.layout.tree()\n    .size([h, w]);\n\nvar diagonal = d3.svg.diagonal()\n    .projection(function(d) { return [d.y, d.x]; });\n\nvar vis = d3.select(\"#body\").append(\"svg:svg\")\n    .attr(\"width\", w + m[1] + m[3])\n    .attr(\"height\", h + m[0] + m[2])\n  .append(\"svg:g\")\n    .attr(\"transform\", \"translate(\" + m[3] + \",\" + m[0] + \")\");\n\nvis.append(\"text\")\n\t.attr(\"opacity\", 1)\n    .attr(\"y\", 246)\n    .attr(\"dy\", \"1.71em\")\n    .style(\"font-size\",\"34px\")\n    .style(\"text-anchor\", \"end\")\n    .attr(\"id\", \"result\")\n    .text(\"\");\n\n\n\nd3.select(\"#testbutton\").on(\"click\", function(e) {\n\tevaluateStatement();\n});\n\nd3.select(\"#statement\").on(\"keyup\", function(){\n    if(d3.event.keyCode == 13){\n        d3.select(\"#testbutton\").on(\"click\")();\n    }\n});\n\nvar parseTree;\n\nfunction evaluateStatement()\n{\n    var statement = d3.select(\"#statement\").node().value;\n\tparseTree = evaluator.parse( statement );\n\tdisplayJSON( parseTree );\n};\n\nfunction displayJSON( json )\n{\n  root = json;\n  root.x0 = h / 2;\n  root.y0 = 0;\n  //d3.select(\"#statement\").val( root.title );\n  d3.select(\"#statement\").property(\"value\", root.expressionString);\n\n  d3.select(\"#result\")\n  .text( root.value )\n\n  function toggleAll(d, delay ) {\n\n  \tif( ! delay ) delay = 1;\n\n    if (d.children) {\n\t\ttoggle(d);\n    }\n\n    if (d._children) {\n\t\ttoggle(d);\n    }\n  }\n  // Initialize the display to show all nodes.\n  root.children.forEach(toggleAll, 444);\n\n  update(root);\n};\n\n// Toggle children.\nfunction toggle(d, showOverlay) {\n\tif( d == undefined ) return;\n    //boolean\n    if( d.value === true  || d.value === false )\n    {\n        if (d.children) {\n        // hide the children by moving them into _children\n            d._children = d.children;\n            d.children = null;\n        } else {\n        // bring back the hidden children\n            d.children = d._children;\n            d._children = null;\n        }\n\n        if( ! d.children && !d._children) // it's a leaf\n        {\n            // toggle true/false\n            if( ( d.value === true ) || (d.value === false ) )\n            {\n                d.value = !d.value;\n                //var myInt = parseInt( d.name );\n                //conditionTruthValues[ myInt ] = d.value;\n                var myVar = d.name;\n                evaluator.state[ myVar ] = d.value;\n                updateWithoutDeleting(root);\n            }\n        }\n    }\n    else // you clicked something that isn't in a boolean flow\n    {\n        if( showOverlay )\n        {\n            var attributeText = d.attributes ? JSON.stringify( d.attributes ) : \"None\";\n            if( ! d.children && !d._children) // it's a leaf\n            {\n                //showValueOverlay( d.value );\n\n                showValueOverlay( \"Attributes: \" + attributeText + \"</br>Content: \" + d.value );\n            }\n            else//oops, we wanted to collapse this thing\n            {\n                //showValueOverlay( \"Attributes: \" + attributeText + \"</br>Content: \" + d.value );\n                if (d.children) {\n                // hide the children by moving them into _children\n                    d._children = d.children;\n                    d.children = null;\n                } else {\n                // bring back the hidden children\n                    d.children = d._children;\n                    d._children = null;\n                }\n            }\n        }\n    }\n}\n\nfunction showValueOverlay( val ){\n    $('#valueModalText').html( val );\n    $('#valueModal').modal('show');\n}\n\nfunction updateWithoutDeleting()\n{\n    parseTree = evaluator.evaluateParseTree();\n    updateObjectAndItsChildren( parseTree, root );\n\n\td3.select(\"#result\")\n\t\t.text( root.value )\n}\n\nfunction updateObjectAndItsChildren( newObjectTemp, rootTemp )\n{\n\n    rootTemp.value = newObjectTemp.value;\n    if( ! newObjectTemp.children ) return;\n    for( var i = 0; i < newObjectTemp.children.length; i++ )\n    {\n        if( rootTemp.children )\n        {\n            updateObjectAndItsChildren( newObjectTemp.children[ i ], rootTemp.children[ i ] );\n        }\n        else\n        {\n        \tif( rootTemp._children )\n        \t{\n            \tupdateObjectAndItsChildren( newObjectTemp.children[ i ], rootTemp._children[ i ] );\n            }\n        }\n\n    }\n}\n\n\n\nfunction update(source) {\n  var duration = d3.event && d3.event.altKey ? 5000 : 500;\n\n  // Compute the new tree layout.\n  var nodes = tree.nodes(root).reverse();\n\n\n\n  // Normalize for fixed-depth.\n  // OK -- why is d.y correlated with the horizontal position here???\n\n  widthPerNode = 110;\n  var body = d3.select(\"body\");\n  var svg = body.select(\"svg\");\n  var widthInPixels = svg.style(\"width\").replace(\"px\", \"\");\n  widthInPixels = parseInt( widthInPixels );\n  var widthPerNode = widthInPixels / nodes.length;\n  nodes.forEach(function(d) { d.y = d.depth * widthPerNode; });\n\n  d3.select(\"#result\")\n  .transition()\n  .duration(duration)\n  .attr(\"x\", nodes[nodes.length -1 ].y - 40 )\n  .attr(\"y\", function(d){ return nodes[nodes.length -1 ].x - 48 } )\n\n  // Update the nodes\n  var node = vis.selectAll(\"g.node\")\n      .data(nodes, function(d) { return d.id || (d.id = ++i); });\n\n  // Enter any new nodes at the parent's previous position.\n  var nodeEnter = node.enter().append(\"svg:g\")\n      .attr(\"class\", \"node\")\n      .attr(\"transform\", function(d) { return \"translate(\" + source.y0 + \",\" + source.x0 + \")\"; })\n      .on(\"click\", function(d) { toggle(d, true ); update(d); });\n\n  nodeEnter.append(\"svg:circle\")\n      .attr(\"r\", 1e-6)\n      .style(\"stroke\", function(d){ return d.value ? \"green\" : \"red\" } )\n      .style(\"fill\", function(d) { return d._children ? \"grey\" : \"#fff\"; });\n\n  nodeEnter.append(\"svg:text\")\n      .attr(\"x\", function(d) { return d.children || d._children ? -1 : 17; })\n      .attr(\"y\", function(d) { return d.children || d._children ? 18 : -1; })\n      .attr(\"dy\", \".35em\")\n      .attr(\"text-anchor\", function(d) { return d.children || d._children ? \"middle\" : \"left\"; })\n//      .attr(\"text-anchor\", function(d) { return d.children || d._children ? \"end\" : \"start\"; })\n      .text(function(d) { return d.name; })\n      .style(\"fill-opacity\", 1e-6);\n\n  // Transition nodes to their new position.\n  var nodeUpdate = node.transition()\n      .duration(duration)\n      .style(\"stroke\", function(d){ return d.value ? \"green\" : \"red\";  } )\n      .attr(\"transform\", function(d) { return \"translate(\" + d.y + \",\" + d.x + \")\"; });\n\n  nodeUpdate.select(\"circle\")\n      .attr(\"r\", 8.5)\n      .style(\"stroke\", function(d){ return d.value ? \"green\" : \"red\" } )\n      .style(\"fill\", function(d) { return d._children ? \"lightsteelblue\" : \"#fff\"; });\n\n  nodeUpdate.select(\"text\")\n      .style(\"fill-opacity\", 1);\n\n  // Transition exiting nodes to the parent's new position.\n  var nodeExit = node.exit().transition()\n      .duration(duration)\n      .attr(\"transform\", function(d) { return \"translate(\" + source.y + \",\" + source.x + \")\"; })\n      .remove();\n\n  nodeExit.select(\"circle\")\n      .attr(\"r\", 1e-6);\n\n  nodeExit.select(\"text\")\n      .style(\"fill-opacity\", 1e-6);\n\n  // Update the links\n  var link = vis.selectAll(\"path.link\")\n      .data(tree.links(nodes), function(d) { return d.target.id; });\n\n  // Enter any new links at the parent's previous position.\n  link.enter().insert(\"svg:path\", \"g\")\n      .attr(\"class\", \"link\")\n      .attr(\"d\", function(d) {\n        var o = {x: source.x0, y: source.y0};\n        return diagonal({source: o, target: o});\n      })\n    .transition()\n      .duration(duration)\n      .attr(\"d\", diagonal);\n\n  // Transition links to their new position.\n  link.transition()\n      .duration(duration)\n      .attr(\"d\", diagonal);\n\n  // Transition exiting nodes to the parent's new position.\n  link.exit().transition()\n      .duration(duration)\n      .attr(\"d\", function(d) {\n        var o = {x: source.x, y: source.y};\n        return diagonal({source: o, target: o});\n      })\n      .remove();\n\n  // Stash the old positions for transition.\n  nodes.forEach(function(d) {\n    d.x0 = d.x;\n    d.y0 = d.y;\n  });\n}\n\nchangeMode(\"boolean\");\nevaluateStatement();\n};\n\n\n// WEBPACK FOOTER //\n// ./js/visualizer.js","\nclass BooleanJSONVisitor{\n  constructor( state ){\n    this.state = state;\n  }\n  setState( newstate ){\n    this.state = newstate;\n  }\n\n  execute( thingToEvaluate )\n  {\n        var ob = {};\n        ob.name = thingToEvaluate.type;\n        ob.value = thingToEvaluate.value = this.getBoolean( thingToEvaluate );\n        let symbolsMatched = thingToEvaluate.seriesOfSymbolsIAbsorbedAndReplaced;\n\n        switch( thingToEvaluate.type )\n        {\n            case \"TOKEN\":\n                return { name : thingToEvaluate.stringIActuallyMatched, value: this.getBoolean( thingToEvaluate ), condition: \"Condition Text Goes Here\" };\n            case \"BOOLEAN\":\n\n                ob.children = [];\n                if( symbolsMatched.length == 3 ) // there's a binary operator\n                {\n\n                  // either a binary operator or \"(\" + boolean + \")\"\n                  if( ( symbolsMatched[0].type == \"(\") && ( symbolsMatched[2].type == \")\") )\n                  {\n                    // we'll pass it through transparently\n                    // in other words, allow our middle child to represent us completely\n                    // since the user isn't interested in seeing each \"(\" represented with its own node onscreen\n                    return this.execute( symbolsMatched[ 1 ] );\n                  }\n                  else\n                  {\n                    ob.name = this.getNameForOperator( symbolsMatched[ 1 ].type );\n                    ob.children.push( this.execute( symbolsMatched[ 0 ]) );\n                    ob.children.push( this.execute( symbolsMatched[ 2 ]) );\n                  }\n                  \n                }\n                else if( symbolsMatched.length == 2 ) // there's a unary operator\n                {\n                  // the only unary operator\n                  ob.name = this.getNameForOperator( symbolsMatched[ 0 ].type ); \n                  ob.children.push( this.execute( symbolsMatched[ 1 ]) );\n                }\n                else\n                {\n                  return this.execute( symbolsMatched[ 0 ]);\n                }\n\n                break;\n\n            case \"IDENT\": // basically a passthrough. Assume our first child is a real operator, and return *its* json.\n                ob.name = thingToEvaluate._stringIMatched;\n        }\n        return ob;\n  }\n\n  getBoolean( nonterminalOrToken ){\n\n    if(nonterminalOrToken.constructor.name == \"Nonterminal\" )\n    {\n        let symbolsMatched = nonterminalOrToken.seriesOfSymbolsIAbsorbedAndReplaced;\n        let value = \"FOO\"; // declare this and, hey, initialize it with something we'll notice if there's an error.\n        if( symbolsMatched.length == 1 ) // we're a nonterminal that absorbed one other thing\n        {\n          value = this.getBoolean( symbolsMatched[0] );\n          return value;\n        }\n        else if( symbolsMatched.length == 3 )// we're a boolean comprising an operator and two operands\n        {\n          if( symbolsMatched[1].type == \"|\")\n          {\n            return this.getBoolean( symbolsMatched[0] ) || this.getBoolean( symbolsMatched[2] );\n          }\n          else if( symbolsMatched[1].type == \"&\")\n          {\n            return this.getBoolean( symbolsMatched[0] ) && this.getBoolean( symbolsMatched[2] );\n          }\n          else if( ( symbolsMatched[0].type == \"(\") && ( symbolsMatched[2].type == \")\") )\n          {\n            return this.getBoolean( symbolsMatched[1] );\n          }\n          else\n          {\n            throw new Error(\"DON'T KNOW WHAT THE OPERATOR OF THIS 3-ELEMENT SYMBOLSMATCHED IS:\" + JSON.stringify( symbolsMatched ));\n          }\n        }\n        else if( symbolsMatched.length == 2 )// we're a boolean with one operator -- probably a not\n        {\n          if( symbolsMatched[0].type == \"!\")\n          {\n            return ! this.getBoolean( symbolsMatched[1] );\n          }\n          else\n          {\n            throw new Error(\"DON'T KNOW WHAT THE OPERATOR OF THIS 2-ELEMENT SYMBOLSMATCHED IS:\" + JSON.stringify( symbolsMatched ));\n          }\n        }\n\n        throw new Error(\"UNKNOWN LENGTH OF SYMBOLSMATCHED:\" + JSON.stringify( symbolsMatched ));\n      }\n      else // it's a token\n      {\n        if( nonterminalOrToken.type.toUpperCase().indexOf( \"TRUE\" ) > -1 )\n        {\n          return true;\n        }\n        if( nonterminalOrToken.type.toUpperCase().indexOf( \"FALSE\" ) > -1 )\n        {\n          return false;\n        }\n        if( nonterminalOrToken.type.toUpperCase().indexOf( \"IDENT\" ) > -1 )\n        {\n          return this.state[ nonterminalOrToken._stringIMatched ];\n        }\n\n        throw new Error(\"nonterminalOrToken.type is \" + nonterminalOrToken.type );\n        return null;\n      }\n  }\n\n  getNameForOperator( operatorSymbol ){\n    if( operatorSymbol == \"|\" ) return \"OR\";\n    if( operatorSymbol == \"&\" ) return \"AND\";\n    if( operatorSymbol == \"^\" ) return \"XOR\";\n    if( operatorSymbol == \"!\" ) return \"NOT\";\n  }\n}\n\nmodule.exports = BooleanJSONVisitor;\n\n\n// WEBPACK FOOTER //\n// ./js/visitors/booleanjsonvisitor.js","import EvaluationVisitor from './evaluationvisitor';\n\nclass BooleanVisitor{\n  constructor( state ){\n    this.state = state;\n  }\n  setState( newstate ){\n    this.state = newstate;\n  }\n\n  execute( nonterminalOrToken ){\n    if(nonterminalOrToken.constructor.name == \"Nonterminal\" )\n    {\n        let symbolsMatched = nonterminalOrToken.seriesOfSymbolsIAbsorbedAndReplaced;\n        let value = \"FOO\"; // declare this and, hey, initialize it with something we'll notice if there's an error.\n        if( symbolsMatched.length == 1 ) // we're a nonterminal that absorbed one other thing\n        {\n          value = symbolsMatched[0].visit( this );\n          return value;\n        }\n        else if( symbolsMatched.length == 3 )// we're a boolean comprising an operator and two operands\n        {\n          if( symbolsMatched[1].type == \"|\")\n          {\n            return symbolsMatched[0].visit( this ) || symbolsMatched[2].visit( this );\n          }\n          else if( symbolsMatched[1].type == \"&\")\n          {\n            return symbolsMatched[0].visit( this ) && symbolsMatched[2].visit( this );\n          }\n          else if( ( symbolsMatched[0].type == \"(\") && ( symbolsMatched[2].type == \")\") )\n          {\n            return symbolsMatched[1].visit( this );\n          }\n          else\n          {\n            throw new Error(\"DON'T KNOW WHAT THE OPERATOR OF THIS 3-ELEMENT SYMBOLSMATCHED IS:\" + JSON.stringify( symbolsMatched ));\n          }\n        }\n        else if( symbolsMatched.length == 2 )// we're a boolean with one operator -- probably a not\n        {\n          if( symbolsMatched[0].type == \"!\")\n          {\n            return ! symbolsMatched[1].visit( this );\n          }\n          else\n          {\n            throw new Error(\"DON'T KNOW WHAT THE OPERATOR OF THIS 2-ELEMENT SYMBOLSMATCHED IS:\" + JSON.stringify( symbolsMatched ));\n          }\n        }\n\n\n        throw new Error(\"UNKNOWN LENGTH OF SYMBOLSMATCHED:\" + JSON.stringify( symbolsMatched ));\n      }\n      else // it's a token\n      {\n        if( nonterminalOrToken.type.toUpperCase().indexOf( \"TRUE\" ) > -1 )\n        {\n          return true;\n        }\n        if( nonterminalOrToken.type.toUpperCase().indexOf( \"FALSE\" ) > -1 )\n        {\n          return false;\n        }\n        if( nonterminalOrToken.type.toUpperCase().indexOf( \"IDENT\" ) > -1 )\n        {\n          return this.state[ nonterminalOrToken._stringIMatched ];\n        }\n\n        throw new Error(\"nonterminalOrToken.type is \" + nonterminalOrToken.type );\n        return null;\n      }\n  }\n}\n\nmodule.exports = BooleanVisitor;\n\n\n// WEBPACK FOOTER //\n// ./js/visitors/booleanvisitor.js","\nclass MathJSONVisitor{\n  constructor( state ){\n    this.state = state;\n  }\n  setState( newstate ){\n    this.state = newstate;\n  }\n\n  execute( thingToEvaluate )\n  {\n        var ob = {};\n        ob.name = thingToEvaluate.type;\n        ob.value = thingToEvaluate.value = this.getValue( thingToEvaluate );\n\n        let symbolsMatched = thingToEvaluate.seriesOfSymbolsIAbsorbedAndReplaced;\n\n        switch( thingToEvaluate.type )\n        {\n            case \"NUM_LIT\":\n                return { name : this.getValue( thingToEvaluate ), value: this.getValue( thingToEvaluate ), condition: \"Condition Text Goes Here\" };\n            case \"NUMERIC\":\n\n                ob.children = [];\n                if( symbolsMatched.length == 3 ) // there's a binary operator\n                {\n\n                  // either a binary operator or \"(\" + boolean + \")\"\n                  if( ( symbolsMatched[0].type == \"(\") && ( symbolsMatched[2].type == \")\") )\n                  {\n                    // we'll pass it through transparently\n                    // in other words, allow our middle child to represent us completely\n                    // since the user isn't interested in seeing each \"(\" represented with its own node onscreen\n                    return this.execute( symbolsMatched[ 1 ] );\n                  }\n                  else\n                  {\n                    ob.name = symbolsMatched[ 1 ].type;\n                    ob.children.push( this.execute( symbolsMatched[ 0 ]) );\n                    ob.children.push( this.execute( symbolsMatched[ 2 ]) );\n                  }\n\n                }\n                else if( symbolsMatched.length == 2 ) // there's a unary operator\n                {\n                  // the only unary operator\n                  ob.name = symbolsMatched[ 0 ].type;\n                  ob.children.push( this.execute( symbolsMatched[ 1 ]) );\n                }\n                else\n                {\n                  return this.execute( symbolsMatched[ 0 ]);\n                }\n\n                break;\n\n            case \"IDENT\": // basically a passthrough. Assume our first child is a real operator, and return *its* json.\n                ob.name = thingToEvaluate._stringIMatched;\n        }\n        return ob;\n  }\n\n  getValue( nonterminalOrToken ){\n    if(nonterminalOrToken.constructor.name == \"Nonterminal\" )\n    {\n        let symbolsMatched = nonterminalOrToken.seriesOfSymbolsIAbsorbedAndReplaced;\n        let value = \"FOO\"; // declare this and, hey, initialize it with something we'll notice if there's an error.\n        if( symbolsMatched.length == 1 ) // we're a nonterminal that absorbed one other thing\n        {\n          value = this.getValue( symbolsMatched[0] );\n          return value;\n        }\n        else if( symbolsMatched.length == 3 )// we're a boolean comprising an operator and two operands\n        {\n          // or maybe we're just a numeric wrapped in parens!\n\n          if( ( symbolsMatched[0].type == \"(\") && ( symbolsMatched[2].type == \")\") )\n          {\n            return this.getValue( symbolsMatched[1] );\n          }\n\n          if( symbolsMatched[1].type == \"+\")\n          {\n            return this.getValue( symbolsMatched[0] ) + this.getValue( symbolsMatched[2] );\n          }\n          else if( symbolsMatched[1].type == \"-\")\n          {\n            return this.getValue( symbolsMatched[0] ) - this.getValue( symbolsMatched[2] );\n          }\n          else if( symbolsMatched[1].type == \"*\")\n          {\n            return this.getValue( symbolsMatched[0] ) * this.getValue( symbolsMatched[2] );\n          }\n          else if( symbolsMatched[1].type == \"/\")\n          {\n            return this.getValue( symbolsMatched[0] ) / this.getValue( symbolsMatched[2] );\n          }\n          else if( symbolsMatched[1].type == \"^\")\n          {\n            return Math.pow( this.getValue( symbolsMatched[0] ), this.getValue( symbolsMatched[2] ));\n          }\n          else\n          {\n            throw new Error(\"WE HAVE 3 SYMBOLS BUT I DON'T KNOW WHAT THIS IS:\" + JSON.stringify( symbolsMatched ));\n          }\n        }\n        else if( symbolsMatched.length == 2 )// we're a boolean with one operator\n        {\n          if( symbolsMatched[0].type == \"+\")\n          {\n            return this.getValue( symbolsMatched[1] );\n          }\n          if( symbolsMatched[0].type == \"-\")\n          {\n            return -1 * this.getValue( symbolsMatched[1] );\n          }\n          else\n          {\n            throw new Error(\"IN NUMERICVISITOR, DON'T KNOW WHAT THE OPERATOR OF THIS 2-ELEMENT SYMBOLSMATCHED IS:\" + JSON.stringify( symbolsMatched ));\n          }\n        }\n\n\n        throw new Error(\"UNKNOWN LENGTH OF SYMBOLSMATCHED:\" + JSON.stringify( symbolsMatched ));\n      }\n      else // it's a token\n      {\n        if( nonterminalOrToken.type.toUpperCase().indexOf( \"NUM_LIT\" ) > -1 )\n        {\n          return parseInt( nonterminalOrToken._stringIMatched );\n        }\n        throw new Error(\"nonterminalOrToken.type is \" + nonterminalOrToken.type );\n        return null;\n      }\n  }\n\n  getNameForOperator( operatorSymbol ){\n    if( operatorSymbol == \"|\" ) return \"OR\";\n    if( operatorSymbol == \"&\" ) return \"AND\";\n    if( operatorSymbol == \"^\" ) return \"XOR\";\n    if( operatorSymbol == \"!\" ) return \"NOT\";\n  }\n}\n\nmodule.exports = MathJSONVisitor;\n\n\n// WEBPACK FOOTER //\n// ./js/visitors/mathjsonvisitor.js","import Token from '../token';\n\nclass XMLJSONVisitor{\n  constructor( state ){\n    this.state = state;\n  }\n  setState( newstate ){\n    this.state = newstate;\n  }\n\n  execute( thingToEvaluate )\n  {\n        var ob = {};\n        ob.name = thingToEvaluate.type;\n        ob.value = this.getValue( thingToEvaluate );\n        let symbolsMatched = thingToEvaluate.symbolsMatched;\n\n        switch( thingToEvaluate.type )\n        {\n\n            case \"TOKEN\":\n                return { name : thingToEvaluate.stringIActuallyMatched, value: this.getValue( thingToEvaluate ), condition: \"Condition Text Goes Here\" };\n            case \"XMLNODE\":\n\n                ob.children = [];\n                // opentag is first item, and that gives us our name\n                ob.name = this.getValue( symbolsMatched[ 0 ] );\n                var optionalAttributes = this.getAttributes( symbolsMatched[ 0 ] );\n\n                if( optionalAttributes )\n                {\n                  ob.attributes = optionalAttributes;\n                }\n\n                symbolsMatched = this.consolidateChildrenThatAreTokens( symbolsMatched );\n\n                for( var i = 1; i < symbolsMatched.length - 1; i++ ) // -1, because the last match will be a closetag, which is irrelevant\n                {\n                  ob.children.push( this.execute( symbolsMatched[ i ]) );\n                }\n\n\n                break;\n\n            case \"IDENT\": // basically a passthrough. Assume our first child is a real operator, and return *its* json.\n                ob.name = thingToEvaluate._stringIMatched;\n        }\n        return ob;\n  }\n\n  // good for the wildcard globbing we do inside open and close tags\n  consolidateChildrenThatAreTokens( arrayOfSymbolsThatMightBeTokens ) {\n    let symbolChildrenOnly = [];\n    let runningStringOfTokenText = \"\";\n    for( var symbol of arrayOfSymbolsThatMightBeTokens ){\n      if( symbol.constructor.name != \"Token\" )\n      {\n        if( runningStringOfTokenText.length > 0 ) // we've been building up a text string!\n        {\n          let tokenConsolidatingStrings = this.makeTokenWrappingString( runningStringOfTokenText );\n          symbolChildrenOnly.push( tokenConsolidatingStrings );\n          runningStringOfTokenText = \"\";\n          symbolChildrenOnly.push( symbol );\n        }\n        else\n        {\n          symbolChildrenOnly.push( symbol );\n        }\n      }\n      else // it's a token!\n      {\n\n         runningStringOfTokenText += symbol._stringIMatched;\n\n      }\n    }\n\n    if( runningStringOfTokenText.length > 0 )\n    {\n      let tokenConsolidatingStrings = this.makeTokenWrappingString( runningStringOfTokenText );\n      symbolChildrenOnly.push( tokenConsolidatingStrings );\n    }\n\n    return symbolChildrenOnly;\n  }\n\n  makeTokenWrappingString( stringToWrap ){\n    let newSymbol = new Token( /.+/, \"TEXTNODE\", stringToWrap.length, stringToWrap );\n    return newSymbol;\n  }\n\n  // sent either an opentag or an opentagstart\n  getAttributes( childOfXMLNode ) {\n\n    if( childOfXMLNode.type == \"OPENTAGSTART\" )\n    {\n      // could be nested\n      // or could just be <, IDENT, IDENT, =, ', WILDCARD, '\n      let atts = {};\n      if( childOfXMLNode.symbolsMatched[0].constructor.name == \"Token\" ) // could only be \"<\"\n      {\n        let name = this.getValue( childOfXMLNode.symbolsMatched[2] );\n        let val = this.getValue( childOfXMLNode.symbolsMatched[5] );\n        atts[ name ] = val;\n        return atts;\n      }\n      else if(childOfXMLNode.symbolsMatched[0].type == \"OPENTAGSTART\")\n      {\n        atts = this.getAttributes( childOfXMLNode.symbolsMatched[0] );\n        let name = this.getValue( childOfXMLNode.symbolsMatched[1] );\n        let val = this.getValue( childOfXMLNode.symbolsMatched[4] );\n        atts[ name ] = val;\n        return atts;\n      }\n    }\n    else if(childOfXMLNode.symbolsMatched[0].type == \"OPENTAGSTART\")\n    {\n      let returnAtts = this.getAttributes( childOfXMLNode.symbolsMatched[0] );\n      return returnAtts;\n    }\n    return null;\n  }\n\n  getValue( nonterminalOrToken ){\n\n    if(nonterminalOrToken.constructor.name == \"Nonterminal\" )\n    {\n        let symbolsMatched = nonterminalOrToken.symbolsMatched;\n\n        let value = \"FOO\"; // declare this and, hey, initialize it with something we'll notice if there's an error.\n\n        if( nonterminalOrToken.type == \"XMLNODE\")\n        {\n          // our first child will be our opentag, which is where our name comes from.\n          let returnVal = this.getValue( symbolsMatched[0] );\n          return returnVal;\n        }\n\n        if( nonterminalOrToken.type == \"OPENTAG\" || nonterminalOrToken.type == \"OPENTAGSTART\")\n        {\n          var returnVal;\n          // symbolsMatched[1] will either be an IDENT or an OPENTAGSTART (the wrapper for attribute definitions)\n          if( symbolsMatched[0].type == \"OPENTAGSTART\" )\n          {\n            returnVal = this.getValue( symbolsMatched[0] );\n            return returnVal;\n          }\n          returnVal = this.getValue( symbolsMatched[1] );\n          return returnVal;\n        }\n\n        if( nonterminalOrToken.type == \"CLOSETAG\")\n        {\n            return this.getValue( symbolsMatched[2] ); // after < and /\n        }\n\n        if( nonterminalOrToken.type == \"COMMENT\")\n        {\n          let commentstring = \"\";\n          for(var kid of nonterminalOrToken.symbolsMatched )\n          {\n            if( kid.type == \"OPENCOMMENT\" || kid.type == \"CLOSECOMMENT\") continue;\n            commentstring += this.getValue( kid );\n          }\n            return commentstring;\n        }\n\n        if( nonterminalOrToken.type == \"NODETEXT\")\n        {\n          let contentstring = \"\";\n          for(var kid of nonterminalOrToken.symbolsMatched )\n          {\n            if( ( kid.type == \"NODETEXT\" )  || ( kid.type == \"IDENT\" )  )\n              contentstring += this.getValue( kid );\n          }\n          return contentstring;\n        }\n\n        throw new Error(\"XMLJSONVISITOR UNKNOWN LENGTH OF SYMBOLSMATCHED for \" + nonterminalOrToken.type + \":\" + JSON.stringify( symbolsMatched ));\n      }\n      else // it's a token\n      {\n        if( nonterminalOrToken.type.toUpperCase().indexOf( \"TRUE\" ) > -1 )\n        {\n          return true;\n        }\n        if( nonterminalOrToken.type.toUpperCase().indexOf( \"TEXTNODE\" ) > -1 )\n        {\n          return nonterminalOrToken._stringIMatched;\n        }\n        if( nonterminalOrToken.type.toUpperCase().indexOf( \"IDENT\" ) > -1 )\n        {\n          return nonterminalOrToken._stringIMatched;\n        }\n        return nonterminalOrToken._stringIMatched;\n//        throw new Error(\"nonterminalOrToken.type is \" + nonterminalOrToken.type );\n//        return null;\n      }\n  }\n}\n\nmodule.exports = XMLJSONVisitor;\n\n\n// WEBPACK FOOTER //\n// ./js/visitors/xmljsonvisitor.js","\nclass XMLParseTimeVisitor{\n  constructor( state ){\n    this.state = state;\n  }\n  setState( newstate ){\n    this.state = newstate;\n  }\n\n  execute( nonterm )\n  {\n\n    if( nonterm.type == \"XMLNODE\")\n    {\n      return this.verifyOpeningAndCloseTagsMatch( nonterm ) && this.verifyTagContentIsLegal( nonterm );\n    }\n    else if( nonterm.type == \"OPENTAG\")\n    {\n      return this.verifyAttributeContentIsLegal( nonterm );\n    }\n    else return true;\n  }\n\n  verifyOpeningAndCloseTagsMatch( thingToEvaluate ) {\n      \n      \n      let openTagName   = this.getTagName( thingToEvaluate.symbolsMatched[ 0 ] );\n       let closeTagName;\n      if( thingToEvaluate.symbolsMatched.length == 2 )\n      {\n        closeTagName = this.getTagName( thingToEvaluate.symbolsMatched[ 1 ] );\n      }\n      else if( thingToEvaluate.symbolsMatched.length > 2 )\n      {\n        closeTagName  = this.getTagName( thingToEvaluate.symbolsMatched[ thingToEvaluate.symbolsMatched.length - 1] );\n      }\n      \n      return openTagName == closeTagName;\n  }\n\n  verifyAttributeContentIsLegal( nonterm ){\n    // remember that OPENTAG can contain optional OPENTAGSTART nodes\n    // each of which can enclose other OPENTAGSTART nodes in perpetuity\n    return true;\n  }\n\n  verifyTagContentIsLegal( thingToEvaluate ){\n    return true;\n  }\n\n\n  getTagName( thingToEvaluate ){\n\n\n    while( thingToEvaluate.type != \"IDENT\" )\n    {\n      \n      if( thingToEvaluate.type == \"OPENTAG\")\n      {\n        if( thingToEvaluate.symbolsMatched)\n        {\n          if(  thingToEvaluate.symbolsMatched[0].type == \"<\")\n          {\n            \n            return thingToEvaluate.symbolsMatched[1]._stringIMatched;\n          }\n        }\n      }\n      else if( thingToEvaluate.type == \"CLOSETAG\")\n      {\n        \n        if( thingToEvaluate.symbolsMatched)\n        {\n          if(  thingToEvaluate.symbolsMatched[0].type == \"<\")\n          {\n            // element [1] will be \"/\" so we'll skip to [2]\n            \n            return thingToEvaluate.symbolsMatched[2]._stringIMatched;\n          }\n        }\n      }\n      else if( thingToEvaluate.type == \"OPENTAGSTART\")\n      {\n        \n        if( thingToEvaluate.symbolsMatched)\n        {\n          if(  thingToEvaluate.symbolsMatched[0].type == \"<\")\n          {\n            return thingToEvaluate.symbolsMatched[1]._stringIMatched;\n          }\n        }\n      }\n      thingToEvaluate = thingToEvaluate.symbolsMatched[0]\n    }\n    return thingToEvaluate._stringIMatched;\n    }\n}\n\n\n\nmodule.exports = XMLParseTimeVisitor;\n\n\n// WEBPACK FOOTER //\n// ./js/visitors/xmlparsetimevisitor.js"],"sourceRoot":""}