{"version":3,"sources":["webpack:///webpack/bootstrap 9d54030416ad06c17b2f","webpack:///./js/factories/nonterminalfactory.js","webpack:///./js/factories/tokenfactory.js","webpack:///./js/symbol.js","webpack:///./js/lexer.js","webpack:///./js/parser.js","webpack:///./js/nonterminal.js","webpack:///./js/token.js","webpack:///./js/visitors/booleanjsonvisitor.js","webpack:///./js/xmlius.js","webpack:///./js/visitors/xmljsonvisitor.js","webpack:///./js/visitors/xmlparsetimevisitor.js","webpack:///./js/boolius.js"],"names":["NonterminalFactory","grammarObject","nonterminals","grammarRule","nonterminal","length","lookaheadTokensToAvoid","push","TokenFactory","tokenDefinitions","tokens","tokenDefinition","makeToken","regex","name","ignore","token","IGNORE","makeTokenFromDefinition","Symbol","_name","someName","Lexer","tokenFactory","getTokens","sentenceToTokenize","arrayOfTokens","startingLetter","stringToMatch","foundAMatchSomewhere","lengthOfMatch","matchYourselfToStartOfThisStringAndAddSelfToArray","Error","charAt","Parser","nonterminalFactory","getNonterminals","state","sentenceOfSymbols","resolvedSymbols","symbol","shift","constructor","type","_stringIMatched","nonterm","seriesOfSymbolsIAbsorbedAndReplaced","traceString","parseTimeVisitor","resolveIdentifiersToTypes","arrayOfSymbolsMatchedBeforeMe","finished","madeAMatch","getSimpleStringForSentence","slice","Nonterminal","seriesOfSymbolsIMustMatch","wildcardMode","join","returnString","toString","evaluationVisitor","execute","sentenceOfSymbolsToMatch","care","toStringSimple","sentenceOfSymbolsToMatchClone","console","log","seriesOfSymbolsIMustMatchClone","done","symbolThatBreaksWildcard","mySymbol","theirSymbol","getFrozenClone","theirNextSymbol","indexOf","frozenClone","Token","regexOfThingsIMustMatch","leng","stringIActuallyMatched","startIndex","_type","start","_length","_ignore","symbolArray","startingIndex","match","exec","index","frozenToken","substring","BooleanJSONVisitor","newstate","thingToEvaluate","ob","value","getBoolean","symbolsMatched","condition","children","getNameForOperator","nonterminalOrToken","JSON","stringify","toUpperCase","operatorSymbol","module","exports","XMLius","xmlParseTimeVisitor","visitor","lexer","parser","setState","sentenceToParse","sentenceOfTokens","tokenize","parseTree","parse","evaluateParseTree","e","error","result","visit","window","XMLJSONVisitor","getValue","optionalAttributes","getAttributes","attributes","consolidateChildrenThatAreTokens","i","arrayOfSymbolsThatMightBeTokens","symbolChildrenOnly","runningStringOfTokenText","tokenConsolidatingStrings","makeTokenWrappingString","stringToWrap","newSymbol","childOfXMLNode","atts","val","returnAtts","returnVal","commentstring","kid","XMLParseTimeVisitor","verifyOpeningAndCloseTagsMatch","verifyTagContentIsLegal","verifyAttributeContentIsLegal","openTagName","getTagName","closeTagName","Boolius","alert"],"mappings":"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","file":"boolius.bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/build\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 11);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 9d54030416ad06c17b2f","import Nonterminal from '../nonterminal';\n\nexport default class NonterminalFactory{\n  constructor(grammarObject){\n    this.grammarObject = grammarObject;\n    this.nonterminals = [];\n    for( let grammarRule of grammarObject )\n    {\n      let nonterminal = new Nonterminal( grammarRule[0], grammarRule[1] );\n      if( grammarRule.length > 2 ) // it has an array of lookaheadTokensToAvoid\n      {\n        nonterminal.lookaheadTokensToAvoid = grammarRule[2];\n      }\n      this.nonterminals.push( nonterminal );\n    }\n  }\n\n  getNonterminals(){\n    return this.nonterminals;\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ./js/factories/nonterminalfactory.js","import Token from '../token';\n\nexport default class TokenFactory{\n   constructor( tokenDefinitions ){\n     this.tokens = [];\n     this.tokenDefinitions = tokenDefinitions;\n   }\n\n   makeTokenFromDefinition( tokenDefinition ){\n     return this.makeToken( tokenDefinition[0], tokenDefinition[1], tokenDefinition.length > 2 ? tokenDefinition[2] : false );\n   }\n    makeToken( regex, name, ignore = false )\n    {\n      var token = new Token( regex, name, 0, \"\", ignore );\n      this.tokens.push( token );\n      return token;\n    }\n\n    getTokens()\n    {\n      let IGNORE = true;\n\n      for( let tokenDefinition of this.tokenDefinitions )\n      {\n        this.makeTokenFromDefinition( tokenDefinition )\n      }\n      return this.tokens;\n\n    }\n}\n\n\n// WEBPACK FOOTER //\n// ./js/factories/tokenfactory.js","export default class Symbol{\n  constructor(){\n\n  }\n  get name(){\n    return this._name;\n  }\n  set name( someName ){\n    this._name = someName;\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ./js/symbol.js","import TokenFactory from './factories/tokenfactory';\n\nexport default class Lexer{\n\n  constructor( tokenDefinitions ){\n    let tokenFactory = new TokenFactory( tokenDefinitions );\n    this.tokens = tokenFactory.getTokens();\n  }\n\n  tokenize( sentenceToTokenize ){\n    let arrayOfTokens = [];\n    var startingLetter = 0;\n    let stringToMatch = sentenceToTokenize; // want to keep original sentence for length/reference\n\n    while(  startingLetter < sentenceToTokenize.length )\n    {\n      let foundAMatchSomewhere = false;\n      for (var token of this.tokens)\n      {\n        let lengthOfMatch = 0;\n        [lengthOfMatch, arrayOfTokens, stringToMatch ] =\n        token.matchYourselfToStartOfThisStringAndAddSelfToArray( arrayOfTokens, stringToMatch, startingLetter );\n        if( lengthOfMatch > 0 )\n        {\n          foundAMatchSomewhere = true;\n          startingLetter += lengthOfMatch;\n          break; // START AT THE TOP OF OUR TOKEN LIST!!\n          // That is IMPORTANT.\n          // Some of our later tokens, like IDENT, are catch-alls that will greedily snatch up keywords like NOT\n        }\n      }\n      if(! foundAMatchSomewhere)\n      {\n        throw new Error(\"Illegal character \" + stringToMatch.charAt(0) + \" at position \" + startingLetter );\n      }\n    }\n    return arrayOfTokens;\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ./js/lexer.js","import Symbol from './symbol'\nimport Nonterminal from './nonterminal'\nimport NonterminalFactory from '../js/factories/nonterminalfactory';\n\nexport default class Parser{\n  constructor( grammarObject ){\n    let nonterminalFactory = new NonterminalFactory( grammarObject );\n    this.nonterminals = nonterminalFactory.getNonterminals();\n    this.state = {};\n  }\n\n  setState( state ) {\n    this.state = state; // generally just a lookup table for declared/initialized variables\n  }\n\n  // What does this do? Well, if there's a token of type IDENT, it's a variable.\n  // If that variable hasn't been declared, then how are we supposed to know what type it is?\n  // We'll be strongly-typed so that even a simple grammar can work effectively.\n  resolveIdentifiersToTypes( sentenceOfSymbols ){\n    let resolvedSymbols = [];\n    while( sentenceOfSymbols.length > 0 )\n    {\n      let symbol = sentenceOfSymbols.shift();\n      // we only care about tokens\n      if( symbol.constructor.name == \"Token\")\n      {\n        if( symbol.type == \"IDENT\")\n        {\n          // so now we can wrap our variable in the appropriate nonterminal type\n          if( typeof this.state[symbol._stringIMatched] == \"boolean\")\n          {\n            let nonterm = new Nonterminal( [\"IDENT\"], \"BOOLEAN\" );\n            nonterm.seriesOfSymbolsIAbsorbedAndReplaced = [ symbol ];\n            symbol = nonterm;\n          }\n          resolvedSymbols.push( symbol );\n          continue;\n        }\n        else\n        {\n          resolvedSymbols.push( symbol );\n        }\n      }\n      else\n      {\n        resolvedSymbols.push( symbol );\n      }\n    }\n    return resolvedSymbols;\n  }\n\n  getSimpleStringForSentence( sentenceOfSymbols ) {\n          let traceString = \"\";\n          for( var symbol of sentenceOfSymbols )\n          {\n            traceString += symbol.type + \" \";\n          }\n          return traceString;\n  }\n\n  parse( sentenceOfSymbols, parseTimeVisitor = null ){\n\n    sentenceOfSymbols = this.resolveIdentifiersToTypes( sentenceOfSymbols );\n    let arrayOfSymbolsMatchedBeforeMe = [];\n    let lengthOfMatch = 0;\n    let finished = false;\n    while( !finished ){\n        let madeAMatch = false;\n        //console.log(\"------- Starting at top of nonterminals list -------\" );\n        for( var nonterminal of this.nonterminals )\n        {\n          // we'll go through the input sentence\n          // and try to match this nonterminal to the beginning of it.\n          // if there's a match, then our nonterminal will be part of the future sentence.\n          // (replacing whatever portion it matched.)\n          // if there's no match, we want to pop a symbol off the start of the input sentence\n          // (moving it into the future sentence, since we )\n          let traceString = this.getSimpleStringForSentence( sentenceOfSymbols );\n          while( sentenceOfSymbols.length > 0 )\n          {\n            //console.log(\"USING nonterminal \" + nonterminal.toStringSimple() + \" to look at \" + traceString );\n            [lengthOfMatch, arrayOfSymbolsMatchedBeforeMe, sentenceOfSymbols ] =\n            nonterminal.matchYourselfToStartOfThisStringAndAddSelfToArray( arrayOfSymbolsMatchedBeforeMe, sentenceOfSymbols, parseTimeVisitor );\n\n            // if we matched, then the good news is, the input sentence is now changed\n            // so we don't have to worry about changing it.\n            // otherwise, we didn't match the beginning of the input sentence,\n            // so let's pop a symbol off it and try again.\n            if( lengthOfMatch == 0 )\n            {\n\n              arrayOfSymbolsMatchedBeforeMe.push( sentenceOfSymbols.shift() );\n              traceString = this.getSimpleStringForSentence( sentenceOfSymbols );\n            }\n            else\n            {\n              //console.log(\"MATCHED nonterminal \" + nonterminal.toStringSimple() + \" to sentence \" + traceString );\n              madeAMatch = true;\n            }\n          }\n\n          // ok, we did what we could. let's gather our processed items and hand them to the next nonterminal to process.\n          sentenceOfSymbols = arrayOfSymbolsMatchedBeforeMe.slice(0); // make sure we copy the items over and keep these two arrays discrete!\n          arrayOfSymbolsMatchedBeforeMe = [];\n          //console.log(\"sentenceOfSymbols is now \" + sentenceOfSymbols );\n          // are we done? if so, then don't bother looking at other nonterminals!\n          if( sentenceOfSymbols.length <= 1 )\n          {\n            finished == true;\n            break;\n          }\n\n          // we need to start from the top of our nonterminals if we made a match!\n          // order MATTERS.\n          if( madeAMatch ) break;\n\n        } // end of cycling through our array of nonterminals\n\n        if( sentenceOfSymbols.length <= 1 )\n        {\n          finished = true;\n        }\n\n    }  // end of our \"while\" loop going through sentenceOfSymbols until finished == true\n\n    return sentenceOfSymbols;\n  }\n\n\n\n\n}\n\n\n// WEBPACK FOOTER //\n// ./js/parser.js","import Symbol from './symbol'\n\nexport default class Nonterminal extends Symbol{\n\n    constructor( seriesOfSymbolsIMustMatch, type ){\n      super();\n      this.seriesOfSymbolsIMustMatch  = seriesOfSymbolsIMustMatch;\n      this.type                       = type;\n      this.seriesOfSymbolsIAbsorbedAndReplaced = [];\n      this.wildcardMode = false;\n      this.lookaheadTokensToAvoid = null;\n    }\n\n    toStringSimple(){\n      return this.seriesOfSymbolsIMustMatch.join( ' ' );\n    }\n\n    toString(){\n      let returnString = this.type + \" (\";\n\n      for( var symbol of this.seriesOfSymbolsIAbsorbedAndReplaced )\n      {\n        returnString += \" \" + symbol.toString();\n      }\n      return returnString;\n    }\n\n    get symbolsMatched(){\n      return this.seriesOfSymbolsIAbsorbedAndReplaced;\n    }\n\n    get length(){\n      return this.seriesOfSymbolsIAbsorbedAndReplaced.length;\n    }\n\n    visit( evaluationVisitor ) {\n      return evaluationVisitor.execute( this );\n    }\n\n    matchYourselfToStartOfThisStringAndAddSelfToArray( arrayOfSymbolsMatchedBeforeMe, sentenceOfSymbolsToMatch, parseTimeVisitor ){\n\n      let care = false;\n\n      if( this.toStringSimple() == \"BOOLEAN & BOOLEAN\" )\n      {\n        //care = true;\n      }\n      // clone it so we don't destroy the original in case we're only a partial match\n\n      let sentenceOfSymbolsToMatchClone = sentenceOfSymbolsToMatch.slice(0);\n\n      if( care ) console.log(\"sentenceOfSymbolsToMatchClone is \" + sentenceOfSymbolsToMatchClone );\n\n      // same with ours\n\n      let seriesOfSymbolsIMustMatchClone = this.seriesOfSymbolsIMustMatch.slice(0);\n\n      if( care ) console.log(\"seriesOfSymbolsIMustMatchClone is \" + seriesOfSymbolsIMustMatchClone );\n\n      this.seriesOfSymbolsIAbsorbedAndReplaced = [];\n\n      let done = false;\n\n      // in case of wildcard, we need to know what the previous symbol was\n\n      let symbolThatBreaksWildcard = null;\n\n      while( seriesOfSymbolsIMustMatchClone.length > 0 )\n      {\n        if( care ) console.log(\"at top of seriesOfSymbolsIMustMatchClone.length loop, where seriesOfSymbolsIMustMatchClone.length is \" + seriesOfSymbolsIMustMatchClone.length );\n        let mySymbol = seriesOfSymbolsIMustMatchClone.shift();\n        let theirSymbol = sentenceOfSymbolsToMatchClone.shift();\n\n        if( care ) console.log(\"mySymbol is \" + mySymbol );\n        if( care ) console.log(\"theirSymbol is \" + theirSymbol );\n\n        // if they ran out of symbols, then we're obviously not a match. UNLESS we were in wildcard mode.\n        if( ! theirSymbol )\n        {\n            this.seriesOfSymbolsIAbsorbedAndReplaced = [];\n            return [ 0, arrayOfSymbolsMatchedBeforeMe, sentenceOfSymbolsToMatch ];\n        }\n\n\n\n        if( mySymbol == \"WILDCARD\" )\n        {\n          this.wildcardMode = true;\n          symbolThatBreaksWildcard = seriesOfSymbolsIMustMatchClone.shift();\n          while( theirSymbol.type != symbolThatBreaksWildcard )\n          {\n            this.seriesOfSymbolsIAbsorbedAndReplaced.push( theirSymbol );\n\n            if( sentenceOfSymbolsToMatchClone.length == 0 ) // they ran out of symbols in their sentence!\n            {\n              if( seriesOfSymbolsIMustMatchClone.length == 0 ) // that wildcard was my last character\n              {\n                arrayOfSymbolsMatchedBeforeMe.push( this.getFrozenClone() );\n                return [ this.length, arrayOfSymbolsMatchedBeforeMe, sentenceOfSymbolsToMatchClone ];\n              }\n              else // failure -- we had more to match but they ran out first\n              {\n                this.seriesOfSymbolsIAbsorbedAndReplaced = [];\n                return [ 0, arrayOfSymbolsMatchedBeforeMe, sentenceOfSymbolsToMatch ];\n              }\n            }\n            else\n            {\n              theirSymbol = sentenceOfSymbolsToMatchClone.shift();\n\n            }\n          } //end of tight loop inside wildcard mode, but still in wildcard mode\n\n          // absorb the one that got us out of the wildcard\n          // i.e., it matched the symbol of ours that follows (and thus ends) the wildcard\n\n          this.seriesOfSymbolsIAbsorbedAndReplaced.push( theirSymbol );\n\n          // we made it through!\n          // if that was the last one, then we should skip the rest of the matching and go right to success\n          // if not, keep the process going -- get a new symbol from them\n          if( seriesOfSymbolsIMustMatchClone.length == 0 ) // we don't have any more\n          {\n            done = true;\n          }\n          else if( sentenceOfSymbolsToMatchClone.length > 0 ) // we have more, and they have more things that need matching\n          {\n            theirSymbol = sentenceOfSymbolsToMatchClone.shift();\n            // but if our wildcard was our last character, then we should leave\n          }\n          else // we have more, but they don't!\n          {\n            this.seriesOfSymbolsIAbsorbedAndReplaced = [];\n            return [ 0, arrayOfSymbolsMatchedBeforeMe, sentenceOfSymbolsToMatch ];\n          }\n        } // end of wildcard loop\n\n        if (!done )\n        {\n          // do they match? i.e., the next character in the sentence -- does it match the next symbol in my internal list?\n          if( theirSymbol.type != mySymbol )\n          {\n            return [ 0, arrayOfSymbolsMatchedBeforeMe, sentenceOfSymbolsToMatch ];\n          }\n          else\n          {\n            if( care ) console.log(\"OK, we matched symbols and done is \" + done );\n            this.seriesOfSymbolsIAbsorbedAndReplaced.push( theirSymbol );\n          }\n        }\n      }// bottom of seriesOfSymbolsIMustMatchClone.length loop\n\n      if( care ) console.log(\"ALL IS WELL SO FAR\");\n      // we made it through -- matched everything we needed to -- but maybe there's a problem after all...\n      // now, there's an edge case -- good for operator precedence enforcement\n      // -- the lookahead tokens.\n      // maybe we matched everything we needed, and that's great,\n      // but maybe the next token in the sentence is a dealbreaker!\n      // for example, 1 + 2 * 3\n      // if we're NUMERIC + NUMERIC, we'll find a match\n      // but that is wrong! because the next token *after* our possible match is a *\n      // and that has higher precedence than +\n\n      if( this.lookaheadTokensToAvoid )\n      {\n        if(care) console.log(\"LOOKAHEADS!!!\" + this.lookaheadTokensToAvoid);\n        if( sentenceOfSymbolsToMatchClone.length > 0 )\n        {\n          let theirNextSymbol = sentenceOfSymbolsToMatchClone[0];\n          if( this.lookaheadTokensToAvoid.indexOf( theirNextSymbol.type ) > -1 )\n          {\n            return [ 0, arrayOfSymbolsMatchedBeforeMe, sentenceOfSymbolsToMatch ];\n          }\n        }\n      }\n      // we made it here! must be a basically perfect match.\n      // but let's see if there's a context stack for this parser\n      // e.g., an XML parser keeps a stack of open nodes\n      // so that when you hit a closing tag for a node\n      // the parser can know if it's the most recently opened tag\n      if( ! parseTimeVisitor || parseTimeVisitor.execute( this ) )\n      {\n        arrayOfSymbolsMatchedBeforeMe.push( this.getFrozenClone() );\n        return [ this.length, arrayOfSymbolsMatchedBeforeMe, sentenceOfSymbolsToMatchClone ];\n      }\n      else\n      {\n        return [ 0, arrayOfSymbolsMatchedBeforeMe, sentenceOfSymbolsToMatch ];\n      }\n    }\n\n    getFrozenClone(){\n\n      let frozenClone = new Nonterminal( this.seriesOfSymbolsIMustMatch, this.type );\n\n      frozenClone.seriesOfSymbolsIAbsorbedAndReplaced = this.seriesOfSymbolsIAbsorbedAndReplaced;\n\n      return frozenClone;\n    }\n\n}\n\n\n// WEBPACK FOOTER //\n// ./js/nonterminal.js","import Symbol from './symbol'\n\nexport default class Token extends Symbol{\n\n  /***\n   * We are one of the two types of Symbol this parser deals with:\n   * Tokens and Nonterminals.\n   * A Token is basically a Symbol that contains one or more string characters.\n   * A Nonterminal is basically a Symbol that contains one or more Symbols\n   * (each of which can be either a Token or a Nonterminal).\n   *\n   * First argument will be a regex that will match some of the raw input stream.\n   * Second argument will be the internal representation I will use for myself\n   * (a string).\n   *\n   */\n  constructor( regexOfThingsIMustMatch, type, leng, stringIActuallyMatched, ignore, startIndex = -1 ){\n    super();\n    this.regexOfThingsIMustMatch = regexOfThingsIMustMatch;\n    this._type = type;\n    this.start = startIndex;\n    this._length = leng ? leng : 0;\n    this._stringIMatched = stringIActuallyMatched;\n    this._ignore = ignore;\n  }\n\n  get type(){\n    return this._type;\n  }\n\n  toStringSimple(){\n      return \" \" +  this._type + \" \" ;\n  }\n\n  get length(){\n    return this._length;\n  }\n\n  visit( evaluationVisitor ) {\n    return evaluationVisitor.execute( this );\n  }\n\n  matchYourselfToStartOfThisStringAndAddSelfToArray( symbolArray, stringToMatch, startingIndex ){\n      this._length = 0;\n      let match = this.regexOfThingsIMustMatch.exec( stringToMatch );\n      if( match != null && match.index == 0 ){\n        this._length = match[0].length;\n        // a frozen clone to record this moment,\n        // so that our data can go on to be reused without breaking things\n        let frozenToken = new Token( this.regexOfThingsIMustMatch, this.type, this._length,  match[0], this._ignore, startingIndex );\n        if( !this._ignore) symbolArray.push( frozenToken );\n        stringToMatch = stringToMatch.substring( this.length );\n      }\n      return [ this._length, symbolArray, stringToMatch ];\n  }\n\n  toString(){\n    return this.type + \"(\" + this.regexOfThingsIMustMatch.toString() + \")<\" + this._stringIMatched + \".\" + this.startingIndex + \">\";\n  }\n\n}\n\n\n\n\n// WEBPACK FOOTER //\n// ./js/token.js","\nclass BooleanJSONVisitor{\n  constructor( state ){\n    this.state = state;\n  }\n  setState( newstate ){\n    this.state = newstate;\n  }\n\n  execute( thingToEvaluate )\n  {\n        var ob = {};\n        ob.name = thingToEvaluate.type;\n        ob.value = thingToEvaluate.value = this.getBoolean( thingToEvaluate );\n        let symbolsMatched = thingToEvaluate.seriesOfSymbolsIAbsorbedAndReplaced;\n\n        switch( thingToEvaluate.type )\n        {\n            case \"TOKEN\":\n                return { name : thingToEvaluate.stringIActuallyMatched, value: this.getBoolean( thingToEvaluate ), condition: \"Condition Text Goes Here\" };\n            case \"BOOLEAN\":\n\n                ob.children = [];\n                if( symbolsMatched.length == 3 ) // there's a binary operator\n                {\n\n                  // either a binary operator or \"(\" + boolean + \")\"\n                  if( ( symbolsMatched[0].type == \"(\") && ( symbolsMatched[2].type == \")\") )\n                  {\n                    // we'll pass it through transparently\n                    // in other words, allow our middle child to represent us completely\n                    // since the user isn't interested in seeing each \"(\" represented with its own node onscreen\n                    return this.execute( symbolsMatched[ 1 ] );\n                  }\n                  else\n                  {\n                    ob.name = this.getNameForOperator( symbolsMatched[ 1 ].type );\n                    ob.children.push( this.execute( symbolsMatched[ 0 ]) );\n                    ob.children.push( this.execute( symbolsMatched[ 2 ]) );\n                  }\n                  \n                }\n                else if( symbolsMatched.length == 2 ) // there's a unary operator\n                {\n                  // the only unary operator\n                  ob.name = this.getNameForOperator( symbolsMatched[ 0 ].type ); \n                  ob.children.push( this.execute( symbolsMatched[ 1 ]) );\n                }\n                else\n                {\n                  return this.execute( symbolsMatched[ 0 ]);\n                }\n\n                break;\n\n            case \"IDENT\": // basically a passthrough. Assume our first child is a real operator, and return *its* json.\n                ob.name = thingToEvaluate._stringIMatched;\n        }\n        return ob;\n  }\n\n  getBoolean( nonterminalOrToken ){\n\n    if(nonterminalOrToken.constructor.name == \"Nonterminal\" )\n    {\n        let symbolsMatched = nonterminalOrToken.seriesOfSymbolsIAbsorbedAndReplaced;\n        let value = \"FOO\"; // declare this and, hey, initialize it with something we'll notice if there's an error.\n        if( symbolsMatched.length == 1 ) // we're a nonterminal that absorbed one other thing\n        {\n          value = this.getBoolean( symbolsMatched[0] );\n          return value;\n        }\n        else if( symbolsMatched.length == 3 )// we're a boolean comprising an operator and two operands\n        {\n          if( symbolsMatched[1].type == \"|\")\n          {\n            return this.getBoolean( symbolsMatched[0] ) || this.getBoolean( symbolsMatched[2] );\n          }\n          else if( symbolsMatched[1].type == \"&\")\n          {\n            return this.getBoolean( symbolsMatched[0] ) && this.getBoolean( symbolsMatched[2] );\n          }\n          else if( ( symbolsMatched[0].type == \"(\") && ( symbolsMatched[2].type == \")\") )\n          {\n            return this.getBoolean( symbolsMatched[1] );\n          }\n          else\n          {\n            throw new Error(\"DON'T KNOW WHAT THE OPERATOR OF THIS 3-ELEMENT SYMBOLSMATCHED IS:\" + JSON.stringify( symbolsMatched ));\n          }\n        }\n        else if( symbolsMatched.length == 2 )// we're a boolean with one operator -- probably a not\n        {\n          if( symbolsMatched[0].type == \"!\")\n          {\n            return ! this.getBoolean( symbolsMatched[1] );\n          }\n          else\n          {\n            throw new Error(\"DON'T KNOW WHAT THE OPERATOR OF THIS 2-ELEMENT SYMBOLSMATCHED IS:\" + JSON.stringify( symbolsMatched ));\n          }\n        }\n\n        throw new Error(\"UNKNOWN LENGTH OF SYMBOLSMATCHED:\" + JSON.stringify( symbolsMatched ));\n      }\n      else // it's a token\n      {\n        if( nonterminalOrToken.type.toUpperCase().indexOf( \"TRUE\" ) > -1 )\n        {\n          return true;\n        }\n        if( nonterminalOrToken.type.toUpperCase().indexOf( \"FALSE\" ) > -1 )\n        {\n          return false;\n        }\n        if( nonterminalOrToken.type.toUpperCase().indexOf( \"IDENT\" ) > -1 )\n        {\n          return this.state[ nonterminalOrToken._stringIMatched ];\n        }\n\n        throw new Error(\"nonterminalOrToken.type is \" + nonterminalOrToken.type );\n        return null;\n      }\n  }\n\n  getNameForOperator( operatorSymbol ){\n    if( operatorSymbol == \"|\" ) return \"OR\";\n    if( operatorSymbol == \"&\" ) return \"AND\";\n    if( operatorSymbol == \"^\" ) return \"XOR\";\n    if( operatorSymbol == \"!\" ) return \"NOT\";\n  }\n}\n\nmodule.exports = BooleanJSONVisitor;\n\n\n// WEBPACK FOOTER //\n// ./js/visitors/booleanjsonvisitor.js","//import Token from './token';\n//import Symbol from './token';\nimport Lexer from './lexer';\nimport Parser from './parser';\nimport XMLParseTimeVisitor from './visitors/xmlparsetimevisitor';\nimport XMLJSONVisitor from './visitors/xmljsonvisitor';\nimport TokenFactory from './factories/tokenfactory';\nimport NonterminalFactory from './factories/nonterminalfactory';\n\nexport default class XMLius{\n  constructor(){\n    let grammarObject = [\n        [  [\"OPENCOMMENT\", \"WILDCARD\", \"CLOSECOMMENT\" ], \"COMMENT\" ],\n        [  [\"<\", \"/\", \"IDENT\", \">\" ], \"CLOSETAG\" ],\n        [  [\"<\", \"IDENT\", \">\" ], \"OPENTAG\" ],\n        [  [\"<\", \"IDENT\", \"/\", \">\" ], \"XMLNODE\" ],\n        [  [\"<\", \"IDENT\", \"IDENT\", \"=\", \"\\\"\", \"WILDCARD\", \"\\\"\" ], \"OPENTAGSTART\" ],\n        /* Some recursive self-nesting here */\n        [  [\"OPENTAGSTART\", \"IDENT\", \"=\", \"\\\"\", \"WILDCARD\", \"\\\"\" ], \"OPENTAGSTART\" ],\n        [  [\"OPENTAGSTART\", \">\"], \"OPENTAG\" ],\n        [  [\"OPENTAG\", \"CLOSETAG\" ], \"XMLNODE\" ],\n        [  [\"OPENTAG\", \"WILDCARD\", \"CLOSETAG\" ], \"XMLNODE\" ]\n      ];\n\n  let IGNORE = true;\n\n      let tokenDefinitions = [\n        [  /\\s+/, \"\", IGNORE ],\n        [  /<!--/, 'OPENCOMMENT' ],\n        [  /-->/, 'CLOSECOMMENT' ],\n        [  /\\//, \"/\" ],\n        [  />/, \">\" ],\n        [  /</, \"<\" ],\n        [  /=/, \"=\" ],\n        [  /\"/, '\"' ],\n        [  /'/, '\"' ],\n        [  /[-+]?[0-9]*\\.?[0-9]+/, \"NUM_LIT\" ],\n        [  /[a-zA-Z]+/, \"IDENT\" ],\n        [ /[^<]+/, \"DIRTYTEXT\"]\n      ];\n\n\n    // we set the state so that the parser knows the data type of each of these variables\n    // (in this case, boolean)\n    // and later so that the visitor can evaluate each node to determine if it is true or false.\n    this.state = {\"a\":false,\"b\":true,\"c\":false,\"d\":true,\"e\":false,\"f\":true,\"g\":false,\"h\":true,\"i\":false};\n\n    this.xmlParseTimeVisitor = new XMLParseTimeVisitor();\n\n    this.visitor = new XMLJSONVisitor(  this.state );\n    // lay the groundwork for lexical analysis\n    this.lexer = new Lexer( tokenDefinitions );\n    this.parser = new Parser( grammarObject );\n    this.parser.setState( this.state );\n  }\n\n  parse( sentenceToParse ){\n    try\n    {\n      let sentenceOfTokens = this.lexer.tokenize( sentenceToParse );\n      this.parseTree = this.parser.parse( sentenceOfTokens, this.xmlParseTimeVisitor );\n      return this.evaluateParseTree();\n    }\n    catch( e )\n    {\n      console.error( \"ERROR PARSING OR EVALUATING:\" + e );\n    }\n  }\n\n  evaluateParseTree(){\n    let result = this.parseTree[0].visit( this.visitor );\n    return result;\n  }\n}\n\n\nwindow.XMLius = XMLius;\n\n\n\n// WEBPACK FOOTER //\n// ./js/xmlius.js","import Token from '../token';\n\nclass XMLJSONVisitor{\n  constructor( state ){\n    this.state = state;\n  }\n  setState( newstate ){\n    this.state = newstate;\n  }\n\n  execute( thingToEvaluate )\n  {\n        var ob = {};\n        ob.name = thingToEvaluate.type;\n        ob.value = this.getValue( thingToEvaluate );\n        let symbolsMatched = thingToEvaluate.symbolsMatched;\n\n        switch( thingToEvaluate.type )\n        {\n\n            case \"TOKEN\":\n                return { name : thingToEvaluate.stringIActuallyMatched, value: this.getValue( thingToEvaluate ), condition: \"Condition Text Goes Here\" };\n            case \"XMLNODE\":\n\n                ob.children = [];\n                // opentag is first item, and that gives us our name\n                ob.name = this.getValue( symbolsMatched[ 0 ] );\n                var optionalAttributes = this.getAttributes( symbolsMatched[ 0 ] );\n\n                if( optionalAttributes )\n                {\n                  ob.attributes = optionalAttributes;\n                }\n\n                symbolsMatched = this.consolidateChildrenThatAreTokens( symbolsMatched );\n\n                for( var i = 1; i < symbolsMatched.length - 1; i++ ) // -1, because the last match will be a closetag, which is irrelevant\n                {\n                  ob.children.push( this.execute( symbolsMatched[ i ]) );\n                }\n\n\n                break;\n\n            case \"IDENT\": // basically a passthrough. Assume our first child is a real operator, and return *its* json.\n                ob.name = thingToEvaluate._stringIMatched;\n        }\n        return ob;\n  }\n\n  // good for the wildcard globbing we do inside open and close tags\n  consolidateChildrenThatAreTokens( arrayOfSymbolsThatMightBeTokens ) {\n    let symbolChildrenOnly = [];\n    let runningStringOfTokenText = \"\";\n    for( var symbol of arrayOfSymbolsThatMightBeTokens ){\n      if( symbol.constructor.name != \"Token\" )\n      {\n        if( runningStringOfTokenText.length > 0 ) // we've been building up a text string!\n        {\n          let tokenConsolidatingStrings = this.makeTokenWrappingString( runningStringOfTokenText );\n          symbolChildrenOnly.push( tokenConsolidatingStrings );\n          runningStringOfTokenText = \"\";\n          symbolChildrenOnly.push( symbol );\n        }\n        else\n        {\n          symbolChildrenOnly.push( symbol );\n        }\n      }\n      else // it's a token!\n      {\n\n         runningStringOfTokenText += symbol._stringIMatched;\n\n      }\n    }\n\n    if( runningStringOfTokenText.length > 0 )\n    {\n      let tokenConsolidatingStrings = this.makeTokenWrappingString( runningStringOfTokenText );\n      symbolChildrenOnly.push( tokenConsolidatingStrings );\n    }\n\n    return symbolChildrenOnly;\n  }\n\n  makeTokenWrappingString( stringToWrap ){\n    let newSymbol = new Token( /.+/, \"TEXTNODE\", stringToWrap.length, stringToWrap );\n    return newSymbol;\n  }\n\n  // sent either an opentag or an opentagstart\n  getAttributes( childOfXMLNode ) {\n\n    if( childOfXMLNode.type == \"OPENTAGSTART\" )\n    {\n      // could be nested\n      // or could just be <, IDENT, IDENT, =, ', WILDCARD, '\n      let atts = {};\n      if( childOfXMLNode.symbolsMatched[0].constructor.name == \"Token\" ) // could only be \"<\"\n      {\n        let name = this.getValue( childOfXMLNode.symbolsMatched[2] );\n        let val = this.getValue( childOfXMLNode.symbolsMatched[5] );\n        atts[ name ] = val;\n        return atts;\n      }\n      else if(childOfXMLNode.symbolsMatched[0].type == \"OPENTAGSTART\")\n      {\n        atts = this.getAttributes( childOfXMLNode.symbolsMatched[0] );\n        let name = this.getValue( childOfXMLNode.symbolsMatched[1] );\n        let val = this.getValue( childOfXMLNode.symbolsMatched[4] );\n        atts[ name ] = val;\n        return atts;\n      }\n    }\n    else if(childOfXMLNode.symbolsMatched[0].type == \"OPENTAGSTART\")\n    {\n      let returnAtts = this.getAttributes( childOfXMLNode.symbolsMatched[0] );\n      return returnAtts;\n    }\n    return null;\n  }\n\n  getValue( nonterminalOrToken ){\n\n    if(nonterminalOrToken.constructor.name == \"Nonterminal\" )\n    {\n        let symbolsMatched = nonterminalOrToken.symbolsMatched;\n\n        let value = \"FOO\"; // declare this and, hey, initialize it with something we'll notice if there's an error.\n\n        if( nonterminalOrToken.type == \"XMLNODE\")\n        {\n          // our first child will be our opentag, which is where our name comes from.\n          let returnVal = this.getValue( symbolsMatched[0] );\n          return returnVal;\n        }\n\n        if( nonterminalOrToken.type == \"OPENTAG\" || nonterminalOrToken.type == \"OPENTAGSTART\")\n        {\n          var returnVal;\n          // symbolsMatched[1] will either be an IDENT or an OPENTAGSTART (the wrapper for attribute definitions)\n          if( symbolsMatched[0].type == \"OPENTAGSTART\" )\n          {\n            returnVal = this.getValue( symbolsMatched[0] );\n            return returnVal;\n          }\n          returnVal = this.getValue( symbolsMatched[1] );\n          return returnVal;\n        }\n\n        if( nonterminalOrToken.type == \"CLOSETAG\")\n        {\n            return this.getValue( symbolsMatched[2] ); // after < and /\n        }\n\n        if( nonterminalOrToken.type == \"COMMENT\")\n        {\n          console.error(\"COMMENT is \" + nonterminalOrToken.toString() );\n          let commentstring = \"\";\n          for(var kid of nonterminalOrToken.symbolsMatched )\n          {\n            if( kid.type == \"OPENCOMMENT\" || kid.type == \"CLOSECOMMENT\") continue;\n            commentstring += this.getValue( kid );\n          }\n            return commentstring;\n        }\n\n        throw new Error(\"XMLJSONVISITOR UNKNOWN LENGTH OF SYMBOLSMATCHED for \" + nonterminalOrToken.type + \":\" + JSON.stringify( symbolsMatched ));\n      }\n      else // it's a token\n      {\n        if( nonterminalOrToken.type.toUpperCase().indexOf( \"TRUE\" ) > -1 )\n        {\n          return true;\n        }\n        if( nonterminalOrToken.type.toUpperCase().indexOf( \"TEXTNODE\" ) > -1 )\n        {\n          return nonterminalOrToken._stringIMatched;\n        }\n        if( nonterminalOrToken.type.toUpperCase().indexOf( \"IDENT\" ) > -1 )\n        {\n          return nonterminalOrToken._stringIMatched;\n        }\n        return nonterminalOrToken._stringIMatched;\n//        throw new Error(\"nonterminalOrToken.type is \" + nonterminalOrToken.type );\n//        return null;\n      }\n  }\n}\n\nmodule.exports = XMLJSONVisitor;\n\n\n// WEBPACK FOOTER //\n// ./js/visitors/xmljsonvisitor.js","\nclass XMLParseTimeVisitor{\n  constructor( state ){\n    this.state = state;\n  }\n  setState( newstate ){\n    this.state = newstate;\n  }\n\n  execute( nonterm )\n  {\n\n    if( nonterm.type == \"XMLNODE\")\n    {\n      return this.verifyOpeningAndCloseTagsMatch( nonterm ) && this.verifyTagContentIsLegal( nonterm );\n    }\n    else if( nonterm.type == \"OPENTAG\")\n    {\n      return this.verifyAttributeContentIsLegal( nonterm );\n    }\n    else return true;\n  }\n\n  verifyOpeningAndCloseTagsMatch( thingToEvaluate ) {\n      \n      \n      let openTagName   = this.getTagName( thingToEvaluate.symbolsMatched[ 0 ] );\n       let closeTagName;\n      if( thingToEvaluate.symbolsMatched.length == 2 )\n      {\n        closeTagName = this.getTagName( thingToEvaluate.symbolsMatched[ 1 ] );\n      }\n      else if( thingToEvaluate.symbolsMatched.length > 2 )\n      {\n        closeTagName  = this.getTagName( thingToEvaluate.symbolsMatched[ thingToEvaluate.symbolsMatched.length - 1] );\n      }\n      \n      return openTagName == closeTagName;\n  }\n\n  verifyAttributeContentIsLegal( nonterm ){\n    // remember that OPENTAG can contain optional OPENTAGSTART nodes\n    // each of which can enclose other OPENTAGSTART nodes in perpetuity\n    return true;\n  }\n\n  verifyTagContentIsLegal( thingToEvaluate ){\n    return true;\n  }\n\n\n  getTagName( thingToEvaluate ){\n\n\n    while( thingToEvaluate.type != \"IDENT\" )\n    {\n      \n      if( thingToEvaluate.type == \"OPENTAG\")\n      {\n        if( thingToEvaluate.symbolsMatched)\n        {\n          if(  thingToEvaluate.symbolsMatched[0].type == \"<\")\n          {\n            \n            return thingToEvaluate.symbolsMatched[1]._stringIMatched;\n          }\n        }\n      }\n      else if( thingToEvaluate.type == \"CLOSETAG\")\n      {\n        \n        if( thingToEvaluate.symbolsMatched)\n        {\n          if(  thingToEvaluate.symbolsMatched[0].type == \"<\")\n          {\n            // element [1] will be \"/\" so we'll skip to [2]\n            \n            return thingToEvaluate.symbolsMatched[2]._stringIMatched;\n          }\n        }\n      }\n      else if( thingToEvaluate.type == \"OPENTAGSTART\")\n      {\n        \n        if( thingToEvaluate.symbolsMatched)\n        {\n          if(  thingToEvaluate.symbolsMatched[0].type == \"<\")\n          {\n            return thingToEvaluate.symbolsMatched[1]._stringIMatched;\n          }\n        }\n      }\n      thingToEvaluate = thingToEvaluate.symbolsMatched[0]\n    }\n    return thingToEvaluate._stringIMatched;\n    }\n}\n\n\n\nmodule.exports = XMLParseTimeVisitor;\n\n\n// WEBPACK FOOTER //\n// ./js/visitors/xmlparsetimevisitor.js","//import Token from './token';\n//import Symbol from './token';\nimport Lexer from './lexer';\nimport Parser from './parser';\nimport XMLius from './xmlius';\nimport BooleanJSONVisitor from './visitors/booleanjsonvisitor';\nimport TokenFactory from './factories/tokenfactory';\nimport NonterminalFactory from './factories/nonterminalfactory';\n\nexport default class Boolius{\n  constructor(){\n    let grammarObject = [\n      [  [\"TRUE\" ], \"BOOLEAN\" ],\n      [  [\"FALSE\" ], \"BOOLEAN\" ],\n      [  [\"!\", \"BOOLEAN\" ], \"BOOLEAN\" ],\n      [  [\"BOOLEAN\", \"&\", \"BOOLEAN\" ], \"BOOLEAN\" ],\n      [  [\"BOOLEAN\", \"|\", \"BOOLEAN\" ], \"BOOLEAN\" ],\n      [  [\"(\", \"BOOLEAN\", \")\" ], \"BOOLEAN\" ],\n      [  [\"NUMERIC\", \"^\", \"NUMERIC\" ], \"NUMERIC\" ],\n      [  [\"NUMERIC\", \"*\", \"NUMERIC\" ], \"NUMERIC\" ],\n      [  [\"NUMERIC\", \"+\", \"NUMERIC\" ], \"NUMERIC\", [\"*\", \"/\", \"^\"] ],\n      [  [\"NUMERIC\", \"-\", \"NUMERIC\" ], \"NUMERIC\", [\"*\", \"/\", \"^\"] ],\n      [  [\"NUM_LIT\" ], \"NUMERIC\" ],\n      [  [\"(\", \"NUMERIC\", \")\" ], \"NUMERIC\" ]\n    ];\n\n\n\n  let IGNORE = true;\n// first arg is the regex that does the matching\n// second arg is how this token will present itself to the parser.\n  let tokenDefinitions = [\n        [ /\\s+/, \"\", IGNORE ], // ignore whitespace\n        [ /&&/, \"&\" ],\n        [ /AND/i, \"&\" ],\n        [ /\\|\\|/, \"|\" ], // this is the escaped form of ||\n        [ /XOR/i, \"^\" ],\n        [ /OR/i, \"|\" ],\n        [ /\\^/, \"^\" ], // this is the escaped form of ^\n        [ /\\!/, \"!\" ], // this is the escaped form of !\n        [ /NOT/i, \"!\" ],\n        [ /\\(/, \"(\" ],\n        [ /\\)/, \")\" ],\n        [ /\\+/, \"+\" ],\n        [ /-/, \"-\" ],\n        [ /\\*/, \"*\" ],\n        [ /\\//, \"/\" ],\n        [ /(true)(?![a-zA-Z0-9])/i, \"TRUE\" ],\n        [ /(false)(?![a-zA-Z0-9])/i, \"FALSE\" ],\n        [ /[-+]?[0-9]*\\.?[0-9]+/, \"NUM_LIT\" ],\n        [ /[a-zA-Z]+/, \"IDENT\" ],\n        [ /.+/, \"DIRTYTEXT\"]\n      ];\n\n\n    // we set the state so that the parser knows the data type of each of these variables\n    // (in this case, boolean)\n    // and later so that the visitor can evaluate each node to determine if it is true or false.\n    this.state = {\"a\":false,\"b\":true,\"c\":false,\"d\":true,\"e\":false,\"f\":true,\"g\":false,\"h\":true,\"i\":false};\n    this.visitor = new BooleanJSONVisitor( this.state );\n    // lay the groundwork for lexical analysis\n    this.lexer = new Lexer( tokenDefinitions );\n    this.parser = new Parser( grammarObject );\n    this.parser.setState( this.state );\n  }\n\n  parse( sentenceToParse ){\n    try\n    {\n      let sentenceOfTokens = this.lexer.tokenize( sentenceToParse );\n      this.parseTree = this.parser.parse( sentenceOfTokens );\n      return this.evaluateParseTree();\n    }\n    catch( e )\n    {\n      alert( e );\n    }\n  }\n\n  evaluateParseTree(){\n    let result = this.parseTree[0].visit( this.visitor );\n    return result;\n  }\n}\nwindow.Boolius = Boolius;\n\n\n\n// WEBPACK FOOTER //\n// ./js/boolius.js"],"sourceRoot":""}