<html>
<head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8">
    <link type="text/css" rel="stylesheet" href="css/style.css">
    <script src="js/d3.v3.min.js" charset="utf-8"></script>
    <script type="text/javascript" src="js/d3.layout.js"></script>
</head>
<script src="build/boolius.bundle.js"></script>

<body>
    <div id="body">
      <div id="header">
	    <div class="hint">Click operators to expand or collapse. Click leaf nodes to toggle true/false.</div>
		<!--<span class="hint">Advanced Condition Logic</span>-->
        <input type="text" id="statement" value='((d && c)) || (!b && a) && (!d || !a) && (!c || !b)'></input>
        <button id="testbutton">Test</button>

      </div>
	</div>
    <script type="text/javascript">

var winHeight = Math.max( 600, window.innerHeight );
var winWidth = Math.max( 1000, window.innerWidth );
var boolius = new Boolius();
var m = [100, 120, 20, 120],
    w = winWidth - m[1] - m[3],
    h = winHeight - m[0] - m[2],
    i = 0,
    root;

var tree = d3.layout.tree()
    .size([h, w]);

var diagonal = d3.svg.diagonal()
    .projection(function(d) { return [d.y, d.x]; });

var vis = d3.select("#body").append("svg:svg")
    .attr("width", w + m[1] + m[3])
    .attr("height", h + m[0] + m[2])
  .append("svg:g")
    .attr("transform", "translate(" + m[3] + "," + m[0] + ")");

vis.append("text")
	.attr("opacity", .1)
    .attr("y", 6)
    .attr("dy", "1.71em")
    .style("text-anchor", "end")
    .attr("id", "tooltip")
    .text("");

vis.append("text")
	.attr("opacity", 1)
    .attr("y", 246)
    .attr("dy", "1.71em")
    .style("font-size","34px")
    .style("text-anchor", "end")
    .attr("id", "result")
    .text("");

evaluateStatement();

d3.select("#testbutton").on("click", function(e) {

	evaluateStatement();

});

var parseTree;

function evaluateStatement()
{
    var statement = d3.select("#statement").node().value;
	parseTree = boolius.parse( statement );
	displayJSON( parseTree );

};

function displayJSON( json )
{
  root = json;
  root.x0 = h / 2;
  root.y0 = 0;
  //d3.select("#statement").val( root.title );
  d3.select("#statement").property("value", root.expressionString);

  d3.select("#result")
  .text( root.value )

  function toggleAll(d, delay ) {

  	if( ! delay ) delay = 1;

    if (d.children) {
		toggle(d);
    }

    if (d._children) {
		toggle(d);
    }
  }
  // Initialize the display to show a few nodes.

  root.children.forEach(toggleAll, 444);
  //toggle(root.children[1]);

  update(root);
};

// Toggle children.
function toggle(d) {
	if( d == undefined ) return;
  if (d.children) {
  // hide the children by moving them into _children
    d._children = d.children;
    d.children = null;
  } else {
  // bring back the hidden children
    d.children = d._children;
    d._children = null;
  }

  if( ! d.children && !d._children) // it's a leaf
  {
	// toggle true/false

	d.value = !d.value;
	//var myInt = parseInt( d.name );
	//conditionTruthValues[ myInt ] = d.value;
    var myVar = d.name;
    boolius.state[ myVar ] = d.value;

  	updateWithoutDeleting(root);

  }
  else
  {
  	d3.select("#tooltip").style("opacity", 0 );
  	d3.select("#tooltipBG").style("opacity", 0 );
  }
}



function updateWithoutDeleting()
{

    var statement = d3.select("#statement").property("value");

	if( !statement || statement.length == 0 )
	{
		alert("You need to have a statement in the textfield for me to work with.");
	}

    parseTree = boolius.evaluateParseTree();

    updateObjectAndItsChildren( parseTree, root );

	d3.select("#result")
		.text( root.value )
}

function updateObjectAndItsChildren( newObjectTemp, rootTemp )
{

    rootTemp.value = newObjectTemp.value;
    if( ! newObjectTemp.children ) return;
    for( var i = 0; i < newObjectTemp.children.length; i++ )
    {
        if( rootTemp.children )
        {
            updateObjectAndItsChildren( newObjectTemp.children[ i ], rootTemp.children[ i ] );
        }
        else
        {
        	if( rootTemp._children )
        	{
            	updateObjectAndItsChildren( newObjectTemp.children[ i ], rootTemp._children[ i ] );
            }
        }

    }
}



function update(source) {
  var duration = d3.event && d3.event.altKey ? 5000 : 500;

  // Compute the new tree layout.
  var nodes = tree.nodes(root).reverse();



  // Normalize for fixed-depth.
  // OK -- why is d.y correlated with the horizontal position here???

  widthPerNode = 110;
  var body = d3.select("body");
  var svg = body.select("svg");
  var widthInPixels = svg.style("width").replace("px", "");
  widthInPixels = parseInt( widthInPixels );
  var widthPerNode = widthInPixels / nodes.length;
  nodes.forEach(function(d) { d.y = d.depth * widthPerNode; });

  d3.select("#result")
  .transition()
  .duration(duration)
  .attr("x", nodes[nodes.length -1 ].y - 40 )
  .attr("y", function(d){ return nodes[nodes.length -1 ].x - 48 } )

  // Update the nodes…
  var node = vis.selectAll("g.node")
      .data(nodes, function(d) { return d.id || (d.id = ++i); });

  // Enter any new nodes at the parent's previous position.
  var nodeEnter = node.enter().append("svg:g")
      .attr("class", "node")
      .attr("transform", function(d) { return "translate(" + source.y0 + "," + source.x0 + ")"; })
      .on("click", function(d) { toggle(d); update(d); });

  nodeEnter.append("svg:circle")
      .attr("r", 1e-6)
      .style("stroke", function(d){ return d.value ? "green" : "red" } )
      .style("fill", function(d) { return d._children ? "grey" : "#fff"; });

  nodeEnter.append("svg:text")
      .attr("x", function(d) { return d.children || d._children ? -1 : 17; })
      .attr("y", function(d) { return d.children || d._children ? 18 : -1; })
      .attr("dy", ".35em")
      .attr("text-anchor", "middle")
//      .attr("text-anchor", function(d) { return d.children || d._children ? "end" : "start"; })
      .text(function(d) { return d.name; })
      .style("fill-opacity", 1e-6);

  // Transition nodes to their new position.
  var nodeUpdate = node.transition()
      .duration(duration)
      .style("stroke", function(d){ return d.value ? "green" : "red";  } )
      .attr("transform", function(d) { return "translate(" + d.y + "," + d.x + ")"; });

  nodeUpdate.select("circle")
      .attr("r", 8.5)
      .style("stroke", function(d){ return d.value ? "green" : "red" } )
      .style("fill", function(d) { return d._children ? "lightsteelblue" : "#fff"; });

  nodeUpdate.select("text")
      .style("fill-opacity", 1);

  // Transition exiting nodes to the parent's new position.
  var nodeExit = node.exit().transition()
      .duration(duration)
      .attr("transform", function(d) { return "translate(" + source.y + "," + source.x + ")"; })
      .remove();

  nodeExit.select("circle")
      .attr("r", 1e-6);

  nodeExit.select("text")
      .style("fill-opacity", 1e-6);

  // Update the links…
  var link = vis.selectAll("path.link")
      .data(tree.links(nodes), function(d) { return d.target.id; });

  // Enter any new links at the parent's previous position.
  link.enter().insert("svg:path", "g")
      .attr("class", "link")
      .attr("d", function(d) {
        var o = {x: source.x0, y: source.y0};
        return diagonal({source: o, target: o});
      })
    .transition()
      .duration(duration)
      .attr("d", diagonal);

  // Transition links to their new position.
  link.transition()
      .duration(duration)
      .attr("d", diagonal);

  // Transition exiting nodes to the parent's new position.
  link.exit().transition()
      .duration(duration)
      .attr("d", function(d) {
        var o = {x: source.x, y: source.y};
        return diagonal({source: o, target: o});
      })
      .remove();

  // Stash the old positions for transition.
  nodes.forEach(function(d) {
    d.x0 = d.x;
    d.y0 = d.y;
  });
}


    </script>


</body>
</html>