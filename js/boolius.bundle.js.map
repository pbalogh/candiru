{"version":3,"sources":["webpack:///webpack/bootstrap 59d9017f3bc2b07d30af","webpack:///./js/factories/nonterminalfactory.js","webpack:///./js/factories/tokenfactory.js","webpack:///./js/lexer.js","webpack:///./js/parser.js","webpack:///./js/symbol.js","webpack:///./js/boolius.js","webpack:///./js/mathius.js","webpack:///./js/nonterminal.js","webpack:///./js/token.js","webpack:///./js/visitors/evaluationvisitor.js","webpack:///./js/visitors/numericvisitor.js","webpack:///./js/xmlius.js","webpack:///./js/visualizer.js","webpack:///./js/visitors/booleanjsonvisitor.js","webpack:///./js/visitors/booleanvisitor.js","webpack:///./js/visitors/mathjsonvisitor.js","webpack:///./js/visitors/xmljsonvisitor.js","webpack:///./js/visitors/xmlparsetimevisitor.js"],"names":["NonterminalFactory","grammarObject","nonterminals","grammarRule","nonterminal","length","lookaheadTokensToAvoid","push","TokenFactory","tokenDefinitions","tokens","tokenDefinition","makeToken","regex","name","ignore","token","IGNORE","makeTokenFromDefinition","Lexer","tokenFactory","getTokens","sentenceToTokenize","arrayOfTokens","startingLetter","stringToMatch","foundAMatchSomewhere","lengthOfMatch","matchYourselfToStartOfThisStringAndAddSelfToArray","Error","charAt","Parser","nonterminalFactory","getNonterminals","state","sentenceOfSymbols","resolvedSymbols","symbol","shift","constructor","type","_stringIMatched","nonterm","seriesOfSymbolsIAbsorbedAndReplaced","traceString","parseTimeVisitor","resolveIdentifiersToTypes","arrayOfSymbolsMatchedBeforeMe","finished","madeAMatch","getSimpleStringForSentence","slice","stringAndPosition","getLastTokenDescriptionOfSymbol","errorString","string","position","getStringAndPositionOfTokensOfSymbol","symbolsMatched","earliestPosition","start","tokenString","kid","Symbol","_name","someName","Boolius","visitor","lexer","parser","setState","sentenceToParse","sentenceOfTokens","tokenize","parseTree","parse","evaluateParseTree","e","alert","result","visit","module","exports","Mathius","console","error","Nonterminal","seriesOfSymbolsIMustMatch","wildcardMode","join","returnString","toString","evaluationVisitor","execute","sentenceOfSymbolsToMatch","sentenceOfSymbolsToMatchClone","seriesOfSymbolsIMustMatchClone","done","symbolThatBreaksWildcard","mySymbol","theirSymbol","getFrozenClone","theirNextSymbol","indexOf","frozenClone","Token","regexOfThingsIMustMatch","leng","stringIActuallyMatched","startIndex","_type","_length","_ignore","symbolArray","startingIndex","match","exec","index","frozenToken","substring","EvaluationVisitor","booleanVisitor","numericVisitor","newstate","nonterminalOrToken","toUpperCase","NumericVisitor","value","Math","pow","JSON","stringify","parseInt","XMLius","xmlParseTimeVisitor","window","onload","d3","select","on","selectedMode","node","toLowerCase","changeMode","newMode","evaluator","makeEvaluatorAndInitialize","newEvaluator","statement","hintText","assignEvaluator","text","evaluateStatement","winHeight","max","innerHeight","winWidth","innerWidth","m","w","h","i","root","tree","layout","size","diagonal","svg","projection","d","y","x","vis","append","attr","style","event","keyCode","displayJSON","json","x0","y0","property","expressionString","toggleAll","delay","children","toggle","_children","forEach","update","showOverlay","undefined","hasNoChildren","myVar","updateWithoutDeleting","attributeText","attributes","showValueOverlay","val","$","html","modal","updateObjectAndItsChildren","newObjectTemp","rootTemp","source","duration","altKey","nodes","reverse","widthPerNode","body","widthInPixels","replace","depth","transition","selectAll","data","id","nodeEnter","enter","nodeUpdate","nodeExit","exit","remove","link","links","target","insert","o","BooleanJSONVisitor","thingToEvaluate","ob","getBoolean","condition","getNameForOperator","operatorSymbol","BooleanVisitor","MathJSONVisitor","getValue","XMLJSONVisitor","trim","executedSymbol","parentnode","optionalAttributes","getAttributes","consolidateChildrenThatAreTokens","child","Array","isArray","concat","arrayOfSymbolsThatMightBeTokens","symbolChildrenOnly","runningStringOfTokenText","tokenConsolidatingStrings","makeTokenWrappingString","stringToWrap","newSymbol","childOfXMLNode","atts","valueForName","attributeValueIndex","notLast","returnAtts","returnVal","commentstring","contentstring","XMLParseTimeVisitor","verifyOpeningAndCloseTagsMatch","verifyTagContentIsLegal","verifyAttributeContentIsLegal","openTagName","getTagName","closeTagName"],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA,mDAA2C,cAAc;;AAEzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;AAEA;AACA;;;;;;;;;;;;;;;;AChEA;;;;;;;;IAEqBA,kB;AACnB,8BAAYC,aAAZ,EAA0B;AAAA;;AACxB,SAAKA,aAAL,GAAqBA,aAArB;AACA,SAAKC,YAAL,GAAoB,EAApB;AAFwB;AAAA;AAAA;;AAAA;AAGxB,2BAAwBD,aAAxB,8HACA;AAAA,YADSE,WACT;;AACE,YAAIC,cAAc,0BAAiBD,YAAY,CAAZ,CAAjB,EAAiCA,YAAY,CAAZ,CAAjC,CAAlB;AACA,YAAIA,YAAYE,MAAZ,GAAqB,CAAzB,EAA6B;AAC7B;AACED,wBAAYE,sBAAZ,GAAqCH,YAAY,CAAZ,CAArC;AACD;AACD,aAAKD,YAAL,CAAkBK,IAAlB,CAAwBH,WAAxB;AACD;AAXuB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAYzB;;;;sCAEgB;AACf,aAAO,KAAKF,YAAZ;AACD;;;;;;kBAjBkBF,kB;;;;;;;;;;;;;;;ACFrB;;;;;;;;IAEqBQ,Y;AAClB,wBAAaC,gBAAb,EAA+B;AAAA;;AAC7B,SAAKC,MAAL,GAAc,EAAd;AACA,SAAKD,gBAAL,GAAwBA,gBAAxB;AACD;;;;4CAEwBE,e,EAAiB;AACxC,aAAO,KAAKC,SAAL,CAAgBD,gBAAgB,CAAhB,CAAhB,EAAoCA,gBAAgB,CAAhB,CAApC,EAAwDA,gBAAgBN,MAAhB,GAAyB,CAAzB,GAA6BM,gBAAgB,CAAhB,CAA7B,GAAkD,KAA1G,CAAP;AACD;;;8BACWE,K,EAAOC,I,EAClB;AAAA,UADwBC,MACxB,uEADiC,KACjC;;AACE,UAAIC,QAAQ,oBAAWH,KAAX,EAAkBC,IAAlB,EAAwB,CAAxB,EAA2B,EAA3B,EAA+BC,MAA/B,CAAZ;AACA,WAAKL,MAAL,CAAYH,IAAZ,CAAkBS,KAAlB;AACA,aAAOA,KAAP;AACD;;;gCAGD;AACE,UAAIC,SAAS,IAAb;;AADF;AAAA;AAAA;;AAAA;AAGE,6BAA4B,KAAKR,gBAAjC,8HACA;AAAA,cADSE,eACT;;AACE,eAAKO,uBAAL,CAA8BP,eAA9B;AACD;AANH;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAOE,aAAO,KAAKD,MAAZ;AAED;;;;;;kBA1BgBF,Y;;;;;;;;;;;;;;;;;ACFrB;;;;;;;;IAEqBW,K;AAEnB,iBAAaV,gBAAb,EAA+B;AAAA;;AAC7B,QAAIW,eAAe,2BAAkBX,gBAAlB,CAAnB;AACA,SAAKC,MAAL,GAAcU,aAAaC,SAAb,EAAd;AACD;;;;6BAESC,kB,EAAoB;AAC5B,UAAIC,gBAAgB,EAApB;AACA,UAAIC,iBAAiB,CAArB;AACA,UAAIC,gBAAgBH,kBAApB,CAH4B,CAGY;;AAExC,aAAQE,iBAAiBF,mBAAmBjB,MAA5C,EACA;AACE,YAAIqB,uBAAuB,KAA3B;AADF;AAAA;AAAA;;AAAA;AAEE,+BAAkB,KAAKhB,MAAvB,8HACA;AAAA,gBADSM,KACT;;AACE,gBAAIW,gBAAgB,CAApB;;AADF,wCAGEX,MAAMY,iDAAN,CAAyDL,aAAzD,EAAwEE,aAAxE,EAAuFD,cAAvF,CAHF;;AAAA;;AAEGG,yBAFH;AAEkBJ,yBAFlB;AAEiCE,yBAFjC;;AAIE,gBAAIE,gBAAgB,CAApB,EACA;AACED,qCAAuB,IAAvB;AACAF,gCAAkBG,aAAlB;AACA,oBAHF,CAGS;AACP;AACA;AACD;AACF;AAfH;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAgBE,YAAG,CAAED,oBAAL,EACA;AACE,gBAAM,IAAIG,KAAJ,CAAU,uBAAuBJ,cAAcK,MAAd,CAAqB,CAArB,CAAvB,GAAiD,eAAjD,GAAmEN,cAA7E,CAAN;AACD;AACF;AACD,aAAOD,aAAP;AACD;;;;;;kBAnCkBJ,K;;;;;;;;;;;;;;;;;ACFrB;;;;AACA;;;;AACA;;;;;;;;IAEqBY,M;AACnB,kBAAa9B,aAAb,EAA4B;AAAA;;AAC1B,QAAI+B,qBAAqB,iCAAwB/B,aAAxB,CAAzB;AACA,SAAKC,YAAL,GAAoB8B,mBAAmBC,eAAnB,EAApB;AACA,SAAKC,KAAL,GAAa,EAAb;AACD;;;;6BAESA,K,EAAQ;AAChB,WAAKA,KAAL,GAAaA,KAAb,CADgB,CACI;AACrB;;AAED;AACA;AACA;;;;8CAC2BC,iB,EAAmB;AAC5C,UAAIC,kBAAkB,EAAtB;AACA,aAAOD,kBAAkB9B,MAAlB,GAA2B,CAAlC,EACA;AACE;AACA;AACA,YAAIgC,SAASF,kBAAkBG,KAAlB,EAAb;AACA;AACA,YAAID,OAAOE,WAAP,CAAmBzB,IAAnB,IAA2B,OAA/B,EACA;AACE,cAAIuB,OAAOG,IAAP,IAAe,OAAnB,EACA;AACE;AACA,gBAAI,OAAO,KAAKN,KAAL,CAAWG,OAAOI,eAAlB,CAAP,IAA6C,SAAjD,EACA;AACE,kBAAIC,UAAU,0BAAiB,CAAC,OAAD,CAAjB,EAA4B,SAA5B,CAAd;AACAA,sBAAQC,mCAAR,GAA8C,CAAEN,MAAF,CAA9C;AACAA,uBAASK,OAAT;AACD;AACDN,4BAAgB7B,IAAhB,CAAsB8B,MAAtB;AACA;AACD,WAXD,MAaA;AACED,4BAAgB7B,IAAhB,CAAsB8B,MAAtB;AACD;AACF,SAlBD,MAoBA;AACED,0BAAgB7B,IAAhB,CAAsB8B,MAAtB;AACD;AACF;AACD,aAAOD,eAAP;AACD;;;+CAE2BD,iB,EAAoB;AACxC,UAAIS,cAAc,EAAlB;AADwC;AAAA;AAAA;;AAAA;AAExC,6BAAmBT,iBAAnB,8HACA;AAAA,cADSE,MACT;;AACEO,yBAAeP,OAAOG,IAAP,GAAc,GAA7B;AACD;AALuC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAMxC,aAAOI,WAAP;AACP;;;0BAEMT,iB,EAA4C;AAAA,UAAzBU,gBAAyB,uEAAN,IAAM;;;AAEjDV,0BAAoB,KAAKW,yBAAL,CAAgCX,iBAAhC,CAApB;AACA,UAAIY,gCAAgC,EAApC;AACA,UAAIpB,gBAAgB,CAApB;AACA,UAAIqB,WAAW,KAAf;AACA;AACA,UAAKb,kBAAkB9B,MAAlB,IAA4B,CAAjC,EAAqC2C,WAAW,IAAX;AACrC,aAAO,CAACA,QAAR,EAAkB;AACd,YAAIC,aAAa,KAAjB;AACA;AAFc;AAAA;AAAA;;AAAA;AAGd,gCAAwB,KAAK/C,YAA7B,mIACA;AAAA,gBADSE,WACT;;;AAEE;AACA;AACA;AACA;AACA;AACA;AACA,gBAAIwC,cAAc,KAAKM,0BAAL,CAAiCf,iBAAjC,CAAlB;AACA,mBAAOA,kBAAkB9B,MAAlB,GAA2B,CAAlC,EACA;;AAKE;AACA;AACA;AACA;AARF,0CAGED,YAAYwB,iDAAZ,CAA+DmB,6BAA/D,EAA8FZ,iBAA9F,EAAiHU,gBAAjH,CAHF;AACV;;;AADU;;AAEGlB,2BAFH;AAEkBoB,2CAFlB;AAEiDZ,+BAFjD;AASE,kBAAIR,iBAAiB,CAArB,EACA;AACEoB,8CAA8BxC,IAA9B,CAAoC4B,kBAAkBG,KAAlB,EAApC;AACAM,8BAAc,KAAKM,0BAAL,CAAiCf,iBAAjC,CAAd;AACD,eAJD,MAMA;AACE;AACAc,6BAAa,IAAb;AACD;AACF;;AAED;AACAd,gCAAoBY,8BAA8BI,KAA9B,CAAoC,CAApC,CAApB,CAhCF,CAgC8D;AAC5DJ,4CAAgC,EAAhC;AACA;AACA;AACA,gBAAIZ,kBAAkB9B,MAAlB,IAA4B,CAAhC,EACA;AACE2C,0BAAY,IAAZ;AACA;AACD;;AAED;AACA;AACA,gBAAIC,UAAJ,EAAiB;AAElB,WAlDa,CAkDZ;;AAEF;AACA;AArDc;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAsDd,YAAI,CAAEA,UAAN,EACA;AACE,cAAIG,oBAAoB,KAAKC,+BAAL,CAAsClB,kBAAkB,CAAlB,CAAtC,CAAxB;AACA,cAAImB,cAAc,oBAAoBF,kBAAkBG,MAAtC,GAA+C,eAA/C,GAAiEH,kBAAkBI,QAArG;AACA,gBAAM,IAAI3B,KAAJ,CAAWyB,WAAX,CAAN;AACAN,qBAAW,IAAX;AACD;;AAED,YAAIb,kBAAkB9B,MAAlB,IAA4B,CAAhC,EACA;AACE2C,qBAAW,IAAX;AACD;AACJ,OA1EgD,CA0E9C;;AAEH,aAAOb,iBAAP;AACD;;;oDAEgCE,M,EAAQ;AACtC,aAAO,KAAKoB,oCAAL,CAA2CpB,OAAOqB,cAAP,CAAuBrB,OAAOqB,cAAP,CAAsBrD,MAAtB,GAA+B,CAAtD,CAA3C,CAAP;AACF;;;yDAEqCgC,M,EAAsC;AAAA,UAA9BsB,gBAA8B,uEAAX,SAAW;;AAC1E,UAAItB,OAAOE,WAAP,CAAmBzB,IAAnB,IAA2B,OAA/B,EACA;AACE,eAAO,EAAEyC,QAAQlB,OAAOI,eAAjB,EAAkCe,UAAUnB,OAAOuB,KAAnD,EAAP;AACD,OAHD,MAIK,IAAIvB,OAAOE,WAAP,CAAmBzB,IAAnB,IAA2B,aAA/B,EACL;AACE,YAAI+C,cAAc,EAAlB;AADF;AAAA;AAAA;;AAAA;AAEE,gCAAgBxB,OAAOqB,cAAvB,mIACA;AAAA,gBADSI,GACT;;AACE,gBAAIV,oBAAoB,KAAKK,oCAAL,CAA2CK,GAA3C,EAAgDH,gBAAhD,CAAxB;AACAE,2BAAeT,kBAAkBG,MAAjC;AACA,gBAAIH,kBAAkBI,QAAlB,GAA6BG,gBAAjC,EACA;AACEA,iCAAmBP,kBAAkBI,QAArC;AACD;AACF;AAVH;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAWE,eAAO,EAAED,QAAQM,WAAV,EAAuBL,UAAUG,gBAAjC,EAAP;AACD;AACF;;;;;;kBAhKkB5B,M;;;;;;;;;;;;;;;;;ICJAgC,O;AACnB,qBAAa;AAAA;AAEZ;;;;wBACS;AACR,aAAO,KAAKC,KAAZ;AACD,K;sBACSC,Q,EAAU;AAClB,WAAKD,KAAL,GAAaC,QAAb;AACD;;;;;;;;;;;;;;;;;;;;qjBCTH;AACA;;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;;;;;IAEaC,O,WAAAA,O;AAEX,mBAAazD,gBAAb,EAA+BR,aAA/B,EAA8C;AAAA;;AAE5C;AACA;AACA;AACA,SAAKiC,KAAL,GAAa,EAAC,KAAI,KAAL,EAAW,KAAI,IAAf,EAAoB,KAAI,KAAxB,EAA8B,KAAI,IAAlC,EAAuC,KAAI,KAA3C,EAAiD,KAAI,IAArD,EAA0D,KAAI,KAA9D,EAAoE,KAAI,IAAxE,EAA6E,KAAI,KAAjF,EAAb;AACA,SAAKiC,OAAL,GAAe,iCAAwB,KAAKjC,KAA7B,CAAf;AACA;AACA,SAAKkC,KAAL,GAAa,oBAAW3D,gBAAX,CAAb;AACA,SAAK4D,MAAL,GAAc,qBAAYpE,aAAZ,CAAd;AACA,SAAKoE,MAAL,CAAYC,QAAZ,CAAsB,KAAKpC,KAA3B;AACD;;;;0BAEMqC,e,EAAiB;AACtB,UACA;AACE,YAAIC,mBAAmB,KAAKJ,KAAL,CAAWK,QAAX,CAAqBF,eAArB,CAAvB;AACA,aAAKG,SAAL,GAAiB,KAAKL,MAAL,CAAYM,KAAZ,CAAmBH,gBAAnB,CAAjB;AACA,eAAO,KAAKI,iBAAL,EAAP;AACD,OALD,CAMA,OAAOC,CAAP,EACA;AACEC,cAAOD,CAAP;AACD;AACF;;;wCAEkB;AACjB,UAAIE,SAAS,KAAKL,SAAL,CAAe,CAAf,EAAkBM,KAAlB,CAAyB,KAAKb,OAA9B,CAAb;AACA,aAAOY,MAAP;AACD;;;;;AAEH;;;AACAE,OAAOC,OAAP,GAAiBhB,OAAjB,C;;;;;;;;;;;;;qjBC5CA;AACA;;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;;;;;IAEqBiB,O;AACnB,mBAAa1E,gBAAb,EAA+BR,aAA/B,EAA8C;AAAA;;AAE5C;AACA;AACA;AACA,SAAKiC,KAAL,GAAa,EAAC,KAAI,KAAL,EAAW,KAAI,IAAf,EAAoB,KAAI,KAAxB,EAA8B,KAAI,IAAlC,EAAuC,KAAI,KAA3C,EAAiD,KAAI,IAArD,EAA0D,KAAI,KAA9D,EAAoE,KAAI,IAAxE,EAA6E,KAAI,KAAjF,EAAb;;AAEA,SAAKiC,OAAL,GAAe,8BAAsB,KAAKjC,KAA3B,CAAf;AACA;AACA,SAAKkC,KAAL,GAAa,oBAAW3D,gBAAX,CAAb;AACA,SAAK4D,MAAL,GAAc,qBAAYpE,aAAZ,CAAd;AACA,SAAKoE,MAAL,CAAYC,QAAZ,CAAsB,KAAKpC,KAA3B;AACD;;;;0BAIMqC,e,EAAiB;AACtB,UACA;AACE,YAAIC,mBAAmB,KAAKJ,KAAL,CAAWK,QAAX,CAAqBF,eAArB,CAAvB;AACA,aAAKG,SAAL,GAAiB,KAAKL,MAAL,CAAYM,KAAZ,CAAmBH,gBAAnB,CAAjB;AACA,eAAO,KAAKI,iBAAL,EAAP;AACD,OALD,CAMA,OAAOC,CAAP,EACA;AACEO,gBAAQC,KAAR,CAAe,iCAAiCR,CAAhD;AACD;AACF;;;wCAEkB;AACjB,UAAIE,SAAS,KAAKL,SAAL,CAAe,CAAf,EAAkBM,KAAlB,CAAyB,KAAKb,OAA9B,CAAb;AACA,aAAOY,MAAP;AACD;;;;;;kBAjCkBI,O;;;;;;;;;;;;;;;ACTrB;;;;;;;;;;;;IAEqBG,W;;;AAEjB,uBAAaC,yBAAb,EAAwC/C,IAAxC,EAA8C;AAAA;;AAAA;;AAE5C,UAAK+C,yBAAL,GAAkCA,yBAAlC;AACA,UAAK/C,IAAL,GAAkCA,IAAlC;AACA,UAAKG,mCAAL,GAA2C,EAA3C;AACA,UAAK6C,YAAL,GAAoB,KAApB;AACA,UAAKlF,sBAAL,GAA8B,IAA9B;AAN4C;AAO7C;;;;qCAEe;AACd,aAAO,KAAKkC,IAAL,GAAY,GAAZ,GAAkB,KAAK+C,yBAAL,CAA+BE,IAA/B,CAAqC,GAArC,CAAlB,GAA+D,GAAtE;AACD;;;+BAES;AACR,UAAIC,eAAe,KAAKlD,IAAL,GAAY,IAA/B;;AADQ;AAAA;AAAA;;AAAA;AAGR,6BAAmB,KAAKG,mCAAxB,8HACA;AAAA,cADSN,MACT;;AACEqD,0BAAgB,MAAMrD,OAAOsD,QAAP,EAAtB;AACD;AANO;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAOR,aAAOD,YAAP;AACD;;;0BAUME,iB,EAAoB;AACzB,aAAOA,kBAAkBC,OAAlB,CAA2B,IAA3B,CAAP;AACD;;;sEAEkD9C,6B,EAA+B+C,wB,EAA0BjD,gB,EAAkB;;AAE5H;;AAEA,UAAIkD,gCAAgCD,yBAAyB3C,KAAzB,CAA+B,CAA/B,CAApC;;AAEA;;AAEA,UAAI6C,iCAAiC,KAAKT,yBAAL,CAA+BpC,KAA/B,CAAqC,CAArC,CAArC;;AAEA,WAAKR,mCAAL,GAA2C,EAA3C;;AAEA,UAAIsD,OAAO,KAAX;;AAEA;;AAEA,UAAIC,2BAA2B,IAA/B;;AAEA,aAAOF,+BAA+B3F,MAA/B,GAAwC,CAA/C,EACA;AACE,YAAI8F,WAAWH,+BAA+B1D,KAA/B,EAAf;AACA,YAAI8D,cAAcL,8BAA8BzD,KAA9B,EAAlB;;AAEA;AACA,YAAI,CAAE8D,WAAN,EACA;AACI,eAAKzD,mCAAL,GAA2C,EAA3C;AACA,iBAAO,CAAE,CAAF,EAAKI,6BAAL,EAAoC+C,wBAApC,CAAP;AACH;;AAID,YAAIK,YAAY,UAAhB,EACA;AACE,eAAKX,YAAL,GAAoB,IAApB;AACAU,qCAA2BF,+BAA+B1D,KAA/B,EAA3B;AACA,iBAAO8D,YAAY5D,IAAZ,IAAoB0D,wBAA3B,EACA;AACE,iBAAKvD,mCAAL,CAAyCpC,IAAzC,CAA+C6F,WAA/C;;AAEA,gBAAIL,8BAA8B1F,MAA9B,IAAwC,CAA5C,EAAgD;AAChD;AACE,oBAAI2F,+BAA+B3F,MAA/B,IAAyC,CAA7C,EAAiD;AACjD;AACE0C,kDAA8BxC,IAA9B,CAAoC,KAAK8F,cAAL,EAApC;AACA,2BAAO,CAAE,KAAKhG,MAAP,EAAe0C,6BAAf,EAA8CgD,6BAA9C,CAAP;AACD,mBAJD,MAKK;AACL;AACE,yBAAKpD,mCAAL,GAA2C,EAA3C;AACA,2BAAO,CAAE,CAAF,EAAKI,6BAAL,EAAoC+C,wBAApC,CAAP;AACD;AACF,eAZD,MAcA;AACEM,4BAAcL,8BAA8BzD,KAA9B,EAAd;AAED;AACF,WAzBH,CAyBI;;AAEF;AACA;;AAEA,eAAKK,mCAAL,CAAyCpC,IAAzC,CAA+C6F,WAA/C;;AAEA;AACA;AACA;AACA,cAAIJ,+BAA+B3F,MAA/B,IAAyC,CAA7C,EAAiD;AACjD;AACE4F,qBAAO,IAAP;AACD,aAHD,MAIK,IAAIF,8BAA8B1F,MAA9B,GAAuC,CAA3C,EAA+C;AACpD;AACE+F,4BAAcL,8BAA8BzD,KAA9B,EAAd;AACA;AACD,aAJI,MAKA;AACL;AACE,mBAAKK,mCAAL,GAA2C,EAA3C;AACA,qBAAO,CAAE,CAAF,EAAKI,6BAAL,EAAoC+C,wBAApC,CAAP;AACD;AACF,SA/DH,CA+DI;;AAEF,YAAI,CAACG,IAAL,EACA;AACE;AACA,cAAIG,YAAY5D,IAAZ,IAAoB2D,QAAxB,EACA;AACE,mBAAO,CAAE,CAAF,EAAKpD,6BAAL,EAAoC+C,wBAApC,CAAP;AACD,WAHD,MAKA;AACE,iBAAKnD,mCAAL,CAAyCpC,IAAzC,CAA+C6F,WAA/C;AACD;AACF;AACF,OAhG2H,CAgG3H;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,UAAI,KAAK9F,sBAAT,EACA;AACE,YAAIyF,8BAA8B1F,MAA9B,GAAuC,CAA3C,EACA;AACE,cAAIiG,kBAAkBP,8BAA8B,CAA9B,CAAtB;AACA,cAAI,KAAKzF,sBAAL,CAA4BiG,OAA5B,CAAqCD,gBAAgB9D,IAArD,IAA8D,CAAC,CAAnE,EACA;AACE,mBAAO,CAAE,CAAF,EAAKO,6BAAL,EAAoC+C,wBAApC,CAAP;AACD;AACF;AACF;AACD;AACA;AACA;AACA;AACA;AACA,UAAI,CAAEjD,gBAAF,IAAsBA,iBAAiBgD,OAAjB,CAA0B,IAA1B,CAA1B,EACA;AACE9C,sCAA8BxC,IAA9B,CAAoC,KAAK8F,cAAL,EAApC;AACA,eAAO,CAAE,KAAKhG,MAAP,EAAe0C,6BAAf,EAA8CgD,6BAA9C,CAAP;AACD,OAJD,MAMA;AACE,eAAO,CAAE,CAAF,EAAKhD,6BAAL,EAAoC+C,wBAApC,CAAP;AACD;AACF;;;qCAEe;;AAEd,UAAIU,cAAc,IAAIlB,WAAJ,CAAiB,KAAKC,yBAAtB,EAAiD,KAAK/C,IAAtD,CAAlB;;AAEAgE,kBAAY7D,mCAAZ,GAAkD,KAAKA,mCAAvD;;AAEA,aAAO6D,WAAP;AACD;;;wBA1JmB;AAClB,aAAO,KAAK7D,mCAAZ;AACD;;;wBAEW;AACV,aAAO,KAAKA,mCAAL,CAAyCtC,MAAhD;AACD;;;;;;kBA/BgBiF,W;;;;;;;;;;;;;;;ACFrB;;;;;;;;;;;;IAEqBmB,K;;;AAEnB;;;;;;;;;;;;AAYA,iBAAaC,uBAAb,EAAsClE,IAAtC,EAA4CmE,IAA5C,EAAkDC,sBAAlD,EAA0E7F,MAA1E,EAAmG;AAAA,QAAjB8F,UAAiB,uEAAJ,CAAC,CAAG;;AAAA;;AAAA;;AAEjG,UAAKH,uBAAL,GAA+BA,uBAA/B;AACA,UAAKI,KAAL,GAAatE,IAAb;AACA,UAAKoB,KAAL,GAAaiD,UAAb;AACA,UAAKE,OAAL,GAAeJ,OAAOA,IAAP,GAAc,CAA7B;AACA,UAAKlE,eAAL,GAAuBmE,sBAAvB;AACA,UAAKI,OAAL,GAAejG,MAAf;AAPiG;AAQlG;;;;qCAMe;AACZ,aAAO,MAAO,KAAK+F,KAAZ,GAAoB,GAA3B;AACH;;;0BAMMlB,iB,EAAoB;AACzB,aAAOA,kBAAkBC,OAAlB,CAA2B,IAA3B,CAAP;AACD;;;sEAEkDoB,W,EAAaxF,a,EAAeyF,a,EAAe;AAC1F,WAAKH,OAAL,GAAe,CAAf;AACA,UAAII,QAAQ,KAAKT,uBAAL,CAA6BU,IAA7B,CAAmC3F,aAAnC,CAAZ;AACA,UAAI0F,SAAS,IAAT,IAAiBA,MAAME,KAAN,IAAe,CAApC,EAAuC;AACrC,aAAKN,OAAL,GAAeI,MAAM,CAAN,EAAS9G,MAAxB;AACA;AACA;AACA,YAAIiH,cAAc,IAAIb,KAAJ,CAAW,KAAKC,uBAAhB,EAAyC,KAAKlE,IAA9C,EAAoD,KAAKuE,OAAzD,EAAmEI,MAAM,CAAN,CAAnE,EAA6E,KAAKH,OAAlF,EAA2FE,aAA3F,CAAlB;AACA,YAAI,CAAC,KAAKF,OAAV,EAAmBC,YAAY1G,IAAZ,CAAkB+G,WAAlB;AACnB7F,wBAAgBA,cAAc8F,SAAd,CAAyB,KAAKlH,MAA9B,CAAhB;AACD;AACD,aAAO,CAAE,KAAK0G,OAAP,EAAgBE,WAAhB,EAA6BxF,aAA7B,CAAP;AACH;;;+BAES;AACR,aAAO,KAAKe,IAAL,GAAY,GAAZ,GAAkB,KAAKkE,uBAAL,CAA6Bf,QAA7B,EAAlB,GAA4D,IAA5D,GAAmE,KAAKlD,eAAxE,GAA0F,GAA1F,GAAgG,KAAKmB,KAArG,GAA6G,GAApH;AACD;;;wBAhCS;AACR,aAAO,KAAKkD,KAAZ;AACD;;;wBAMW;AACV,aAAO,KAAKC,OAAZ;AACD;;;;;;kBAlCkBN,K;;;;;;;;;;;ACFrB;;;;AACA;;;;;;;;IAEMe,iB;AACJ,6BAAatF,KAAb,EAAoB;AAAA;;AAClB,SAAKA,KAAL,GAAaA,KAAb;AACA,SAAKuF,cAAL,GAAsB,6BAAoBvF,KAApB,CAAtB;AACA,SAAKwF,cAAL,GAAsB,6BAAoBxF,KAApB,CAAtB;AACD;;;;6BAESyF,Q,EAAU;AAClB,WAAKzF,KAAL,GAAayF,QAAb;AACA,WAAKF,cAAL,CAAoBnD,QAApB,CAA8BqD,QAA9B;AACA,WAAKD,cAAL,CAAoBpD,QAApB,CAA8BqD,QAA9B;AACD;;;4BAEQC,kB,EAAqB;AAC5B,UAAGA,mBAAmBrF,WAAnB,CAA+BzB,IAA/B,IAAuC,aAA1C,EACA;AACE,YAAI8G,mBAAmBpF,IAAnB,IAA2B,SAA/B,EACE,OAAO,KAAKiF,cAAL,CAAoB5B,OAApB,CAA6B+B,kBAA7B,CAAP;AACF,YAAIA,mBAAmBpF,IAAnB,IAA2B,SAA/B,EACE,OAAO,KAAKkF,cAAL,CAAoB7B,OAApB,CAA6B+B,kBAA7B,CAAP;AACH,OAND,MAOK;AACL;AACE,cAAIA,mBAAmBpF,IAAnB,CAAwBqF,WAAxB,GAAsCtB,OAAtC,CAA+C,MAA/C,IAA0D,CAAC,CAA/D,EACA;AACE,mBAAO,IAAP;AACD;AACD,cAAIqB,mBAAmBpF,IAAnB,CAAwBqF,WAAxB,GAAsCtB,OAAtC,CAA+C,OAA/C,IAA2D,CAAC,CAAhE,EACA;AACE,mBAAO,KAAP;AACD;AACD,gBAAM,IAAI1E,KAAJ,CAAU,gCAAgC+F,mBAAmBpF,IAA7D,CAAN;AACA,iBAAO,IAAP;AACD;AACF;;;;;;AAGHyC,OAAOC,OAAP,GAAiBsC,iBAAjB,C;;;;;;;;;;;ACxCA;;;;;;;;IAEMM,c;AACJ,0BAAa5F,KAAb,EAAoB;AAAA;;AAClB,SAAKA,KAAL,GAAaA,KAAb;AACD;;;;6BAESyF,Q,EAAU;AAClB,WAAKzF,KAAL,GAAayF,QAAb;AACD;;;4BACQC,kB,EAAoB;AAC3B,UAAGA,mBAAmBrF,WAAnB,CAA+BzB,IAA/B,IAAuC,aAA1C,EACA;AACI,YAAI4C,iBAAiBkE,mBAAmBjF,mCAAxC;AACA,YAAIoF,QAAQ,KAAZ,CAFJ,CAEuB;AACnB,YAAIrE,eAAerD,MAAf,IAAyB,CAA7B,EAAiC;AACjC;AACE0H,oBAAQrE,eAAe,CAAf,EAAkBsB,KAAlB,CAAyB,IAAzB,CAAR;AACA,mBAAO+C,KAAP;AACD,WAJD,MAKK,IAAIrE,eAAerD,MAAf,IAAyB,CAA7B,EAAgC;AACrC;AACE;;AAEA,gBAAMqD,eAAe,CAAf,EAAkBlB,IAAlB,IAA0B,GAA5B,IAAsCkB,eAAe,CAAf,EAAkBlB,IAAlB,IAA0B,GAApE,EACA;AACE,qBAAOkB,eAAe,CAAf,EAAkBsB,KAAlB,CAAyB,IAAzB,CAAP;AACD;;AAGD,gBAAItB,eAAe,CAAf,EAAkBlB,IAAlB,IAA0B,GAA9B,EACA;AACE,qBAAOkB,eAAe,CAAf,EAAkBsB,KAAlB,CAAyB,IAAzB,IAAkCtB,eAAe,CAAf,EAAkBsB,KAAlB,CAAyB,IAAzB,CAAzC;AACD,aAHD,MAIK,IAAItB,eAAe,CAAf,EAAkBlB,IAAlB,IAA0B,GAA9B,EACL;AACE,qBAAOkB,eAAe,CAAf,EAAkBsB,KAAlB,CAAyB,IAAzB,IAAkCtB,eAAe,CAAf,EAAkBsB,KAAlB,CAAyB,IAAzB,CAAzC;AACD,aAHI,MAIA,IAAItB,eAAe,CAAf,EAAkBlB,IAAlB,IAA0B,GAA9B,EACL;AACE,qBAAOkB,eAAe,CAAf,EAAkBsB,KAAlB,CAAyB,IAAzB,IAAkCtB,eAAe,CAAf,EAAkBsB,KAAlB,CAAyB,IAAzB,CAAzC;AACD,aAHI,MAIA,IAAItB,eAAe,CAAf,EAAkBlB,IAAlB,IAA0B,GAA9B,EACL;AACE,qBAAOkB,eAAe,CAAf,EAAkBsB,KAAlB,CAAyB,IAAzB,IAAkCtB,eAAe,CAAf,EAAkBsB,KAAlB,CAAyB,IAAzB,CAAzC;AACD,aAHI,MAIA,IAAItB,eAAe,CAAf,EAAkBlB,IAAlB,IAA0B,GAA9B,EACL;AACE,qBAAOwF,KAAKC,GAAL,CAAUvE,eAAe,CAAf,EAAkBsB,KAAlB,CAAyB,IAAzB,CAAV,EAA2CtB,eAAe,CAAf,EAAkBsB,KAAlB,CAAyB,IAAzB,CAA3C,CAAP;AACD,aAHI,MAKL;AACE,oBAAM,IAAInD,KAAJ,CAAU,qDAAqDqG,KAAKC,SAAL,CAAgBzE,cAAhB,CAA/D,CAAN;AACD;AACF,WAlCI,MAmCA,IAAIA,eAAerD,MAAf,IAAyB,CAA7B,EAAgC;AACrC;AACE,gBAAIqD,eAAe,CAAf,EAAkBlB,IAAlB,IAA0B,GAA9B,EACA;AACE,qBAAOkB,eAAe,CAAf,EAAkBsB,KAAlB,CAAyB,IAAzB,CAAP;AACD;AACD,gBAAItB,eAAe,CAAf,EAAkBlB,IAAlB,IAA0B,GAA9B,EACA;AACE,qBAAO,CAAC,CAAD,GAAKkB,eAAe,CAAf,EAAkBsB,KAAlB,CAAyB,IAAzB,CAAZ;AACD,aAHD,MAKA;AACE,oBAAM,IAAInD,KAAJ,CAAU,yFAAyFqG,KAAKC,SAAL,CAAgBzE,cAAhB,CAAnG,CAAN;AACD;AACF;;AAGD,cAAM,IAAI7B,KAAJ,CAAU,sCAAsCqG,KAAKC,SAAL,CAAgBzE,cAAhB,CAAhD,CAAN;AACD,OA9DH,MA+DO;AACL;AACE,cAAIkE,mBAAmBpF,IAAnB,CAAwBqF,WAAxB,GAAsCtB,OAAtC,CAA+C,SAA/C,IAA6D,CAAC,CAAlE,EACA;AACE,mBAAO6B,SAAUR,mBAAmBnF,eAA7B,CAAP;AACD;AACD,gBAAM,IAAIZ,KAAJ,CAAU,gCAAgC+F,mBAAmBpF,IAA7D,CAAN;AACA,iBAAO,IAAP;AACD;AACJ;;;;;;AAGHyC,OAAOC,OAAP,GAAiB4C,cAAjB,C;;;;;;;;;;;;;qjBCtFA;AACA;;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;;;;;IAEqBO,M;AACnB,kBAAa5H,gBAAb,EAA+BR,aAA/B,EAA8C;AAAA;;AAI5C;AACA;AACA;AACA,SAAKiC,KAAL,GAAa,EAAb;;AAEA,SAAKoG,mBAAL,GAA2B,mCAA3B;;AAEA,SAAKnE,OAAL,GAAe,6BAAqB,KAAKjC,KAA1B,CAAf;AACA;AACA,SAAKkC,KAAL,GAAa,oBAAW3D,gBAAX,CAAb;AACA,SAAK4D,MAAL,GAAc,qBAAYpE,aAAZ,CAAd;AACA,SAAKoE,MAAL,CAAYC,QAAZ,CAAsB,KAAKpC,KAA3B;AACD;;;;0BAEMqC,e,EAAiB;AACtB,UACA;AACE,YAAIC,mBAAmB,KAAKJ,KAAL,CAAWK,QAAX,CAAqBF,eAArB,CAAvB;AACA,aAAKF,MAAL,CAAYC,QAAZ,CAAsB,KAAKpC,KAA3B;AACA,aAAKwC,SAAL,GAAiB,KAAKL,MAAL,CAAYM,KAAZ,CAAmBH,gBAAnB,EAAqC,KAAK8D,mBAA1C,CAAjB;AACA,eAAO,KAAK1D,iBAAL,EAAP;AACD,OAND,CAOA,OAAOC,CAAP,EACA;AACEO,gBAAQC,KAAR,CAAe,iCAAiCR,CAAhD;AACD;AACF;;;wCAEkB;AACjB,UAAIE,SAAS,KAAKL,SAAL,CAAe,CAAf,EAAkBM,KAAlB,CAAyB,KAAKb,OAA9B,CAAb;AACA,aAAOY,MAAP;AACD;;;;;;kBApCkBsD,M;;;;;;;;;ACRrB;;;;AACA;;;;AACA;;;;;;AAFiC;AAIjCE,OAAOC,MAAP,GAAgB,YAAU;AACtBC,OAAGC,MAAH,CAAU,aAAV,EAAyBC,EAAzB,CAA4B,QAA5B,EAAsC,UAAS9D,CAAT,EAAW;AAC7C,YAAI+D,eAAeH,GAAGC,MAAH,CAAU,aAAV,EAAyBG,IAAzB,GAAgCd,KAAhC,CAAsCe,WAAtC,EAAnB;AACAC,mBAAYH,YAAZ;AACH,KAHD;;AAMA,aAASG,UAAT,CAAqBC,OAArB,EAA8B;AAC1B,YAAIA,QAAQzC,OAAR,CAAiB,YAAjB,IAAkC,CAAC,CAAvC,EACA;AACI;AACA;AACA,gBAAK,CAAC0C,SAAD,IAAcA,UAAU1G,WAAV,CAAsBzB,IAAtB,IAA8B,SAAjD,EACA;AACI,oBAAIb,gBAAgB,CAChB,CAAG,CAAC,SAAD,EAAY,GAAZ,EAAiB,SAAjB,CAAH,EAAiC,SAAjC,CADgB,EAEhB,CAAG,CAAC,SAAD,EAAY,GAAZ,EAAiB,SAAjB,CAAH,EAAiC,SAAjC,CAFgB,EAGhB,CAAG,CAAC,SAAD,EAAY,GAAZ,EAAiB,SAAjB,CAAH,EAAiC,SAAjC,EAA4C,CAAC,GAAD,EAAM,GAAN,EAAW,GAAX,CAA5C,CAHgB,EAIhB,CAAG,CAAC,SAAD,EAAY,GAAZ,EAAiB,SAAjB,CAAH,EAAiC,SAAjC,EAA4C,CAAC,GAAD,EAAM,GAAN,EAAW,GAAX,CAA5C,CAJgB,EAKhB,CAAG,CAAC,SAAD,CAAH,EAAiB,SAAjB,CALgB,EAMhB,CAAG,CAAC,GAAD,EAAM,SAAN,EAAiB,GAAjB,CAAH,EAA2B,SAA3B,CANgB,CAApB;;AASA,oBAAIgB,SAAS,IAAb;;AAEA,oBAAIR,mBAAmB,CACnB,CAAE,KAAF,EAAS,EAAT,EAAaQ,MAAb,CADmB,EACI;AACvB,iBAAE,IAAF,EAAQ,GAAR,CAFmB,EAEJ;AACf,iBAAE,IAAF,EAAQ,GAAR,CAHmB,EAInB,CAAE,IAAF,EAAQ,GAAR,CAJmB,EAKnB,CAAE,IAAF,EAAQ,GAAR,CALmB,EAMnB,CAAE,GAAF,EAAO,GAAP,CANmB,EAOnB,CAAE,IAAF,EAAQ,GAAR,CAPmB,EAQnB,CAAE,IAAF,EAAQ,GAAR,CARmB,EASnB,CAAE,sBAAF,EAA0B,SAA1B,CATmB,EAUnB,CAAE,WAAF,EAAe,OAAf,CAVmB,EAWnB,CAAE,IAAF,EAAQ,WAAR,CAXmB,CAAvB;AAaAiI,2CAA4B,sBAAazI,gBAAb,EAA+BR,aAA/B,CAA5B,EAA4E,qBAA5E,EACA,wCADA;AAEH;AACJ,SAjCD,MAkCK,IAAI+I,QAAQzC,OAAR,CAAiB,SAAjB,IAA+B,CAAC,CAApC,EACL;AACI;AACA;AACA,gBAAK,CAAC0C,SAAD,IAAcA,UAAU1G,WAAV,CAAsBzB,IAAtB,IAA8B,SAAjD,EACA;AACI,oBAAIb,gBAAgB,CAChB,CAAG,CAAC,MAAD,CAAH,EAAc,SAAd,CADgB,EAEhB,CAAG,CAAC,OAAD,CAAH,EAAe,SAAf,CAFgB,EAGhB,CAAG,CAAC,GAAD,EAAM,SAAN,CAAH,EAAsB,SAAtB,CAHgB,EAIhB,CAAG,CAAC,SAAD,EAAY,GAAZ,EAAiB,SAAjB,CAAH,EAAiC,SAAjC,CAJgB,EAKhB,CAAG,CAAC,SAAD,EAAY,GAAZ,EAAiB,SAAjB,CAAH,EAAiC,SAAjC,CALgB,EAMhB,CAAG,CAAC,GAAD,EAAM,SAAN,EAAiB,GAAjB,CAAH,EAA2B,SAA3B,CANgB,CAApB;;AASA,oBAAIgB,UAAS,IAAb;;AAEA,oBAAIR,oBAAmB,CACnB,CAAE,KAAF,EAAS,EAAT,EAAaQ,OAAb,CADmB,EACI;AACvB,iBAAE,IAAF,EAAQ,GAAR,CAFmB,EAGnB,CAAE,MAAF,EAAU,GAAV,CAHmB,EAInB,CAAE,MAAF,EAAU,GAAV,CAJmB,EAIF;AACjB,iBAAE,MAAF,EAAU,GAAV,CALmB,EAMnB,CAAE,KAAF,EAAS,GAAT,CANmB,EAOnB,CAAE,IAAF,EAAQ,GAAR,CAPmB,EAOJ;AACf,iBAAE,IAAF,EAAQ,GAAR,CARmB,EAQJ;AACf,iBAAE,MAAF,EAAU,GAAV,CATmB,EAUnB,CAAE,IAAF,EAAQ,GAAR,CAVmB,EAWnB,CAAE,IAAF,EAAQ,GAAR,CAXmB,EAYnB,CAAE,wBAAF,EAA4B,MAA5B,CAZmB,EAanB,CAAE,yBAAF,EAA6B,OAA7B,CAbmB,EAcnB,CAAE,WAAF,EAAe,OAAf,CAdmB,EAenB,CAAE,IAAF,EAAQ,WAAR,CAfmB,CAAvB;AAiBAiI,2CAA4B,sBAAazI,iBAAb,EAA+BR,aAA/B,CAA5B,EAA4E,qDAA5E,EACA,+EADA;AAEH;AACJ,SArCI,MAsCA,IAAI+I,QAAQzC,OAAR,CAAiB,KAAjB,IAA2B,CAAC,CAAhC,EACL;AACI;AACA;AACA,gBAAK,CAAC0C,SAAD,IAAcA,UAAU1G,WAAV,CAAsBzB,IAAtB,IAA8B,QAAjD,EACA;AACI,oBAAIb,iBAAgB,CAChB,CAAG,CAAC,aAAD,EAAgB,UAAhB,EAA4B,cAA5B,CAAH,EAAiD,SAAjD,CADgB;AAEhB;AACA;AACA,iBAAG,CAAC,SAAD,CAAH,EAAgB,UAAhB,CAJgB,EAKhB,CAAG,CAAC,GAAD,EAAM,GAAN,EAAW,OAAX,EAAoB,GAApB,CAAH,EAA8B,UAA9B,CALgB,EAMhB,CAAG,CAAC,GAAD,EAAM,OAAN,EAAe,GAAf,CAAH,EAAyB,SAAzB,CANgB,EAOhB,CAAG,CAAC,GAAD,EAAM,OAAN,EAAe,GAAf,EAAoB,GAApB,CAAH,EAA8B,SAA9B,CAPgB,EAQhB,CAAG,CAAC,GAAD,EAAM,OAAN,EAAe,OAAf,EAAwB,GAAxB,EAA6B,IAA7B,EAAmC,UAAnC,EAA+C,IAA/C,CAAH,EAA0D,cAA1D,CARgB;AAShB;AACA,iBAAG,CAAC,cAAD,EAAiB,OAAjB,EAA0B,GAA1B,EAA+B,IAA/B,EAAqC,UAArC,EAAiD,IAAjD,CAAH,EAA4D,cAA5D,CAVgB,EAWhB,CAAG,CAAC,cAAD,EAAiB,GAAjB,CAAH,EAA0B,SAA1B,CAXgB;AAYhB;AACA;AACA,iBAAG,CAAC,OAAD,EAAU,OAAV,CAAH,EAAwB,UAAxB,CAdgB,EAehB,CAAG,CAAC,OAAD,EAAU,UAAV,CAAH,EAA2B,UAA3B,CAfgB,EAgBhB,CAAG,CAAC,UAAD,EAAa,UAAb,CAAH,EAA8B,UAA9B,CAhBgB;AAiBhB;AACA,iBAAG,CAAC,SAAD,EAAY,UAAZ,CAAH,EAA6B,UAA7B,CAlBgB,EAmBhB,CAAG,CAAC,UAAD,EAAa,UAAb,CAAH,EAA8B,UAA9B,CAnBgB,EAoBhB,CAAG,CAAC,UAAD,EAAa,SAAb,CAAH,EAA6B,UAA7B,CApBgB,EAqBhB,CAAG,CAAC,UAAD,EAAa,UAAb,CAAH,EAA8B,UAA9B,CArBgB,EAsBhB,CAAG,CAAC,SAAD,EAAY,UAAZ,CAAH,EAA6B,SAA7B,CAtBgB,EAuBhB,CAAG,CAAC,SAAD,EAAY,UAAZ,EAAwB,UAAxB,CAAH,EAAyC,SAAzC,CAvBgB,EAwBhB,CAAG,CAAC,SAAD,EAAY,SAAZ,EAAuB,UAAvB,CAAH,EAAwC,SAAxC,CAxBgB,EAyBhB,CAAG,CAAC,SAAD,EAAY,SAAZ,CAAH,EAA4B,UAA5B,CAzBgB,EA0BhB,CAAG,CAAC,SAAD,EAAY,UAAZ,EAAwB,UAAxB,CAAH,EAAyC,SAAzC,CA1BgB,CAApB;;AA6BA,oBAAIgB,WAAS,IAAb;;AAEA,oBAAIR,qBAAmB,CACnB,CAAG,KAAH,EAAU,EAAV,EAAcQ,QAAd,CADmB,EAEnB,CAAG,MAAH,EAAW,aAAX,CAFmB,EAGnB,CAAG,KAAH,EAAU,cAAV,CAHmB,EAInB,CAAG,IAAH,EAAS,GAAT,CAJmB,EAKnB,CAAG,GAAH,EAAQ,GAAR,CALmB,EAMnB,CAAG,GAAH,EAAQ,GAAR,CANmB,EAOnB,CAAG,GAAH,EAAQ,GAAR,CAPmB,EAQnB,CAAG,GAAH,EAAQ,GAAR,CARmB,EASnB,CAAG,GAAH,EAAQ,GAAR,CATmB,EAUnB,CAAG,sBAAH,EAA2B,SAA3B,CAVmB,EAWnB,CAAG,wBAAH,EAA6B,OAA7B,CAXmB;AAYnB;AACA,iBAAE,OAAF,EAAW,UAAX,CAbmB,CAAvB;;AAgBAiI,2CAA4B,qBAAYzI,kBAAZ,EAA8BR,cAA9B,CAA5B,0MAEA,mEAFA;AAGH;AACJ;AACJ;;AAED,aAASiJ,0BAAT,CAAqCC,YAArC,EAAmDC,SAAnD,EAA8DC,QAA9D,EAAwE;AACpEC,wBAAiBH,YAAjB;AACAV,WAAGC,MAAH,CAAU,YAAV,EAAwBG,IAAxB,GAA+Bd,KAA/B,GAAuCqB,SAAvC;AACAX,WAAGC,MAAH,CAAU,UAAV,EAAsBa,IAAtB,CAA4BF,QAA5B;AACAG;AACH;;AAED,aAASF,eAAT,CAA0BH,YAA1B,EAAyC;AACrC;AACA,YAAIF,aAAaE,aAAa5G,WAAb,CAAyBzB,IAAzB,IAAiCmI,UAAU1G,WAAV,CAAsBzB,IAAxE,EAA+E;AAC/EmI,oBAAYE,YAAZ;AACH;;AAEL,QAAIF,SAAJ;;AAIA,QAAIQ,YAAYzB,KAAK0B,GAAL,CAAU,GAAV,EAAenB,OAAOoB,WAAtB,CAAhB;AACA,QAAIC,WAAW5B,KAAK0B,GAAL,CAAU,IAAV,EAAgBnB,OAAOsB,UAAvB,CAAf;;AAEA,QAAIC,IAAI,CAAC,CAAD,EAAI,GAAJ,EAAS,GAAT,EAAc,GAAd,CAAR;AAAA,QACIC,IAAIH,WAAWE,EAAE,CAAF,CAAX,GAAkBA,EAAE,CAAF,CAD1B;AAAA,QAEIE,IAAIP,YAAYK,EAAE,CAAF,CAAZ,GAAmBA,EAAE,CAAF,CAF3B;AAAA,QAGIG,IAAI,CAHR;AAAA,QAIIC,IAJJ;;AAMA,QAAIC,OAAO1B,GAAG2B,MAAH,CAAUD,IAAV,GACNE,IADM,CACD,CAACL,CAAD,EAAID,CAAJ,CADC,CAAX;;AAGA,QAAIO,WAAW7B,GAAG8B,GAAH,CAAOD,QAAP,GACVE,UADU,CACC,UAASC,CAAT,EAAY;AAAE,eAAO,CAACA,EAAEC,CAAH,EAAMD,EAAEE,CAAR,CAAP;AAAoB,KADnC,CAAf;;AAGA,QAAIC,MAAMnC,GAAGC,MAAH,CAAU,OAAV,EAAmBmC,MAAnB,CAA0B,SAA1B,EACLC,IADK,CACA,OADA,EACSf,IAAID,EAAE,CAAF,CAAJ,GAAWA,EAAE,CAAF,CADpB,EAELgB,IAFK,CAEA,QAFA,EAEUd,IAAIF,EAAE,CAAF,CAAJ,GAAWA,EAAE,CAAF,CAFrB,EAGPe,MAHO,CAGA,OAHA,EAILC,IAJK,CAIA,WAJA,EAIa,eAAehB,EAAE,CAAF,CAAf,GAAsB,GAAtB,GAA4BA,EAAE,CAAF,CAA5B,GAAmC,GAJhD,CAAV;;AAMAc,QAAIC,MAAJ,CAAW,MAAX,EACEC,IADF,CACO,SADP,EACkB,CADlB,EAEKA,IAFL,CAEU,GAFV,EAEe,GAFf,EAGKA,IAHL,CAGU,IAHV,EAGgB,QAHhB,EAIKC,KAJL,CAIW,WAJX,EAIuB,MAJvB,EAKKA,KALL,CAKW,aALX,EAK0B,KAL1B,EAMKD,IANL,CAMU,IANV,EAMgB,QANhB,EAOKvB,IAPL,CAOU,EAPV;;AAWAd,OAAGC,MAAH,CAAU,aAAV,EAAyBC,EAAzB,CAA4B,OAA5B,EAAqC,UAAS9D,CAAT,EAAY;AAChD2E;AACA,KAFD;;AAIAf,OAAGC,MAAH,CAAU,YAAV,EAAwBC,EAAxB,CAA2B,OAA3B,EAAoC,YAAU;AAC1C,YAAGF,GAAGuC,KAAH,CAASC,OAAT,IAAoB,EAAvB,EAA0B;AACtBxC,eAAGC,MAAH,CAAU,aAAV,EAAyBC,EAAzB,CAA4B,OAA5B;AACH;AACJ,KAJD;;AAMA,QAAIjE,SAAJ;;AAEA,aAAS8E,iBAAT,GACA;AACI,YAAIJ,YAAYX,GAAGC,MAAH,CAAU,YAAV,EAAwBG,IAAxB,GAA+Bd,KAA/C;AACHrD,oBAAYuE,UAAUtE,KAAV,CAAiByE,SAAjB,CAAZ;AACA8B,oBAAaxG,SAAb;AACA;;AAED,aAASwG,WAAT,CAAsBC,IAAtB,EACA;AACEjB,eAAOiB,IAAP;AACAjB,aAAKkB,EAAL,GAAUpB,IAAI,CAAd;AACAE,aAAKmB,EAAL,GAAU,CAAV;AACA;AACA5C,WAAGC,MAAH,CAAU,YAAV,EAAwB4C,QAAxB,CAAiC,OAAjC,EAA0CpB,KAAKqB,gBAA/C;;AAEA9C,WAAGC,MAAH,CAAU,SAAV,EACCa,IADD,CACOW,KAAKnC,KADZ;;AAGA,iBAASyD,SAAT,CAAmBf,CAAnB,EAAsBgB,KAAtB,EAA8B;;AAE7B,gBAAI,CAAEA,KAAN,EAAcA,QAAQ,CAAR;;AAEb,gBAAIhB,EAAEiB,QAAN,EAAgB;AAClBC,uBAAOlB,CAAP;AACG;;AAED,gBAAIA,EAAEmB,SAAN,EAAiB;AACnBD,uBAAOlB,CAAP;AACG;AACF;AACD;AACAP,aAAKwB,QAAL,CAAcG,OAAd,CAAsBL,SAAtB,EAAiC,GAAjC;;AAEAM,eAAO5B,IAAP;AACD;;AAED;AACA,aAASyB,MAAT,CAAgBlB,CAAhB,EAAmBsB,WAAnB,EAAgC;AAC/B,YAAItB,KAAKuB,SAAT,EAAqB;AAClB;AACA,YAAIvB,EAAE1C,KAAF,KAAY,IAAZ,IAAqB0C,EAAE1C,KAAF,KAAY,KAArC,EACA;AACI,gBAAI0C,EAAEiB,QAAN,EAAgB;AAChB;AACIjB,kBAAEmB,SAAF,GAAcnB,EAAEiB,QAAhB;AACAjB,kBAAEiB,QAAF,GAAa,IAAb;AACH,aAJD,MAIO;AACP;AACIjB,kBAAEiB,QAAF,GAAajB,EAAEmB,SAAf;AACAnB,kBAAEmB,SAAF,GAAc,IAAd;AACH;;AAED,gBAAIK,gBAAgB,CAACxB,EAAEiB,QAAH,IAAe,CAACjB,EAAEmB,SAAtC;AACA,gBAAI,CAACK,aAAL,EACA;AACI;AACA;;AAEA,oBAAKxB,EAAEiB,QAAF,IAAcjB,EAAEiB,QAAF,CAAWrL,MAAX,IAAqB,CAAxC,EAA4C4L,gBAAgB,IAAhB;AAC5C,oBAAKxB,EAAEmB,SAAF,IAAenB,EAAEmB,SAAF,CAAYvL,MAAZ,IAAsB,CAA1C,EAA8C4L,gBAAgB,IAAhB;AACjD;AACD,gBAAIA,aAAJ,EAAoB;AACpB;AACI;AACA,wBAAMxB,EAAE1C,KAAF,KAAY,IAAd,IAAyB0C,EAAE1C,KAAF,KAAY,KAAzC,EACA;AACI0C,0BAAE1C,KAAF,GAAU,CAAC0C,EAAE1C,KAAb;AACA;AACA;AACA,4BAAImE,QAAQzB,EAAE3J,IAAd;AACAmI,kCAAU/G,KAAV,CAAiBgK,KAAjB,IAA2BzB,EAAE1C,KAA7B;AACAoE,8CAAsBjC,IAAtB;AACH;AACJ;AACJ,SAlCD,MAmCK;AACL;AACI,oBAAI6B,WAAJ,EACA;AACI,wBAAIK,gBAAgB3B,EAAE4B,UAAF,GAAenE,KAAKC,SAAL,CAAgBsC,EAAE4B,UAAlB,CAAf,GAAgD,MAApE;AACA,wBAAI,CAAE5B,EAAEiB,QAAJ,IAAgB,CAACjB,EAAEmB,SAAvB,EAAkC;AAClC;AACI;;AAEAU,6CAAkB,iBAAiBF,aAAjB,GAAiC,gBAAjC,GAAoD3B,EAAE1C,KAAxE;AACH,yBALD,MAMI;AACJ;AACI;AACA,gCAAI0C,EAAEiB,QAAN,EAAgB;AAChB;AACIjB,kCAAEmB,SAAF,GAAcnB,EAAEiB,QAAhB;AACAjB,kCAAEiB,QAAF,GAAa,IAAb;AACH,6BAJD,MAIO;AACP;AACIjB,kCAAEiB,QAAF,GAAajB,EAAEmB,SAAf;AACAnB,kCAAEmB,SAAF,GAAc,IAAd;AACH;AACJ;AACJ;AACJ;AACJ;;AAED,aAASU,gBAAT,CAA2BC,GAA3B,EAAgC;AAC5BC,UAAE,iBAAF,EAAqBC,IAArB,CAA2BF,GAA3B;AACAC,UAAE,aAAF,EAAiBE,KAAjB,CAAuB,MAAvB;AACH;;AAED,aAASP,qBAAT,GACA;AACIzH,oBAAYuE,UAAUrE,iBAAV,EAAZ;AACA+H,mCAA4BjI,SAA5B,EAAuCwF,IAAvC;;AAEHzB,WAAGC,MAAH,CAAU,SAAV,EACEa,IADF,CACQW,KAAKnC,KADb;AAEA;;AAED,aAAS4E,0BAAT,CAAqCC,aAArC,EAAoDC,QAApD,EACA;;AAEIA,iBAAS9E,KAAT,GAAiB6E,cAAc7E,KAA/B;AACA,YAAI,CAAE6E,cAAclB,QAApB,EAA+B;AAC/B,aAAK,IAAIzB,IAAI,CAAb,EAAgBA,IAAI2C,cAAclB,QAAd,CAAuBrL,MAA3C,EAAmD4J,GAAnD,EACA;AACI,gBAAI4C,SAASnB,QAAb,EACA;AACIiB,2CAA4BC,cAAclB,QAAd,CAAwBzB,CAAxB,CAA5B,EAAyD4C,SAASnB,QAAT,CAAmBzB,CAAnB,CAAzD;AACH,aAHD,MAKA;AACC,oBAAI4C,SAASjB,SAAb,EACA;AACIe,+CAA4BC,cAAclB,QAAd,CAAwBzB,CAAxB,CAA5B,EAAyD4C,SAASjB,SAAT,CAAoB3B,CAApB,CAAzD;AACA;AACJ;AAEJ;AACJ;;AAID,aAAS6B,MAAT,CAAgBgB,MAAhB,EAAwB;AACtB,YAAIC,WAAWtE,GAAGuC,KAAH,IAAYvC,GAAGuC,KAAH,CAASgC,MAArB,GAA8B,IAA9B,GAAqC,GAApD;;AAEA;AACA,YAAIC,QAAQ9C,KAAK8C,KAAL,CAAW/C,IAAX,EAAiBgD,OAAjB,EAAZ;;AAIA;AACA;;AAEAC,uBAAe,GAAf;AACA,YAAIC,OAAO3E,GAAGC,MAAH,CAAU,MAAV,CAAX;AACA,YAAI6B,MAAM6C,KAAK1E,MAAL,CAAY,KAAZ,CAAV;AACA,YAAI2E,gBAAgB9C,IAAIQ,KAAJ,CAAU,OAAV,EAAmBuC,OAAnB,CAA2B,IAA3B,EAAiC,EAAjC,CAApB;AACAD,wBAAgBjF,SAAUiF,aAAV,CAAhB;AACA,YAAIF,eAAeE,gBAAgBJ,MAAM5M,MAAzC;AACA4M,cAAMpB,OAAN,CAAc,UAASpB,CAAT,EAAY;AAAEA,cAAEC,CAAF,GAAMD,EAAE8C,KAAF,GAAUJ,YAAhB;AAA+B,SAA3D;;AAEA1E,WAAGC,MAAH,CAAU,SAAV,EACC8E,UADD,GAECT,QAFD,CAEUA,QAFV,EAGCjC,IAHD,CAGM,GAHN,EAGWmC,MAAMA,MAAM5M,MAAN,GAAc,CAApB,EAAwBqK,CAAxB,GAA4B,EAHvC,EAICI,IAJD,CAIM,GAJN,EAIW,UAASL,CAAT,EAAW;AAAE,mBAAOwC,MAAMA,MAAM5M,MAAN,GAAc,CAApB,EAAwBsK,CAAxB,GAA4B,EAAnC;AAAuC,SAJ/D;;AAMA;AACA,YAAI9B,OAAO+B,IAAI6C,SAAJ,CAAc,QAAd,EACNC,IADM,CACDT,KADC,EACM,UAASxC,CAAT,EAAY;AAAE,mBAAOA,EAAEkD,EAAF,KAASlD,EAAEkD,EAAF,GAAO,EAAE1D,CAAlB,CAAP;AAA8B,SADlD,CAAX;;AAGA;AACA,YAAI2D,YAAY/E,KAAKgF,KAAL,GAAahD,MAAb,CAAoB,OAApB,EACXC,IADW,CACN,OADM,EACG,MADH,EAEXA,IAFW,CAEN,WAFM,EAEO,UAASL,CAAT,EAAY;AAAE,mBAAO,eAAeqC,OAAOzB,EAAtB,GAA2B,GAA3B,GAAiCyB,OAAO1B,EAAxC,GAA6C,GAApD;AAA0D,SAF/E,EAGXzC,EAHW,CAGR,OAHQ,EAGC,UAAS8B,CAAT,EAAY;AAAEkB,mBAAOlB,CAAP,EAAU,IAAV,EAAkBqB,OAAOrB,CAAP;AAAY,SAH7C,EAIX9B,EAJW,CAIR,WAJQ,EAIK,UAAS8B,CAAT,EAAW;AACtB,gBAAI2B,gBAAgB3B,EAAE4B,UAAF,GAAenE,KAAKC,SAAL,CAAgBsC,EAAE4B,UAAlB,CAAf,GAAgD,EAApE;AACA,gBAAID,cAAc/L,MAAd,GAAuB,CAA3B,EACA;AACIiM,iCAAkB,iBAAiBF,aAAjB,GAAiC,gBAAjC,GAAoD3B,EAAE1C,KAAxE;AACH;AAEN,SAXW,CAAhB;;AAaA6F,kBAAU/C,MAAV,CAAiB,YAAjB,EACKC,IADL,CACU,GADV,EACe,IADf,EAEKC,KAFL,CAEW,QAFX,EAEqB,UAASN,CAAT,EAAW;AAAE,mBAAOA,EAAE1C,KAAF,GAAU,OAAV,GAAoB,KAA3B;AAAkC,SAFpE,EAGKgD,KAHL,CAGW,MAHX,EAGmB,UAASN,CAAT,EAAY;AAAE,mBAAOA,EAAEmB,SAAF,GAAc,MAAd,GAAuB,MAA9B;AAAuC,SAHxE;;AAKAgC,kBAAU/C,MAAV,CAAiB,UAAjB,EACKC,IADL,CACU,GADV,EACe,UAASL,CAAT,EAAY;AAAE,mBAAOA,EAAEiB,QAAF,IAAcjB,EAAEmB,SAAhB,GAA4B,CAAC,CAA7B,GAAiC,EAAxC;AAA6C,SAD1E,EAEKd,IAFL,CAEU,GAFV,EAEe,UAASL,CAAT,EAAY;AAAE,mBAAOA,EAAEiB,QAAF,IAAcjB,EAAEmB,SAAhB,GAA4B,EAA5B,GAAiC,CAAC,CAAzC;AAA6C,SAF1E,EAGKd,IAHL,CAGU,IAHV,EAGgB,OAHhB,EAIKA,IAJL,CAIU,aAJV,EAIyB,UAASL,CAAT,EAAY;AAAE,mBAAOA,EAAEiB,QAAF,IAAcjB,EAAEmB,SAAhB,GAA4B,QAA5B,GAAuC,MAA9C;AAAuD,SAJ9F;AAKF;AALE,SAMKrC,IANL,CAMU,UAASkB,CAAT,EAAY;AAAE,mBAAOA,EAAE3J,IAAT;AAAgB,SANxC,EAOKiK,KAPL,CAOW,cAPX,EAO2B,IAP3B;;AASA;AACA,YAAI+C,aAAajF,KAAK2E,UAAL,GACZT,QADY,CACHA,QADG,EAEZhC,KAFY,CAEN,QAFM,EAEI,UAASN,CAAT,EAAW;AAAE,mBAAOA,EAAE1C,KAAF,GAAU,OAAV,GAAoB,KAA3B;AAAoC,SAFrD,EAGZ+C,IAHY,CAGP,WAHO,EAGM,UAASL,CAAT,EAAY;AAAE,mBAAO,eAAeA,EAAEC,CAAjB,GAAqB,GAArB,GAA2BD,EAAEE,CAA7B,GAAiC,GAAxC;AAA8C,SAHlE,CAAjB;;AAKAmD,mBAAWpF,MAAX,CAAkB,QAAlB,EACKoC,IADL,CACU,GADV,EACe,GADf,EAEKC,KAFL,CAEW,QAFX,EAEqB,UAASN,CAAT,EAAW;AAAE,mBAAOA,EAAE1C,KAAF,GAAU,OAAV,GAAoB,KAA3B;AAAkC,SAFpE,EAGKgD,KAHL,CAGW,MAHX,EAGmB,UAASN,CAAT,EAAY;AAAE,mBAAOA,EAAEmB,SAAF,GAAc,gBAAd,GAAiC,MAAxC;AAAiD,SAHlF;;AAKAkC,mBAAWpF,MAAX,CAAkB,MAAlB,EACKqC,KADL,CACW,cADX,EAC2B,CAD3B;;AAGA;AACA,YAAIgD,WAAWlF,KAAKmF,IAAL,GAAYR,UAAZ,GACVT,QADU,CACDA,QADC,EAEVjC,IAFU,CAEL,WAFK,EAEQ,UAASL,CAAT,EAAY;AAAE,mBAAO,eAAeqC,OAAOpC,CAAtB,GAA0B,GAA1B,GAAgCoC,OAAOnC,CAAvC,GAA2C,GAAlD;AAAwD,SAF9E,EAGVsD,MAHU,EAAf;;AAKAF,iBAASrF,MAAT,CAAgB,QAAhB,EACKoC,IADL,CACU,GADV,EACe,IADf;;AAGAiD,iBAASrF,MAAT,CAAgB,MAAhB,EACKqC,KADL,CACW,cADX,EAC2B,IAD3B;;AAGA;AACA,YAAImD,OAAOtD,IAAI6C,SAAJ,CAAc,WAAd,EACNC,IADM,CACDvD,KAAKgE,KAAL,CAAWlB,KAAX,CADC,EACkB,UAASxC,CAAT,EAAY;AAAE,mBAAOA,EAAE2D,MAAF,CAAST,EAAhB;AAAqB,SADrD,CAAX;;AAGA;AACAO,aAAKL,KAAL,GAAaQ,MAAb,CAAoB,UAApB,EAAgC,GAAhC,EACKvD,IADL,CACU,OADV,EACmB,MADnB,EAEKA,IAFL,CAEU,GAFV,EAEe,UAASL,CAAT,EAAY;AACrB,gBAAI6D,IAAI,EAAC3D,GAAGmC,OAAO1B,EAAX,EAAeV,GAAGoC,OAAOzB,EAAzB,EAAR;AACA,mBAAOf,SAAS,EAACwC,QAAQwB,CAAT,EAAYF,QAAQE,CAApB,EAAT,CAAP;AACD,SALL,EAMGd,UANH,GAOKT,QAPL,CAOcA,QAPd,EAQKjC,IARL,CAQU,GARV,EAQeR,QARf;;AAUA;AACA4D,aAAKV,UAAL,GACKT,QADL,CACcA,QADd,EAEKjC,IAFL,CAEU,GAFV,EAEeR,QAFf;;AAIA;AACA4D,aAAKF,IAAL,GAAYR,UAAZ,GACKT,QADL,CACcA,QADd,EAEKjC,IAFL,CAEU,GAFV,EAEe,UAASL,CAAT,EAAY;AACrB,gBAAI6D,IAAI,EAAC3D,GAAGmC,OAAOnC,CAAX,EAAcD,GAAGoC,OAAOpC,CAAxB,EAAR;AACA,mBAAOJ,SAAS,EAACwC,QAAQwB,CAAT,EAAYF,QAAQE,CAApB,EAAT,CAAP;AACD,SALL,EAMKL,MANL;;AAQA;AACAhB,cAAMpB,OAAN,CAAc,UAASpB,CAAT,EAAY;AACxBA,cAAEW,EAAF,GAAOX,EAAEE,CAAT;AACAF,cAAEY,EAAF,GAAOZ,EAAEC,CAAT;AACD,SAHD;AAID;;AAED3B,eAAW,SAAX;AACAS;AACC,CA/cD,C;;;;;;;;;;;;;ICJM+E,kB;AACJ,8BAAarM,KAAb,EAAoB;AAAA;;AAClB,SAAKA,KAAL,GAAaA,KAAb;AACD;;;;6BACSyF,Q,EAAU;AAClB,WAAKzF,KAAL,GAAayF,QAAb;AACD;;;4BAEQ6G,e,EACT;AACM,UAAIC,KAAK,EAAT;AACAA,SAAG3N,IAAH,GAAU0N,gBAAgBhM,IAA1B;AACAiM,SAAG1G,KAAH,GAAWyG,gBAAgBzG,KAAhB,GAAwB,KAAK2G,UAAL,CAAiBF,eAAjB,CAAnC;AACA,UAAI9K,iBAAiB8K,gBAAgB7L,mCAArC;;AAEA,cAAQ6L,gBAAgBhM,IAAxB;AAEI,aAAK,OAAL;AACI,iBAAO,EAAE1B,MAAO0N,gBAAgB5H,sBAAzB,EAAiDmB,OAAO,KAAK2G,UAAL,CAAiBF,eAAjB,CAAxD,EAA4FG,WAAW,0BAAvG,EAAP;AACJ,aAAK,SAAL;;AAEIF,aAAG/C,QAAH,GAAc,EAAd;AACA,cAAIhI,eAAerD,MAAf,IAAyB,CAA7B,EAAiC;AACjC;;AAEE;AACA,kBAAMqD,eAAe,CAAf,EAAkBlB,IAAlB,IAA0B,GAA5B,IAAsCkB,eAAe,CAAf,EAAkBlB,IAAlB,IAA0B,GAApE,EACA;AACE;AACA;AACA;AACA,uBAAO,KAAKqD,OAAL,CAAcnC,eAAgB,CAAhB,CAAd,CAAP;AACD,eAND,MAQA;AACE+K,mBAAG3N,IAAH,GAAU,KAAK8N,kBAAL,CAAyBlL,eAAgB,CAAhB,EAAoBlB,IAA7C,CAAV;AACAiM,mBAAG/C,QAAH,CAAYnL,IAAZ,CAAkB,KAAKsF,OAAL,CAAcnC,eAAgB,CAAhB,CAAd,CAAlB;AACA+K,mBAAG/C,QAAH,CAAYnL,IAAZ,CAAkB,KAAKsF,OAAL,CAAcnC,eAAgB,CAAhB,CAAd,CAAlB;AACD;AAEF,aAlBD,MAmBK,IAAIA,eAAerD,MAAf,IAAyB,CAA7B,EAAiC;AACtC;AACE;AACAoO,iBAAG3N,IAAH,GAAU,KAAK8N,kBAAL,CAAyBlL,eAAgB,CAAhB,EAAoBlB,IAA7C,CAAV;AACAiM,iBAAG/C,QAAH,CAAYnL,IAAZ,CAAkB,KAAKsF,OAAL,CAAcnC,eAAgB,CAAhB,CAAd,CAAlB;AACD,aALI,MAOL;AACE,mBAAO,KAAKmC,OAAL,CAAcnC,eAAgB,CAAhB,CAAd,CAAP;AACD;;AAED;;AAEJ,aAAK,OAAL;AAAc;AACV+K,aAAG3N,IAAH,GAAU0N,gBAAgB/L,eAA1B;AAxCR;AA0CA,aAAOgM,EAAP;AACL;;;+BAEW7G,kB,EAAoB;;AAE9B,UAAGA,mBAAmBrF,WAAnB,CAA+BzB,IAA/B,IAAuC,aAA1C,EACA;AACI,YAAI4C,iBAAiBkE,mBAAmBjF,mCAAxC;AACA,YAAIoF,QAAQ,KAAZ,CAFJ,CAEuB;AACnB,YAAIrE,eAAerD,MAAf,IAAyB,CAA7B,EAAiC;AACjC;AACE0H,oBAAQ,KAAK2G,UAAL,CAAiBhL,eAAe,CAAf,CAAjB,CAAR;AACA,mBAAOqE,KAAP;AACD,WAJD,MAKK,IAAIrE,eAAerD,MAAf,IAAyB,CAA7B,EAAgC;AACrC;AACE,gBAAIqD,eAAe,CAAf,EAAkBlB,IAAlB,IAA0B,GAA9B,EACA;AACE,qBAAO,KAAKkM,UAAL,CAAiBhL,eAAe,CAAf,CAAjB,KAAwC,KAAKgL,UAAL,CAAiBhL,eAAe,CAAf,CAAjB,CAA/C;AACD,aAHD,MAIK,IAAIA,eAAe,CAAf,EAAkBlB,IAAlB,IAA0B,GAA9B,EACL;AACE,qBAAO,KAAKkM,UAAL,CAAiBhL,eAAe,CAAf,CAAjB,KAAwC,KAAKgL,UAAL,CAAiBhL,eAAe,CAAf,CAAjB,CAA/C;AACD,aAHI,MAIA,IAAMA,eAAe,CAAf,EAAkBlB,IAAlB,IAA0B,GAA5B,IAAsCkB,eAAe,CAAf,EAAkBlB,IAAlB,IAA0B,GAApE,EACL;AACE,qBAAO,KAAKkM,UAAL,CAAiBhL,eAAe,CAAf,CAAjB,CAAP;AACD,aAHI,MAKL;AACE,oBAAM,IAAI7B,KAAJ,CAAU,sEAAsEqG,KAAKC,SAAL,CAAgBzE,cAAhB,CAAhF,CAAN;AACD;AACF,WAlBI,MAmBA,IAAIA,eAAerD,MAAf,IAAyB,CAA7B,EAAgC;AACrC;AACE,gBAAIqD,eAAe,CAAf,EAAkBlB,IAAlB,IAA0B,GAA9B,EACA;AACE,qBAAO,CAAE,KAAKkM,UAAL,CAAiBhL,eAAe,CAAf,CAAjB,CAAT;AACD,aAHD,MAKA;AACE,oBAAM,IAAI7B,KAAJ,CAAU,sEAAsEqG,KAAKC,SAAL,CAAgBzE,cAAhB,CAAhF,CAAN;AACD;AACF;;AAED,cAAM,IAAI7B,KAAJ,CAAU,sCAAsCqG,KAAKC,SAAL,CAAgBzE,cAAhB,CAAhD,CAAN;AACD,OAzCH,MA0CO;AACL;AACE,cAAIkE,mBAAmBpF,IAAnB,CAAwBqF,WAAxB,GAAsCtB,OAAtC,CAA+C,MAA/C,IAA0D,CAAC,CAA/D,EACA;AACE,mBAAO,IAAP;AACD;AACD,cAAIqB,mBAAmBpF,IAAnB,CAAwBqF,WAAxB,GAAsCtB,OAAtC,CAA+C,OAA/C,IAA2D,CAAC,CAAhE,EACA;AACE,mBAAO,KAAP;AACD;AACD,cAAIqB,mBAAmBpF,IAAnB,CAAwBqF,WAAxB,GAAsCtB,OAAtC,CAA+C,OAA/C,IAA2D,CAAC,CAAhE,EACA;AACE,mBAAO,KAAKrE,KAAL,CAAY0F,mBAAmBnF,eAA/B,CAAP;AACD;;AAED,gBAAM,IAAIZ,KAAJ,CAAU,gCAAgC+F,mBAAmBpF,IAA7D,CAAN;AACA,iBAAO,IAAP;AACD;AACJ;;;uCAEmBqM,c,EAAgB;AAClC,UAAIA,kBAAkB,GAAtB,EAA4B,OAAO,IAAP;AAC5B,UAAIA,kBAAkB,GAAtB,EAA4B,OAAO,KAAP;AAC5B,UAAIA,kBAAkB,GAAtB,EAA4B,OAAO,KAAP;AAC5B,UAAIA,kBAAkB,GAAtB,EAA4B,OAAO,KAAP;AAC7B;;;;;;AAGH5J,OAAOC,OAAP,GAAiBqJ,kBAAjB,C;;;;;;;;;;;ACrIA;;;;;;;;IAEMO,c;AACJ,0BAAa5M,KAAb,EAAoB;AAAA;;AAClB,SAAKA,KAAL,GAAaA,KAAb;AACD;;;;6BACSyF,Q,EAAU;AAClB,WAAKzF,KAAL,GAAayF,QAAb;AACD;;;4BAEQC,kB,EAAoB;AAC3B,UAAGA,mBAAmBrF,WAAnB,CAA+BzB,IAA/B,IAAuC,aAA1C,EACA;AACI,YAAI4C,iBAAiBkE,mBAAmBjF,mCAAxC;AACA,YAAIoF,QAAQ,KAAZ,CAFJ,CAEuB;AACnB,YAAIrE,eAAerD,MAAf,IAAyB,CAA7B,EAAiC;AACjC;AACE0H,oBAAQrE,eAAe,CAAf,EAAkBsB,KAAlB,CAAyB,IAAzB,CAAR;AACA,mBAAO+C,KAAP;AACD,WAJD,MAKK,IAAIrE,eAAerD,MAAf,IAAyB,CAA7B,EAAgC;AACrC;AACE,gBAAIqD,eAAe,CAAf,EAAkBlB,IAAlB,IAA0B,GAA9B,EACA;AACE,qBAAOkB,eAAe,CAAf,EAAkBsB,KAAlB,CAAyB,IAAzB,KAAmCtB,eAAe,CAAf,EAAkBsB,KAAlB,CAAyB,IAAzB,CAA1C;AACD,aAHD,MAIK,IAAItB,eAAe,CAAf,EAAkBlB,IAAlB,IAA0B,GAA9B,EACL;AACE,qBAAOkB,eAAe,CAAf,EAAkBsB,KAAlB,CAAyB,IAAzB,KAAmCtB,eAAe,CAAf,EAAkBsB,KAAlB,CAAyB,IAAzB,CAA1C;AACD,aAHI,MAIA,IAAMtB,eAAe,CAAf,EAAkBlB,IAAlB,IAA0B,GAA5B,IAAsCkB,eAAe,CAAf,EAAkBlB,IAAlB,IAA0B,GAApE,EACL;AACE,qBAAOkB,eAAe,CAAf,EAAkBsB,KAAlB,CAAyB,IAAzB,CAAP;AACD,aAHI,MAKL;AACE,oBAAM,IAAInD,KAAJ,CAAU,sEAAsEqG,KAAKC,SAAL,CAAgBzE,cAAhB,CAAhF,CAAN;AACD;AACF,WAlBI,MAmBA,IAAIA,eAAerD,MAAf,IAAyB,CAA7B,EAAgC;AACrC;AACE,gBAAIqD,eAAe,CAAf,EAAkBlB,IAAlB,IAA0B,GAA9B,EACA;AACE,qBAAO,CAAEkB,eAAe,CAAf,EAAkBsB,KAAlB,CAAyB,IAAzB,CAAT;AACD,aAHD,MAKA;AACE,oBAAM,IAAInD,KAAJ,CAAU,sEAAsEqG,KAAKC,SAAL,CAAgBzE,cAAhB,CAAhF,CAAN;AACD;AACF;;AAGD,cAAM,IAAI7B,KAAJ,CAAU,sCAAsCqG,KAAKC,SAAL,CAAgBzE,cAAhB,CAAhD,CAAN;AACD,OA1CH,MA2CO;AACL;AACE,cAAIkE,mBAAmBpF,IAAnB,CAAwBqF,WAAxB,GAAsCtB,OAAtC,CAA+C,MAA/C,IAA0D,CAAC,CAA/D,EACA;AACE,mBAAO,IAAP;AACD;AACD,cAAIqB,mBAAmBpF,IAAnB,CAAwBqF,WAAxB,GAAsCtB,OAAtC,CAA+C,OAA/C,IAA2D,CAAC,CAAhE,EACA;AACE,mBAAO,KAAP;AACD;AACD,cAAIqB,mBAAmBpF,IAAnB,CAAwBqF,WAAxB,GAAsCtB,OAAtC,CAA+C,OAA/C,IAA2D,CAAC,CAAhE,EACA;AACE,mBAAO,KAAKrE,KAAL,CAAY0F,mBAAmBnF,eAA/B,CAAP;AACD;;AAED,gBAAM,IAAIZ,KAAJ,CAAU,gCAAgC+F,mBAAmBpF,IAA7D,CAAN;AACA,iBAAO,IAAP;AACD;AACJ;;;;;;AAGHyC,OAAOC,OAAP,GAAiB4J,cAAjB,C;;;;;;;;;;;;;IC1EMC,e;AACJ,2BAAa7M,KAAb,EAAoB;AAAA;;AAClB,SAAKA,KAAL,GAAaA,KAAb;AACD;;;;6BACSyF,Q,EAAU;AAClB,WAAKzF,KAAL,GAAayF,QAAb;AACD;;;4BAEQ6G,e,EACT;AACM,UAAIC,KAAK,EAAT;AACAA,SAAG3N,IAAH,GAAU0N,gBAAgBhM,IAA1B;AACAiM,SAAG1G,KAAH,GAAWyG,gBAAgBzG,KAAhB,GAAwB,KAAKiH,QAAL,CAAeR,eAAf,CAAnC;;AAEA,UAAI9K,iBAAiB8K,gBAAgB7L,mCAArC;;AAEA,cAAQ6L,gBAAgBhM,IAAxB;AAEI,aAAK,SAAL;AACI,iBAAO,EAAE1B,MAAO,KAAKkO,QAAL,CAAeR,eAAf,CAAT,EAA2CzG,OAAO,KAAKiH,QAAL,CAAeR,eAAf,CAAlD,EAAoFG,WAAW,0BAA/F,EAAP;AACJ,aAAK,SAAL;;AAEIF,aAAG/C,QAAH,GAAc,EAAd;AACA,cAAIhI,eAAerD,MAAf,IAAyB,CAA7B,EAAiC;AACjC;;AAEE;AACA,kBAAMqD,eAAe,CAAf,EAAkBlB,IAAlB,IAA0B,GAA5B,IAAsCkB,eAAe,CAAf,EAAkBlB,IAAlB,IAA0B,GAApE,EACA;AACE;AACA;AACA;AACA,uBAAO,KAAKqD,OAAL,CAAcnC,eAAgB,CAAhB,CAAd,CAAP;AACD,eAND,MAQA;AACE+K,mBAAG3N,IAAH,GAAU4C,eAAgB,CAAhB,EAAoBlB,IAA9B;AACAiM,mBAAG/C,QAAH,CAAYnL,IAAZ,CAAkB,KAAKsF,OAAL,CAAcnC,eAAgB,CAAhB,CAAd,CAAlB;AACA+K,mBAAG/C,QAAH,CAAYnL,IAAZ,CAAkB,KAAKsF,OAAL,CAAcnC,eAAgB,CAAhB,CAAd,CAAlB;AACD;AAEF,aAlBD,MAmBK,IAAIA,eAAerD,MAAf,IAAyB,CAA7B,EAAiC;AACtC;AACE;AACAoO,iBAAG3N,IAAH,GAAU4C,eAAgB,CAAhB,EAAoBlB,IAA9B;AACAiM,iBAAG/C,QAAH,CAAYnL,IAAZ,CAAkB,KAAKsF,OAAL,CAAcnC,eAAgB,CAAhB,CAAd,CAAlB;AACD,aALI,MAOL;AACE,mBAAO,KAAKmC,OAAL,CAAcnC,eAAgB,CAAhB,CAAd,CAAP;AACD;;AAED;;AAEJ,aAAK,OAAL;AAAc;AACV+K,aAAG3N,IAAH,GAAU0N,gBAAgB/L,eAA1B;AAxCR;AA0CA,aAAOgM,EAAP;AACL;;;6BAES7G,kB,EAAoB;AAC5B,UAAGA,mBAAmBrF,WAAnB,CAA+BzB,IAA/B,IAAuC,aAA1C,EACA;AACI,YAAI4C,iBAAiBkE,mBAAmBjF,mCAAxC;AACA,YAAIoF,QAAQ,KAAZ,CAFJ,CAEuB;AACnB,YAAIrE,eAAerD,MAAf,IAAyB,CAA7B,EAAiC;AACjC;AACE0H,oBAAQ,KAAKiH,QAAL,CAAetL,eAAe,CAAf,CAAf,CAAR;AACA,mBAAOqE,KAAP;AACD,WAJD,MAKK,IAAIrE,eAAerD,MAAf,IAAyB,CAA7B,EAAgC;AACrC;AACE;;AAEA,gBAAMqD,eAAe,CAAf,EAAkBlB,IAAlB,IAA0B,GAA5B,IAAsCkB,eAAe,CAAf,EAAkBlB,IAAlB,IAA0B,GAApE,EACA;AACE,qBAAO,KAAKwM,QAAL,CAAetL,eAAe,CAAf,CAAf,CAAP;AACD;;AAED,gBAAIA,eAAe,CAAf,EAAkBlB,IAAlB,IAA0B,GAA9B,EACA;AACE,qBAAO,KAAKwM,QAAL,CAAetL,eAAe,CAAf,CAAf,IAAqC,KAAKsL,QAAL,CAAetL,eAAe,CAAf,CAAf,CAA5C;AACD,aAHD,MAIK,IAAIA,eAAe,CAAf,EAAkBlB,IAAlB,IAA0B,GAA9B,EACL;AACE,qBAAO,KAAKwM,QAAL,CAAetL,eAAe,CAAf,CAAf,IAAqC,KAAKsL,QAAL,CAAetL,eAAe,CAAf,CAAf,CAA5C;AACD,aAHI,MAIA,IAAIA,eAAe,CAAf,EAAkBlB,IAAlB,IAA0B,GAA9B,EACL;AACE,qBAAO,KAAKwM,QAAL,CAAetL,eAAe,CAAf,CAAf,IAAqC,KAAKsL,QAAL,CAAetL,eAAe,CAAf,CAAf,CAA5C;AACD,aAHI,MAIA,IAAIA,eAAe,CAAf,EAAkBlB,IAAlB,IAA0B,GAA9B,EACL;AACE,qBAAO,KAAKwM,QAAL,CAAetL,eAAe,CAAf,CAAf,IAAqC,KAAKsL,QAAL,CAAetL,eAAe,CAAf,CAAf,CAA5C;AACD,aAHI,MAIA,IAAIA,eAAe,CAAf,EAAkBlB,IAAlB,IAA0B,GAA9B,EACL;AACE,qBAAOwF,KAAKC,GAAL,CAAU,KAAK+G,QAAL,CAAetL,eAAe,CAAf,CAAf,CAAV,EAA8C,KAAKsL,QAAL,CAAetL,eAAe,CAAf,CAAf,CAA9C,CAAP;AACD,aAHI,MAKL;AACE,oBAAM,IAAI7B,KAAJ,CAAU,qDAAqDqG,KAAKC,SAAL,CAAgBzE,cAAhB,CAA/D,CAAN;AACD;AACF,WAjCI,MAkCA,IAAIA,eAAerD,MAAf,IAAyB,CAA7B,EAAgC;AACrC;AACE,gBAAIqD,eAAe,CAAf,EAAkBlB,IAAlB,IAA0B,GAA9B,EACA;AACE,qBAAO,KAAKwM,QAAL,CAAetL,eAAe,CAAf,CAAf,CAAP;AACD;AACD,gBAAIA,eAAe,CAAf,EAAkBlB,IAAlB,IAA0B,GAA9B,EACA;AACE,qBAAO,CAAC,CAAD,GAAK,KAAKwM,QAAL,CAAetL,eAAe,CAAf,CAAf,CAAZ;AACD,aAHD,MAKA;AACE,oBAAM,IAAI7B,KAAJ,CAAU,yFAAyFqG,KAAKC,SAAL,CAAgBzE,cAAhB,CAAnG,CAAN;AACD;AACF;;AAGD,cAAM,IAAI7B,KAAJ,CAAU,sCAAsCqG,KAAKC,SAAL,CAAgBzE,cAAhB,CAAhD,CAAN;AACD,OA7DH,MA8DO;AACL;AACE,cAAIkE,mBAAmBpF,IAAnB,CAAwBqF,WAAxB,GAAsCtB,OAAtC,CAA+C,SAA/C,IAA6D,CAAC,CAAlE,EACA;AACE,mBAAO6B,SAAUR,mBAAmBnF,eAA7B,CAAP;AACD;AACD,gBAAM,IAAIZ,KAAJ,CAAU,gCAAgC+F,mBAAmBpF,IAA7D,CAAN;AACA,iBAAO,IAAP;AACD;AACJ;;;uCAEmBqM,c,EAAgB;AAClC,UAAIA,kBAAkB,GAAtB,EAA4B,OAAO,IAAP;AAC5B,UAAIA,kBAAkB,GAAtB,EAA4B,OAAO,KAAP;AAC5B,UAAIA,kBAAkB,GAAtB,EAA4B,OAAO,KAAP;AAC5B,UAAIA,kBAAkB,GAAtB,EAA4B,OAAO,KAAP;AAC7B;;;;;;AAGH5J,OAAOC,OAAP,GAAiB6J,eAAjB,C;;;;;;;;;;;AChJA;;;;;;;;IAEME,c;AACJ,0BAAa/M,KAAb,EAAoB;AAAA;;AAClB,SAAKA,KAAL,GAAaA,KAAb;AACD;;;;6BACSyF,Q,EAAU;AAClB,WAAKzF,KAAL,GAAayF,QAAb;AACD;;;4BAEQ6G,e,EACT;AACM,UAAIC,KAAK,EAAT;AACAA,SAAG3N,IAAH,GAAU0N,gBAAgBhM,IAA1B;AACAiM,SAAG1G,KAAH,GAAW,KAAKiH,QAAL,CAAeR,eAAf,EAAiCU,IAAjC,EAAX;AACA,UAAIxL,iBAAiB8K,gBAAgB9K,cAArC;AACA,cAAQ8K,gBAAgBhM,IAAxB;;AAGI,aAAK,OAAL;AACI,iBAAO,EAAE1B,MAAO0N,gBAAgB5H,sBAAzB,EAAiDmB,OAAO,KAAKiH,QAAL,CAAeR,eAAf,CAAxD,EAA0FG,WAAW,0BAArG,EAAP;;AAEJ,aAAK,UAAL;AACIF,aAAG3N,IAAH,GAAU,UAAV;AACA2N,aAAG/C,QAAH,GAAc,EAAd;AACA,eAAK,IAAIzB,IAAI,CAAb,EAAgBA,IAAIvG,eAAerD,MAAnC,EAA2C4J,GAA3C,EACA;AACE,gBAAIkF,iBAAiB,KAAKtJ,OAAL,CAAcnC,eAAgBuG,CAAhB,CAAd,CAArB;AACAwE,eAAG/C,QAAH,CAAYnL,IAAZ,CAAkB4O,cAAlB;AACD;AACD,iBAAOV,GAAG/C,QAAV;AACA;;AAEJ,aAAK,SAAL;;AAEI,eAAK0D,UAAL,GAAkBX,EAAlB;AACAA,aAAG/C,QAAH,GAAc,EAAd;AACA;AACA+C,aAAG3N,IAAH,GAAU,KAAKkO,QAAL,CAAetL,eAAgB,CAAhB,CAAf,CAAV;AACA,cAAI2L,qBAAqB,KAAKC,aAAL,CAAoB5L,eAAgB,CAAhB,CAApB,CAAzB;;AAEA,cAAI2L,kBAAJ,EACA;AACEZ,eAAGpC,UAAH,GAAgBgD,kBAAhB;AACD;;AAED3L,2BAAiB,KAAK6L,gCAAL,CAAuC7L,cAAvC,CAAjB;;AAEA,eAAK,IAAIuG,IAAI,CAAb,EAAgBA,IAAIvG,eAAerD,MAAf,GAAwB,CAA5C,EAA+C4J,GAA/C,EAAqD;AACrD;AACE,gBAAIuF,QAAQ,KAAK3J,OAAL,CAAcnC,eAAgBuG,CAAhB,CAAd,CAAZ;AACA;AACA;AACA;AACA,gBAAIwF,MAAMC,OAAN,CAAeF,KAAf,CAAJ,EACA;AACIf,iBAAG/C,QAAH,GAAc+C,GAAG/C,QAAH,CAAYiE,MAAZ,CAAoBH,KAApB,CAAd;AACH,aAHD,MAKA;AACIf,iBAAG/C,QAAH,CAAYnL,IAAZ,CAAkBiP,KAAlB;AACH;AACF;;AAGD;;AAEJ,aAAK,OAAL;AAAc;AACVf,aAAG3N,IAAH,GAAU0N,gBAAgB/L,eAA1B;AApDR;AAsDA,aAAOgM,EAAP;AACL;;AAED;;;;qDACkCmB,+B,EAAkC;AAClE,UAAIC,qBAAqB,EAAzB;AACA,UAAIC,2BAA2B,EAA/B;AAFkE;AAAA;AAAA;;AAAA;AAGlE,6BAAmBF,+BAAnB,8HAAoD;AAAA,cAA3CvN,MAA2C;;AAClD,cAAIA,OAAOE,WAAP,CAAmBzB,IAAnB,IAA2B,OAA/B,EACA;AACE,gBAAIgP,yBAAyBzP,MAAzB,GAAkC,CAAtC,EAA0C;AAC1C;AACE,oBAAI0P,6BAA4B,KAAKC,uBAAL,CAA8BF,wBAA9B,CAAhC;AACAD,mCAAmBtP,IAAnB,CAAyBwP,0BAAzB;AACAD,2CAA2B,EAA3B;AACAD,mCAAmBtP,IAAnB,CAAyB8B,MAAzB;AACD,eAND,MAQA;AACEwN,iCAAmBtP,IAAnB,CAAyB8B,MAAzB;AACD;AACF,WAbD,MAcK;AACL;;AAEGyN,0CAA4BzN,OAAOI,eAAnC;AAEF;AACF;AAxBiE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AA0BlE,UAAIqN,yBAAyBzP,MAAzB,GAAkC,CAAtC,EACA;AACE,YAAI0P,4BAA4B,KAAKC,uBAAL,CAA8BF,wBAA9B,CAAhC;AACAD,2BAAmBtP,IAAnB,CAAyBwP,yBAAzB;AACD;;AAED,aAAOF,kBAAP;AACD;;;4CAEwBI,Y,EAAc;AACrC,UAAIC,YAAY,oBAAW,IAAX,EAAiB,UAAjB,EAA6BD,aAAa5P,MAA1C,EAAkD4P,YAAlD,CAAhB;AACA,aAAOC,SAAP;AACD;;AAED;;;;kCACeC,c,EAAiB;;AAE9B,UAAIA,eAAe3N,IAAf,IAAuB,cAA3B,EACA;AACE;AACA;AACA;AACA;AACA,YAAI4N,OAAO,EAAX;AACA,YAAID,eAAezM,cAAf,CAA8B,CAA9B,EAAiCnB,WAAjC,CAA6CzB,IAA7C,IAAqD,OAAzD,EAAmE;AACnE;AACE,gBAAIA,OAAO,KAAKkO,QAAL,CAAemB,eAAezM,cAAf,CAA8B,CAA9B,CAAf,CAAX;AACA,gBAAI2M,eAAe,EAAnB;AACA,iBAAK,IAAIC,sBAAsB,CAA/B,EAAkCA,sBAAsBH,eAAezM,cAAf,CAA8BrD,MAA9B,GAAuC,CAA/F,EAAkGiQ,qBAAlG,EACA;AACED,8BAAgB,KAAKrB,QAAL,CAAemB,eAAezM,cAAf,CAA+B4M,mBAA/B,CAAf,CAAhB;AACA,kBAAIC,UAAUD,sBAAsBH,eAAezM,cAAf,CAA8BrD,MAA9B,GAAuC,CAA3E;AACA,kBAAIkQ,OAAJ,EAAcF,gBAAgB,GAAhB;AACf;AACDD,iBAAMtP,IAAN,IAAeuP,YAAf;AACA,mBAAOD,IAAP;AACD,WAZD,MAaK,IAAGD,eAAezM,cAAf,CAA8B,CAA9B,EAAiClB,IAAjC,IAAyC,cAA5C,EAA4D;AACjE;AACE4N,mBAAO,KAAKd,aAAL,CAAoBa,eAAezM,cAAf,CAA8B,CAA9B,CAApB,CAAP;AACA,gBAAI5C,QAAO,KAAKkO,QAAL,CAAemB,eAAezM,cAAf,CAA8B,CAA9B,CAAf,CAAX;AACA,gBAAI6I,MAAM,KAAKyC,QAAL,CAAemB,eAAezM,cAAf,CAA8B,CAA9B,CAAf,CAAV;AACA0M,iBAAMtP,KAAN,IAAeyL,GAAf;AACA,mBAAO6D,IAAP;AACD;AACF,OA5BD,MA6BK,IAAGD,eAAezM,cAAf,CAA8B,CAA9B,EAAiClB,IAAjC,IAAyC,cAA5C,EACL;AACE,YAAIgO,aAAa,KAAKlB,aAAL,CAAoBa,eAAezM,cAAf,CAA8B,CAA9B,CAApB,CAAjB;AACA,eAAO8M,UAAP;AACD;AACD,aAAO,IAAP;AACD;;;6BAES5I,kB,EAAoB;AAC5B,UAAGA,mBAAmBrF,WAAnB,CAA+BzB,IAA/B,IAAuC,aAA1C,EACA;AACI,YAAI4C,iBAAiBkE,mBAAmBlE,cAAxC;;AAEA,YAAIqE,QAAQ,KAAZ,CAHJ,CAGuB;;AAEnB,YAAIH,mBAAmBpF,IAAnB,IAA2B,SAA/B,EACA;AACE;AACA,cAAIiO,aAAY,KAAKzB,QAAL,CAAetL,eAAe,CAAf,CAAf,CAAhB;AACA,iBAAO+M,UAAP;AACD;;AAED,YAAI7I,mBAAmBpF,IAAnB,IAA2B,UAA/B,EACA;AACE,cAAIiO,cAAY,UAAhB;AACA,iBAAOA,WAAP;AACD;;AAED,YAAI7I,mBAAmBpF,IAAnB,IAA2B,SAA3B,IAAwCoF,mBAAmBpF,IAAnB,IAA2B,cAAvE,EACA;AACE,cAAIiO,SAAJ;AACA;AACA,cAAI/M,eAAe,CAAf,EAAkBlB,IAAlB,IAA0B,cAA9B,EACA;AACEiO,wBAAY,KAAKzB,QAAL,CAAetL,eAAe,CAAf,CAAf,CAAZ;AACA,mBAAO+M,SAAP;AACD;AACDA,sBAAY,KAAKzB,QAAL,CAAetL,eAAe,CAAf,CAAf,CAAZ;AACA,iBAAO+M,SAAP;AACD;;AAED,YAAI7I,mBAAmBpF,IAAnB,IAA2B,UAA/B,EACA;AACI,iBAAO,KAAKwM,QAAL,CAAetL,eAAe,CAAf,CAAf,CAAP,CADJ,CAC+C;AAC9C;;AAED,YAAIkE,mBAAmBpF,IAAnB,IAA2B,SAA/B,EACA;AACE,cAAIkO,gBAAgB,EAApB;AADF;AAAA;AAAA;;AAAA;AAEE,kCAAe9I,mBAAmBlE,cAAlC,mIACA;AAAA,kBADQI,GACR;;AACE,kBAAIA,IAAItB,IAAJ,IAAY,aAAZ,IAA6BsB,IAAItB,IAAJ,IAAY,cAA7C,EAA6D;AAC7DkO,+BAAiB,KAAK1B,QAAL,CAAelL,GAAf,CAAjB;AACD;AANH;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAOI,iBAAO4M,aAAP;AACH;;AAED,YAAI9I,mBAAmBpF,IAAnB,IAA2B,UAA/B,EACA;AACE,cAAImO,gBAAgB,EAApB;AADF;AAAA;AAAA;;AAAA;AAEE,kCAAe/I,mBAAmBlE,cAAlC,mIACA;AAAA,kBADQI,GACR;;AACE,kBAAMA,IAAItB,IAAJ,IAAY,UAAd,IAAiCsB,IAAItB,IAAJ,IAAY,OAAjD;AACE;AACA;AACA,oBAAIsB,IAAItB,IAAJ,IAAY,OAAhB,EACA;AACEmO,mCAAiB,MAAM,KAAK3B,QAAL,CAAelL,GAAf,CAAvB;AACD,iBAHD,MAKA;AACE6M,mCAAiB,KAAK3B,QAAL,CAAelL,GAAf,CAAjB;AACD;AACJ;AAfH;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAgBE,iBAAO6M,aAAP;AACD;;AAED,cAAM,IAAI9O,KAAJ,CAAU,yDAAyD+F,mBAAmBpF,IAA5E,GAAmF,GAAnF,GAAyF0F,KAAKC,SAAL,CAAgBzE,cAAhB,CAAnG,CAAN;AACD,OArEH,MAsEO;AACL;AACE,cAAIkE,mBAAmBpF,IAAnB,CAAwBqF,WAAxB,GAAsCtB,OAAtC,CAA+C,MAA/C,IAA0D,CAAC,CAA/D,EACA;AACE,mBAAO,IAAP;AACD;AACD,cAAIqB,mBAAmBpF,IAAnB,CAAwBqF,WAAxB,GAAsCtB,OAAtC,CAA+C,UAA/C,IAA8D,CAAC,CAAnE,EACA;AACE,mBAAOqB,mBAAmBnF,eAA1B;AACD;AACD,cAAImF,mBAAmBpF,IAAnB,CAAwBqF,WAAxB,GAAsCtB,OAAtC,CAA+C,OAA/C,IAA2D,CAAC,CAAhE,EACA;AACE,mBAAOqB,mBAAmBnF,eAA1B;AACD;AACD,iBAAOmF,mBAAmBnF,eAA1B;AACR;AACA;AACO;AACJ;;;;;;AAGHwC,OAAOC,OAAP,GAAiB+J,cAAjB,C;;;;;;;;;;;;;ICrPM2B,mB;AACJ,+BAAa1O,KAAb,EAAoB;AAAA;;AAClB,SAAKA,KAAL,GAAaA,KAAb;AACD;;;;6BACSyF,Q,EAAU;AAClB,WAAKzF,KAAL,GAAayF,QAAb;AACD;;;4BAEQjF,O,EACT;;AAEE,UAAIA,QAAQF,IAAR,IAAgB,SAApB,EACA;AACE,eAAO,KAAKqO,8BAAL,CAAqCnO,OAArC,KAAkD,KAAKoO,uBAAL,CAA8BpO,OAA9B,CAAzD;AACD,OAHD,MAIK,IAAIA,QAAQF,IAAR,IAAgB,SAApB,EACL;AACE,eAAO,KAAKuO,6BAAL,CAAoCrO,OAApC,CAAP;AACD,OAHI,MAIA,OAAO,IAAP;AACN;;;mDAE+B8L,e,EAAkB;;AAG9C,UAAIwC,cAAgB,KAAKC,UAAL,CAAiBzC,gBAAgB9K,cAAhB,CAAgC,CAAhC,CAAjB,CAApB;AACC,UAAIwN,qBAAJ;AACD,UAAI1C,gBAAgB9K,cAAhB,CAA+BrD,MAA/B,IAAyC,CAA7C,EACA;AACE6Q,uBAAe,KAAKD,UAAL,CAAiBzC,gBAAgB9K,cAAhB,CAAgC,CAAhC,CAAjB,CAAf;AACD,OAHD,MAIK,IAAI8K,gBAAgB9K,cAAhB,CAA+BrD,MAA/B,GAAwC,CAA5C,EACL;AACE6Q,uBAAgB,KAAKD,UAAL,CAAiBzC,gBAAgB9K,cAAhB,CAAgC8K,gBAAgB9K,cAAhB,CAA+BrD,MAA/B,GAAwC,CAAxE,CAAjB,CAAhB;AACD;;AAED,aAAO2Q,eAAeE,YAAtB;AACH;;;kDAE8BxO,O,EAAS;AACtC;AACA;AACA,aAAO,IAAP;AACD;;;4CAEwB8L,e,EAAiB;AACxC,aAAO,IAAP;AACD;;;+BAGWA,e,EAAiB;;AAG3B,aAAOA,gBAAgBhM,IAAhB,IAAwB,OAA/B,EACA;;AAEE,YAAIgM,gBAAgBhM,IAAhB,IAAwB,SAA5B,EACA;AACE,cAAIgM,gBAAgB9K,cAApB,EACA;AACE,gBAAK8K,gBAAgB9K,cAAhB,CAA+B,CAA/B,EAAkClB,IAAlC,IAA0C,GAA/C,EACA;;AAEE,qBAAOgM,gBAAgB9K,cAAhB,CAA+B,CAA/B,EAAkCjB,eAAzC;AACD;AACF;AACF,SAVD,MAWK,IAAI+L,gBAAgBhM,IAAhB,IAAwB,UAA5B,EACL;;AAEE,cAAIgM,gBAAgB9K,cAApB,EACA;AACE,gBAAK8K,gBAAgB9K,cAAhB,CAA+B,CAA/B,EAAkClB,IAAlC,IAA0C,GAA/C,EACA;AACE;;AAEA,qBAAOgM,gBAAgB9K,cAAhB,CAA+B,CAA/B,EAAkCjB,eAAzC;AACD;AACF;AACF,SAZI,MAaA,IAAI+L,gBAAgBhM,IAAhB,IAAwB,cAA5B,EACL;;AAEE,cAAIgM,gBAAgB9K,cAApB,EACA;AACE,gBAAK8K,gBAAgB9K,cAAhB,CAA+B,CAA/B,EAAkClB,IAAlC,IAA0C,GAA/C,EACA;AACE,qBAAOgM,gBAAgB9K,cAAhB,CAA+B,CAA/B,EAAkCjB,eAAzC;AACD;AACF;AACF;AACD+L,0BAAkBA,gBAAgB9K,cAAhB,CAA+B,CAA/B,CAAlB;AACD;AACD,aAAO8K,gBAAgB/L,eAAvB;AACC;;;;;;AAKLwC,OAAOC,OAAP,GAAiB0L,mBAAjB,C","file":"boolius.bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/build/js\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 18);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 59d9017f3bc2b07d30af","import Nonterminal from '../nonterminal';\n\nexport default class NonterminalFactory{\n  constructor(grammarObject){\n    this.grammarObject = grammarObject;\n    this.nonterminals = [];\n    for( let grammarRule of grammarObject )\n    {\n      let nonterminal = new Nonterminal( grammarRule[0], grammarRule[1] );\n      if( grammarRule.length > 2 ) // it has an array of lookaheadTokensToAvoid\n      {\n        nonterminal.lookaheadTokensToAvoid = grammarRule[2];\n      }\n      this.nonterminals.push( nonterminal );\n    }\n  }\n\n  getNonterminals(){\n    return this.nonterminals;\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ./js/factories/nonterminalfactory.js","import Token from '../token';\n\nexport default class TokenFactory{\n   constructor( tokenDefinitions ){\n     this.tokens = [];\n     this.tokenDefinitions = tokenDefinitions;\n   }\n\n   makeTokenFromDefinition( tokenDefinition ){\n     return this.makeToken( tokenDefinition[0], tokenDefinition[1], tokenDefinition.length > 2 ? tokenDefinition[2] : false );\n   }\n    makeToken( regex, name, ignore = false )\n    {\n      var token = new Token( regex, name, 0, \"\", ignore );\n      this.tokens.push( token );\n      return token;\n    }\n\n    getTokens()\n    {\n      let IGNORE = true;\n\n      for( let tokenDefinition of this.tokenDefinitions )\n      {\n        this.makeTokenFromDefinition( tokenDefinition )\n      }\n      return this.tokens;\n\n    }\n}\n\n\n// WEBPACK FOOTER //\n// ./js/factories/tokenfactory.js","import TokenFactory from './factories/tokenfactory';\n\nexport default class Lexer{\n\n  constructor( tokenDefinitions ){\n    let tokenFactory = new TokenFactory( tokenDefinitions );\n    this.tokens = tokenFactory.getTokens();\n  }\n\n  tokenize( sentenceToTokenize ){\n    let arrayOfTokens = [];\n    var startingLetter = 0;\n    let stringToMatch = sentenceToTokenize; // want to keep original sentence for length/reference\n\n    while(  startingLetter < sentenceToTokenize.length )\n    {\n      let foundAMatchSomewhere = false;\n      for (var token of this.tokens)\n      {\n        let lengthOfMatch = 0;\n        [lengthOfMatch, arrayOfTokens, stringToMatch ] =\n        token.matchYourselfToStartOfThisStringAndAddSelfToArray( arrayOfTokens, stringToMatch, startingLetter );\n        if( lengthOfMatch > 0 )\n        {\n          foundAMatchSomewhere = true;\n          startingLetter += lengthOfMatch;\n          break; // START AT THE TOP OF OUR TOKEN LIST!!\n          // That is IMPORTANT.\n          // Some of our later tokens, like IDENT, are catch-alls that will greedily snatch up keywords like NOT\n        }\n      }\n      if(! foundAMatchSomewhere)\n      {\n        throw new Error(\"Illegal character \" + stringToMatch.charAt(0) + \" at position \" + startingLetter );\n      }\n    }\n    return arrayOfTokens;\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ./js/lexer.js","import Symbol from './symbol'\nimport Nonterminal from './nonterminal'\nimport NonterminalFactory from '../js/factories/nonterminalfactory';\n\nexport default class Parser{\n  constructor( grammarObject ){\n    let nonterminalFactory = new NonterminalFactory( grammarObject );\n    this.nonterminals = nonterminalFactory.getNonterminals();\n    this.state = {};\n  }\n\n  setState( state ) {\n    this.state = state; // generally just a lookup table for declared/initialized variables\n  }\n\n  // What does this do? Well, if there's a token of type IDENT, it's a variable.\n  // If that variable hasn't been declared, then how are we supposed to know what type it is?\n  // We'll be strongly-typed so that even a simple grammar can work effectively.\n  resolveIdentifiersToTypes( sentenceOfSymbols ){\n    let resolvedSymbols = [];\n    while( sentenceOfSymbols.length > 0 )\n    {\n      // comments might have been turned into null symbols\n      // in which case we should skip them\n      let symbol = sentenceOfSymbols.shift();\n      // we only care about tokens\n      if( symbol.constructor.name == \"Token\")\n      {\n        if( symbol.type == \"IDENT\")\n        {\n          // so now we can wrap our variable in the appropriate nonterminal type\n          if( typeof this.state[symbol._stringIMatched] == \"boolean\")\n          {\n            let nonterm = new Nonterminal( [\"IDENT\"], \"BOOLEAN\" );\n            nonterm.seriesOfSymbolsIAbsorbedAndReplaced = [ symbol ];\n            symbol = nonterm;\n          }\n          resolvedSymbols.push( symbol );\n          continue;\n        }\n        else\n        {\n          resolvedSymbols.push( symbol );\n        }\n      }\n      else\n      {\n        resolvedSymbols.push( symbol );\n      }\n    }\n    return resolvedSymbols;\n  }\n\n  getSimpleStringForSentence( sentenceOfSymbols ) {\n          let traceString = \"\";\n          for( var symbol of sentenceOfSymbols )\n          {\n            traceString += symbol.type + \" \";\n          }\n          return traceString;\n  }\n\n  parse( sentenceOfSymbols, parseTimeVisitor = null ){\n\n    sentenceOfSymbols = this.resolveIdentifiersToTypes( sentenceOfSymbols );\n    let arrayOfSymbolsMatchedBeforeMe = [];\n    let lengthOfMatch = 0;\n    let finished = false;\n    // actually, if our sentence only has one symbol, it may very well be finished already\n    if ( sentenceOfSymbols.length == 1 ) finished = true;\n    while( !finished ){\n        let madeAMatch = false;\n        //console.log(\"============\");\n        for( var nonterminal of this.nonterminals )\n        {\n\n          // we'll go through the input sentence\n          // and try to match this nonterminal to the beginning of it.\n          // if there's a match, then our nonterminal will be part of the future sentence.\n          // (replacing whatever portion it matched.)\n          // if there's no match, we want to pop a symbol off the start of the input sentence\n          // (moving it into the future sentence, since we )\n          let traceString = this.getSimpleStringForSentence( sentenceOfSymbols );\n          while( sentenceOfSymbols.length > 0 )\n          {\n//            console.log(\"USING nonterminal \" + nonterminal.toStringSimple() + \" to look at \" + traceString );\n            [lengthOfMatch, arrayOfSymbolsMatchedBeforeMe, sentenceOfSymbols ] =\n            nonterminal.matchYourselfToStartOfThisStringAndAddSelfToArray( arrayOfSymbolsMatchedBeforeMe, sentenceOfSymbols, parseTimeVisitor );\n\n            // if we matched, then the good news is, the input sentence is now changed\n            // so we don't have to worry about changing it.\n            // otherwise, we didn't match the beginning of the input sentence,\n            // so let's pop a symbol off it and try again.\n            if( lengthOfMatch == 0 )\n            {\n              arrayOfSymbolsMatchedBeforeMe.push( sentenceOfSymbols.shift() );\n              traceString = this.getSimpleStringForSentence( sentenceOfSymbols );\n            }\n            else\n            {\n              //console.log(\"MATCHED nonterminal \" + nonterminal.toStringSimple() + \" to sentence \" + traceString );\n              madeAMatch = true;\n            }\n          }\n\n          // ok, we did what we could. let's gather our processed items and hand them to the next nonterminal to process.\n          sentenceOfSymbols = arrayOfSymbolsMatchedBeforeMe.slice(0); // make sure we copy the items over and keep these two arrays discrete!\n          arrayOfSymbolsMatchedBeforeMe = [];\n          //console.log(\"sentenceOfSymbols is now \" + sentenceOfSymbols );\n          // are we done? if so, then don't bother looking at other nonterminals!\n          if( sentenceOfSymbols.length <= 1 )\n          {\n            finished == true;\n            break;\n          }\n\n          // we need to start from the top of our nonterminals if we made a match!\n          // order MATTERS.\n          if( madeAMatch ) break;\n\n        } // end of cycling through our array of nonterminals\n\n        // what if we made it through all our nonterminals and didn't make a match?\n        // error, that's what!\n        if( ! madeAMatch )\n        {\n          let stringAndPosition = this.getLastTokenDescriptionOfSymbol( sentenceOfSymbols[0] );\n          let errorString = \"\\nSyntax error:\" + stringAndPosition.string + \" at position \" + stringAndPosition.position;\n          throw new Error( errorString );\n          finished = true;\n        }\n\n        if( sentenceOfSymbols.length <= 1 )\n        {\n          finished = true;\n        }\n    }  // end of our \"while\" loop going through sentenceOfSymbols until finished == true\n\n    return sentenceOfSymbols;\n  }\n\n  getLastTokenDescriptionOfSymbol( symbol ){\n     return this.getStringAndPositionOfTokensOfSymbol( symbol.symbolsMatched[ symbol.symbolsMatched.length - 1] );\n  }\n\n  getStringAndPositionOfTokensOfSymbol( symbol, earliestPosition = 100000000 ){\n    if (symbol.constructor.name == \"Token\" )\n    {\n      return { string: symbol._stringIMatched, position: symbol.start };\n    }\n    else if (symbol.constructor.name == \"Nonterminal\" )\n    {\n      let tokenString = \"\";\n      for( let kid of symbol.symbolsMatched )\n      {\n        let stringAndPosition = this.getStringAndPositionOfTokensOfSymbol( kid, earliestPosition );\n        tokenString += stringAndPosition.string;\n        if( stringAndPosition.position < earliestPosition )\n        {\n          earliestPosition = stringAndPosition.position;\n        }\n      }\n      return { string: tokenString, position: earliestPosition };\n    }\n  }\n\n\n}\n\n\n// WEBPACK FOOTER //\n// ./js/parser.js","export default class Symbol{\n  constructor(){\n\n  }\n  get name(){\n    return this._name;\n  }\n  set name( someName ){\n    this._name = someName;\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ./js/symbol.js","//import Token from './token';\n//import Symbol from './token';\nimport Lexer from './lexer';\nimport Parser from './parser';\nimport XMLius from './xmlius';\nimport Mathius from './mathius';\nimport BooleanJSONVisitor from './visitors/booleanjsonvisitor';\nimport TokenFactory from './factories/tokenfactory';\nimport NonterminalFactory from './factories/nonterminalfactory';\n\nexport class Boolius{\n\n  constructor( tokenDefinitions, grammarObject ){\n\n    // we set the state so that the parser knows the data type of each of these variables\n    // (in this case, boolean)\n    // and later so that the visitor can evaluate each node to determine if it is true or false.\n    this.state = {\"a\":false,\"b\":true,\"c\":false,\"d\":true,\"e\":false,\"f\":true,\"g\":false,\"h\":true,\"i\":false};\n    this.visitor = new BooleanJSONVisitor( this.state );\n    // lay the groundwork for lexical analysis\n    this.lexer = new Lexer( tokenDefinitions );\n    this.parser = new Parser( grammarObject );\n    this.parser.setState( this.state );\n  }\n\n  parse( sentenceToParse ){\n    try\n    {\n      let sentenceOfTokens = this.lexer.tokenize( sentenceToParse );\n      this.parseTree = this.parser.parse( sentenceOfTokens );\n      return this.evaluateParseTree();\n    }\n    catch( e )\n    {\n      alert( e );\n    }\n  }\n\n  evaluateParseTree(){\n    let result = this.parseTree[0].visit( this.visitor );\n    return result;\n  }\n}\n//window.Boolius = Boolius;\nmodule.exports = Boolius;\n\n\n// WEBPACK FOOTER //\n// ./js/boolius.js","//import Token from './token';\n//import Symbol from './token';\nimport Lexer from './lexer';\nimport Parser from './parser';\nimport NumericVisitor from './visitors/numericvisitor';\nimport MathJSONVisitor from './visitors/mathjsonvisitor';\nimport TokenFactory from './factories/tokenfactory';\nimport NonterminalFactory from './factories/nonterminalfactory';\n\nexport default class Mathius{\n  constructor( tokenDefinitions, grammarObject ){\n\n    // we set the state so that the parser knows the data type of each of these variables\n    // (in this case, boolean)\n    // and later so that the visitor can evaluate each node to determine if it is true or false.\n    this.state = {\"a\":false,\"b\":true,\"c\":false,\"d\":true,\"e\":false,\"f\":true,\"g\":false,\"h\":true,\"i\":false};\n\n    this.visitor = new MathJSONVisitor(  this.state );\n    // lay the groundwork for lexical analysis\n    this.lexer = new Lexer( tokenDefinitions );\n    this.parser = new Parser( grammarObject );\n    this.parser.setState( this.state );\n  }\n\n\n\n  parse( sentenceToParse ){\n    try\n    {\n      let sentenceOfTokens = this.lexer.tokenize( sentenceToParse );\n      this.parseTree = this.parser.parse( sentenceOfTokens );\n      return this.evaluateParseTree();\n    }\n    catch( e )\n    {\n      console.error( \"ERROR PARSING OR EVALUATING:\" + e );\n    }\n  }\n\n  evaluateParseTree(){\n    let result = this.parseTree[0].visit( this.visitor );\n    return result;\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./js/mathius.js","import Symbol from './symbol'\n\nexport default class Nonterminal extends Symbol{\n\n    constructor( seriesOfSymbolsIMustMatch, type ){\n      super();\n      this.seriesOfSymbolsIMustMatch  = seriesOfSymbolsIMustMatch;\n      this.type                       = type;\n      this.seriesOfSymbolsIAbsorbedAndReplaced = [];\n      this.wildcardMode = false;\n      this.lookaheadTokensToAvoid = null;\n    }\n\n    toStringSimple(){\n      return this.type + \"(\" + this.seriesOfSymbolsIMustMatch.join( ' ' ) + \")\";\n    }\n\n    toString(){\n      let returnString = this.type + \" (\";\n\n      for( var symbol of this.seriesOfSymbolsIAbsorbedAndReplaced )\n      {\n        returnString += \" \" + symbol.toString();\n      }\n      return returnString;\n    }\n\n    get symbolsMatched(){\n      return this.seriesOfSymbolsIAbsorbedAndReplaced;\n    }\n\n    get length(){\n      return this.seriesOfSymbolsIAbsorbedAndReplaced.length;\n    }\n\n    visit( evaluationVisitor ) {\n      return evaluationVisitor.execute( this );\n    }\n\n    matchYourselfToStartOfThisStringAndAddSelfToArray( arrayOfSymbolsMatchedBeforeMe, sentenceOfSymbolsToMatch, parseTimeVisitor ){\n\n      // clone it so we don't destroy the original in case we're only a partial match\n\n      let sentenceOfSymbolsToMatchClone = sentenceOfSymbolsToMatch.slice(0);\n\n      // same with ours\n\n      let seriesOfSymbolsIMustMatchClone = this.seriesOfSymbolsIMustMatch.slice(0);\n\n      this.seriesOfSymbolsIAbsorbedAndReplaced = [];\n\n      let done = false;\n\n      // in case of wildcard, we need to know what the previous symbol was\n\n      let symbolThatBreaksWildcard = null;\n\n      while( seriesOfSymbolsIMustMatchClone.length > 0 )\n      {\n        let mySymbol = seriesOfSymbolsIMustMatchClone.shift();\n        let theirSymbol = sentenceOfSymbolsToMatchClone.shift();\n\n        // if they ran out of symbols, then we're obviously not a match. UNLESS we were in wildcard mode.\n        if( ! theirSymbol )\n        {\n            this.seriesOfSymbolsIAbsorbedAndReplaced = [];\n            return [ 0, arrayOfSymbolsMatchedBeforeMe, sentenceOfSymbolsToMatch ];\n        }\n\n\n\n        if( mySymbol == \"WILDCARD\" )\n        {\n          this.wildcardMode = true;\n          symbolThatBreaksWildcard = seriesOfSymbolsIMustMatchClone.shift();\n          while( theirSymbol.type != symbolThatBreaksWildcard )\n          {\n            this.seriesOfSymbolsIAbsorbedAndReplaced.push( theirSymbol );\n\n            if( sentenceOfSymbolsToMatchClone.length == 0 ) // they ran out of symbols in their sentence!\n            {\n              if( seriesOfSymbolsIMustMatchClone.length == 0 ) // that wildcard was my last character\n              {\n                arrayOfSymbolsMatchedBeforeMe.push( this.getFrozenClone() );\n                return [ this.length, arrayOfSymbolsMatchedBeforeMe, sentenceOfSymbolsToMatchClone ];\n              }\n              else // failure -- we had more to match but they ran out first\n              {\n                this.seriesOfSymbolsIAbsorbedAndReplaced = [];\n                return [ 0, arrayOfSymbolsMatchedBeforeMe, sentenceOfSymbolsToMatch ];\n              }\n            }\n            else\n            {\n              theirSymbol = sentenceOfSymbolsToMatchClone.shift();\n\n            }\n          } //end of tight loop inside wildcard mode, but still in wildcard mode\n\n          // absorb the one that got us out of the wildcard\n          // i.e., it matched the symbol of ours that follows (and thus ends) the wildcard\n\n          this.seriesOfSymbolsIAbsorbedAndReplaced.push( theirSymbol );\n\n          // we made it through!\n          // if that was the last one, then we should skip the rest of the matching and go right to success\n          // if not, keep the process going -- get a new symbol from them\n          if( seriesOfSymbolsIMustMatchClone.length == 0 ) // we don't have any more\n          {\n            done = true;\n          }\n          else if( sentenceOfSymbolsToMatchClone.length > 0 ) // we have more, and they have more things that need matching\n          {\n            theirSymbol = sentenceOfSymbolsToMatchClone.shift();\n            // but if our wildcard was our last character, then we should leave\n          }\n          else // we have more, but they don't!\n          {\n            this.seriesOfSymbolsIAbsorbedAndReplaced = [];\n            return [ 0, arrayOfSymbolsMatchedBeforeMe, sentenceOfSymbolsToMatch ];\n          }\n        } // end of wildcard loop\n\n        if (!done )\n        {\n          // do they match? i.e., the next character in the sentence -- does it match the next symbol in my internal list?\n          if( theirSymbol.type != mySymbol )\n          {\n            return [ 0, arrayOfSymbolsMatchedBeforeMe, sentenceOfSymbolsToMatch ];\n          }\n          else\n          {\n            this.seriesOfSymbolsIAbsorbedAndReplaced.push( theirSymbol );\n          }\n        }\n      }// bottom of seriesOfSymbolsIMustMatchClone.length loop\n\n      // we made it through -- matched everything we needed to -- but maybe there's a problem after all...\n      // now, there's an edge case -- good for operator precedence enforcement\n      // -- the lookahead tokens.\n      // maybe we matched everything we needed, and that's great,\n      // but maybe the next token in the sentence is a dealbreaker!\n      // for example, 1 + 2 * 3\n      // if we're NUMERIC + NUMERIC, we'll find a match\n      // but that is wrong! because the next token *after* our possible match is a *\n      // and that has higher precedence than +\n\n      if( this.lookaheadTokensToAvoid )\n      {\n        if( sentenceOfSymbolsToMatchClone.length > 0 )\n        {\n          let theirNextSymbol = sentenceOfSymbolsToMatchClone[0];\n          if( this.lookaheadTokensToAvoid.indexOf( theirNextSymbol.type ) > -1 )\n          {\n            return [ 0, arrayOfSymbolsMatchedBeforeMe, sentenceOfSymbolsToMatch ];\n          }\n        }\n      }\n      // we made it here! must be a basically perfect match.\n      // but let's see if there's a context stack for this parser\n      // e.g., an XML parser keeps a stack of open nodes\n      // so that when you hit a closing tag for a node\n      // the parser can know if it's the most recently opened tag\n      if( ! parseTimeVisitor || parseTimeVisitor.execute( this ) )\n      {\n        arrayOfSymbolsMatchedBeforeMe.push( this.getFrozenClone() );\n        return [ this.length, arrayOfSymbolsMatchedBeforeMe, sentenceOfSymbolsToMatchClone ];\n      }\n      else\n      {\n        return [ 0, arrayOfSymbolsMatchedBeforeMe, sentenceOfSymbolsToMatch ];\n      }\n    }\n\n    getFrozenClone(){\n\n      let frozenClone = new Nonterminal( this.seriesOfSymbolsIMustMatch, this.type );\n\n      frozenClone.seriesOfSymbolsIAbsorbedAndReplaced = this.seriesOfSymbolsIAbsorbedAndReplaced;\n\n      return frozenClone;\n    }\n\n}\n\n\n// WEBPACK FOOTER //\n// ./js/nonterminal.js","import Symbol from './symbol'\n\nexport default class Token extends Symbol{\n\n  /***\n   * We are one of the two types of Symbol this parser deals with:\n   * Tokens and Nonterminals.\n   * A Token is basically a Symbol that contains one or more string characters.\n   * A Nonterminal is basically a Symbol that contains one or more Symbols\n   * (each of which can be either a Token or a Nonterminal).\n   *\n   * First argument will be a regex that will match some of the raw input stream.\n   * Second argument will be the internal representation I will use for myself\n   * (a string).\n   *\n   */\n  constructor( regexOfThingsIMustMatch, type, leng, stringIActuallyMatched, ignore, startIndex = -1 ){\n    super();\n    this.regexOfThingsIMustMatch = regexOfThingsIMustMatch;\n    this._type = type;\n    this.start = startIndex;\n    this._length = leng ? leng : 0;\n    this._stringIMatched = stringIActuallyMatched;\n    this._ignore = ignore;\n  }\n\n  get type(){\n    return this._type;\n  }\n\n  toStringSimple(){\n      return \" \" +  this._type + \" \" ;\n  }\n\n  get length(){\n    return this._length;\n  }\n\n  visit( evaluationVisitor ) {\n    return evaluationVisitor.execute( this );\n  }\n\n  matchYourselfToStartOfThisStringAndAddSelfToArray( symbolArray, stringToMatch, startingIndex ){\n      this._length = 0;\n      let match = this.regexOfThingsIMustMatch.exec( stringToMatch );\n      if( match != null && match.index == 0 ){\n        this._length = match[0].length;\n        // a frozen clone to record this moment,\n        // so that our data can go on to be reused without breaking things\n        let frozenToken = new Token( this.regexOfThingsIMustMatch, this.type, this._length,  match[0], this._ignore, startingIndex );\n        if( !this._ignore) symbolArray.push( frozenToken );\n        stringToMatch = stringToMatch.substring( this.length );\n      }\n      return [ this._length, symbolArray, stringToMatch ];\n  }\n\n  toString(){\n    return this.type + \"(\" + this.regexOfThingsIMustMatch.toString() + \")<\" + this._stringIMatched + \".\" + this.start + \">\";\n  }\n\n}\n\n\n\n\n// WEBPACK FOOTER //\n// ./js/token.js","import BooleanVisitor from './booleanvisitor'\nimport NumericVisitor from './numericvisitor'\n\nclass EvaluationVisitor{\n  constructor( state ){\n    this.state = state;\n    this.booleanVisitor = new BooleanVisitor( state );\n    this.numericVisitor = new NumericVisitor( state );\n  }\n\n  setState( newstate ){\n    this.state = newstate;\n    this.booleanVisitor.setState( newstate );\n    this.numericVisitor.setState( newstate );\n  }\n\n  execute( nonterminalOrToken ) {\n    if(nonterminalOrToken.constructor.name == \"Nonterminal\" )\n    {\n      if( nonterminalOrToken.type == \"BOOLEAN\")\n        return this.booleanVisitor.execute( nonterminalOrToken );\n      if( nonterminalOrToken.type == \"NUMERIC\")\n        return this.numericVisitor.execute( nonterminalOrToken );\n    }\n    else // it's a token\n    {\n      if( nonterminalOrToken.type.toUpperCase().indexOf( \"TRUE\" ) > -1 )\n      {\n        return true;\n      }\n      if( nonterminalOrToken.type.toUpperCase().indexOf( \"FALSE\" ) > -1 )\n      {\n        return false;\n      }\n      throw new Error(\"nonterminalOrToken.type is \" + nonterminalOrToken.type );\n      return null;\n    }\n  }\n}\n\nmodule.exports = EvaluationVisitor;\n\n\n// WEBPACK FOOTER //\n// ./js/visitors/evaluationvisitor.js","import EvaluationVisitor from './evaluationvisitor';\n\nclass NumericVisitor{\n  constructor( state ){\n    this.state = state;\n  }\n\n  setState( newstate ){\n    this.state = newstate;\n  }\n  execute( nonterminalOrToken ){\n    if(nonterminalOrToken.constructor.name == \"Nonterminal\" )\n    {\n        let symbolsMatched = nonterminalOrToken.seriesOfSymbolsIAbsorbedAndReplaced;\n        let value = \"FOO\"; // declare this and, hey, initialize it with something we'll notice if there's an error.\n        if( symbolsMatched.length == 1 ) // we're a nonterminal that absorbed one other thing\n        {\n          value = symbolsMatched[0].visit( this );\n          return value;\n        }\n        else if( symbolsMatched.length == 3 )// we're a boolean comprising an operator and two operands\n        {\n          // or maybe we're just a numeric wrapped in parens!\n\n          if( ( symbolsMatched[0].type == \"(\") && ( symbolsMatched[2].type == \")\") )\n          {\n            return symbolsMatched[1].visit( this );\n          }\n\n\n          if( symbolsMatched[1].type == \"+\")\n          {\n            return symbolsMatched[0].visit( this ) + symbolsMatched[2].visit( this );\n          }\n          else if( symbolsMatched[1].type == \"-\")\n          {\n            return symbolsMatched[0].visit( this ) - symbolsMatched[2].visit( this );\n          }\n          else if( symbolsMatched[1].type == \"*\")\n          {\n            return symbolsMatched[0].visit( this ) * symbolsMatched[2].visit( this );\n          }\n          else if( symbolsMatched[1].type == \"/\")\n          {\n            return symbolsMatched[0].visit( this ) / symbolsMatched[2].visit( this );\n          }\n          else if( symbolsMatched[1].type == \"^\")\n          {\n            return Math.pow( symbolsMatched[0].visit( this ), symbolsMatched[2].visit( this ));\n          }\n          else\n          {\n            throw new Error(\"WE HAVE 3 SYMBOLS BUT I DON'T KNOW WHAT THIS IS:\" + JSON.stringify( symbolsMatched ));\n          }\n        }\n        else if( symbolsMatched.length == 2 )// we're a boolean with one operator -- probably a not\n        {\n          if( symbolsMatched[0].type == \"+\")\n          {\n            return symbolsMatched[1].visit( this );\n          }\n          if( symbolsMatched[0].type == \"-\")\n          {\n            return -1 * symbolsMatched[1].visit( this );\n          }\n          else\n          {\n            throw new Error(\"IN NUMERICVISITOR, DON'T KNOW WHAT THE OPERATOR OF THIS 2-ELEMENT SYMBOLSMATCHED IS:\" + JSON.stringify( symbolsMatched ));\n          }\n        }\n\n\n        throw new Error(\"UNKNOWN LENGTH OF SYMBOLSMATCHED:\" + JSON.stringify( symbolsMatched ));\n      }\n      else // it's a token\n      {\n        if( nonterminalOrToken.type.toUpperCase().indexOf( \"NUM_LIT\" ) > -1 )\n        {\n          return parseInt( nonterminalOrToken._stringIMatched );\n        }\n        throw new Error(\"nonterminalOrToken.type is \" + nonterminalOrToken.type );\n        return null;\n      }\n  }\n}\n\nmodule.exports = NumericVisitor;\n\n\n// WEBPACK FOOTER //\n// ./js/visitors/numericvisitor.js","//import Token from './token';\n//import Symbol from './token';\nimport Lexer from './lexer';\nimport Parser from './parser';\nimport XMLParseTimeVisitor from './visitors/xmlparsetimevisitor';\nimport XMLJSONVisitor from './visitors/xmljsonvisitor';\nimport TokenFactory from './factories/tokenfactory';\nimport NonterminalFactory from './factories/nonterminalfactory';\n\nexport default class XMLius{\n  constructor( tokenDefinitions, grammarObject ){\n\n\n\n    // we set the state so that the parser knows the data type of each of these variables\n    // (in this case, boolean)\n    // and later so that the visitor can evaluate each node to determine if it is true or false.\n    this.state = {};\n\n    this.xmlParseTimeVisitor = new XMLParseTimeVisitor();\n\n    this.visitor = new XMLJSONVisitor(  this.state );\n    // lay the groundwork for lexical analysis\n    this.lexer = new Lexer( tokenDefinitions );\n    this.parser = new Parser( grammarObject );\n    this.parser.setState( this.state );\n  }\n\n  parse( sentenceToParse ){\n    try\n    {\n      let sentenceOfTokens = this.lexer.tokenize( sentenceToParse );\n      this.parser.setState( this.state );\n      this.parseTree = this.parser.parse( sentenceOfTokens, this.xmlParseTimeVisitor );\n      return this.evaluateParseTree();\n    }\n    catch( e )\n    {\n      console.error( \"ERROR PARSING OR EVALUATING:\" + e );\n    }\n  }\n\n  evaluateParseTree(){\n    let result = this.parseTree[0].visit( this.visitor );\n    return result;\n  }\n}\n\n\n\n\n// WEBPACK FOOTER //\n// ./js/xmlius.js","\nimport Boolius from './boolius'; // which in turn imports all the classes it depends upon\nimport XMLius from './xmlius';\nimport Mathius from './mathius';\n\nwindow.onload = function(){\n    d3.select('#modeSelect').on('change', function(e){\n        var selectedMode = d3.select('#modeSelect').node().value.toLowerCase();\n        changeMode( selectedMode );\n    });\n\n\n    function changeMode( newMode ){\n        if( newMode.indexOf( 'arithmetic' ) > -1 )\n        {\n            // the user wants to look at arithmetic expressions.\n            // is boolius already loaded?\n            if(  !evaluator || evaluator.constructor.name != \"Mathius\" )\n            {\n                var grammarObject = [\n                    [  [\"NUMERIC\", \"^\", \"NUMERIC\" ], \"NUMERIC\" ],\n                    [  [\"NUMERIC\", \"*\", \"NUMERIC\" ], \"NUMERIC\" ],\n                    [  [\"NUMERIC\", \"+\", \"NUMERIC\" ], \"NUMERIC\", [\"*\", \"/\", \"^\"] ],\n                    [  [\"NUMERIC\", \"-\", \"NUMERIC\" ], \"NUMERIC\", [\"*\", \"/\", \"^\"] ],\n                    [  [\"NUM_LIT\" ], \"NUMERIC\" ],\n                    [  [\"(\", \"NUMERIC\", \")\" ], \"NUMERIC\" ]\n                ];\n\n                let IGNORE = true;\n\n                let tokenDefinitions = [\n                    [ /\\s+/, \"\", IGNORE ], // ignore whitespace\n                    [ /\\^/, \"^\" ], // this is the escaped form of ^\n                    [ /\\(/, \"(\" ],\n                    [ /\\)/, \")\" ],\n                    [ /\\+/, \"+\" ],\n                    [ /-/, \"-\" ],\n                    [ /\\*/, \"*\" ],\n                    [ /\\//, \"/\" ],\n                    [ /[-+]?[0-9]*\\.?[0-9]+/, \"NUM_LIT\" ],\n                    [ /[a-zA-Z]+/, \"IDENT\" ],\n                    [ /.+/, \"DIRTYTEXT\"]\n                ];\n                makeEvaluatorAndInitialize( new Mathius( tokenDefinitions, grammarObject ), \"1 + 2 ^ (5 - 2) * 3\",\n                \"Click operators to expand or collapse.\" );\n            }\n        }\n        else if( newMode.indexOf( 'boolean' ) > -1 )\n        {\n            // the user wants to look at boolean expressions.\n            // is boolius already loaded?\n            if(  !evaluator || evaluator.constructor.name != \"Boolius\" )\n            {\n                var grammarObject = [\n                    [  [\"TRUE\" ], \"BOOLEAN\" ],\n                    [  [\"FALSE\" ], \"BOOLEAN\" ],\n                    [  [\"!\", \"BOOLEAN\" ], \"BOOLEAN\" ],\n                    [  [\"BOOLEAN\", \"&\", \"BOOLEAN\" ], \"BOOLEAN\" ],\n                    [  [\"BOOLEAN\", \"|\", \"BOOLEAN\" ], \"BOOLEAN\" ],\n                    [  [\"(\", \"BOOLEAN\", \")\" ], \"BOOLEAN\" ]\n                ];\n\n                let IGNORE = true;\n\n                let tokenDefinitions = [\n                    [ /\\s+/, \"\", IGNORE ], // ignore whitespace\n                    [ /&&/, \"&\" ],\n                    [ /AND/i, \"&\" ],\n                    [ /\\|\\|/, \"|\" ], // this is the escaped form of ||\n                    [ /XOR/i, \"^\" ],\n                    [ /OR/i, \"|\" ],\n                    [ /\\^/, \"^\" ], // this is the escaped form of ^\n                    [ /\\!/, \"!\" ], // this is the escaped form of !\n                    [ /NOT/i, \"!\" ],\n                    [ /\\(/, \"(\" ],\n                    [ /\\)/, \")\" ],\n                    [ /(true)(?![a-zA-Z0-9])/i, \"TRUE\" ],\n                    [ /(false)(?![a-zA-Z0-9])/i, \"FALSE\" ],\n                    [ /[a-zA-Z]+/, \"IDENT\" ],\n                    [ /.+/, \"DIRTYTEXT\"]\n                ];\n                makeEvaluatorAndInitialize( new Boolius( tokenDefinitions, grammarObject ), \"((d && c)) || (!b && a) && (!d || !a) && (!c || !b)\",\n                \"Click operators to expand or collapse. Click leaf nodes to toggle true/false.\" );\n            }\n        }\n        else if( newMode.indexOf( 'xml' ) > -1 )\n        {\n            // the user wants to look at boolean expressions.\n            // is boolius already loaded?\n            if(  !evaluator || evaluator.constructor.name != \"XMLius\" )\n            {\n                let grammarObject = [\n                    [  [\"OPENCOMMENT\", \"WILDCARD\", \"CLOSECOMMENT\" ], \"COMMENT\" ],\n                    // comments will be engulfed by the text of a node\n                    // and ignored when the node is asked for its text as a string\n                    [  [\"COMMENT\"], \"NODETEXT\" ],\n                    [  [\"<\", \"/\", \"IDENT\", \">\" ], \"CLOSETAG\" ],\n                    [  [\"<\", \"IDENT\", \">\" ], \"OPENTAG\" ],\n                    [  [\"<\", \"IDENT\", \"/\", \">\" ], \"XMLNODE\" ],\n                    [  [\"<\", \"IDENT\", \"IDENT\", \"=\", \"\\\"\", \"WILDCARD\", \"\\\"\" ], \"OPENTAGSTART\" ],\n                    /* Some recursive self-nesting here */\n                    [  [\"OPENTAGSTART\", \"IDENT\", \"=\", \"\\\"\", \"WILDCARD\", \"\\\"\" ], \"OPENTAGSTART\" ],\n                    [  [\"OPENTAGSTART\", \">\"], \"OPENTAG\" ],\n                    // can't have two identifiers in a row, unless we're between an opening and closing tag\n                    // a/k/a node.text\n                    [  [\"IDENT\", \"IDENT\" ], \"NODETEXT\" ],\n                    [  [\"IDENT\", \"NODETEXT\" ], \"NODETEXT\" ],\n                    [  [\"NODETEXT\", \"NODETEXT\" ], \"NODETEXT\" ],\n                    // let's also have nested nodes engulfed in the NODETEXT\n                    [  [\"XMLNODE\", \"NODETEXT\" ], \"NODETEXT\" ],\n                    [  [\"XMLNODES\", \"NODETEXT\" ], \"NODETEXT\" ],\n                    [  [\"NODETEXT\", \"XMLNODE\" ], \"NODETEXT\" ],\n                    [  [\"NODETEXT\", \"XMLNODES\" ], \"NODETEXT\" ],\n                    [  [\"OPENTAG\", \"CLOSETAG\" ], \"XMLNODE\" ],\n                    [  [\"OPENTAG\", \"NODETEXT\", \"CLOSETAG\" ], \"XMLNODE\" ],\n                    [  [\"OPENTAG\", \"XMLNODE\", \"CLOSETAG\" ], \"XMLNODE\" ],\n                    [  [\"XMLNODE\", \"XMLNODE\" ], \"XMLNODES\" ],\n                    [  [\"OPENTAG\", \"XMLNODES\", \"CLOSETAG\" ], \"XMLNODE\" ]\n                ];\n\n                let IGNORE = true;\n\n                let tokenDefinitions = [\n                    [  /\\s+/, \"\", IGNORE ],\n                    [  /<!--/, 'OPENCOMMENT' ],\n                    [  /-->/, 'CLOSECOMMENT' ],\n                    [  /\\//, \"/\" ],\n                    [  />/, \">\" ],\n                    [  /</, \"<\" ],\n                    [  /=/, \"=\" ],\n                    [  /\"/, '\"' ],\n                    [  /'/, '\"' ],\n                    [  /[-+]?[0-9]*\\.?[0-9]+/, \"NUM_LIT\" ],\n                    [  /[a-zA-Z]+[a-zA-Z0-9-]*/, \"IDENT\" ],\n                    // having trapped all these things, what's left is nodetext\n                    [ /[^<]+/, \"NODETEXT\"]\n                ];\n\n                makeEvaluatorAndInitialize( new XMLius( tokenDefinitions, grammarObject ),\n                `<div class=\"hintwrapper\"><div class=\"hint\">Click operators to expand or collapse. Click leaf nodes to toggle true/false.</div><div class=\"styled-select green semi-square\" style=\"bold\"></div></div>`,\n                \"Mouseover nodes to see attributes. Click nodetext to see content.\");\n            }\n        }\n    }\n\n    function makeEvaluatorAndInitialize( newEvaluator, statement, hintText ){\n        assignEvaluator( newEvaluator );\n        d3.select('#statement').node().value = statement;\n        d3.select('div.hint').text( hintText );\n        evaluateStatement();\n    }\n\n    function assignEvaluator( newEvaluator ) {\n        // don't change if the user wants what they already have\n        if( evaluator && newEvaluator.constructor.name == evaluator.constructor.name ) return;\n        evaluator = newEvaluator;\n    }\n\nvar evaluator;\n\n\n\nvar winHeight = Math.max( 600, window.innerHeight );\nvar winWidth = Math.max( 1000, window.innerWidth );\n\nvar m = [0, 120, 140, 120],\n    w = winWidth - m[1] - m[3],\n    h = winHeight - m[0] - m[2],\n    i = 0,\n    root;\n\nvar tree = d3.layout.tree()\n    .size([h, w]);\n\nvar diagonal = d3.svg.diagonal()\n    .projection(function(d) { return [d.y, d.x]; });\n\nvar vis = d3.select(\"#body\").append(\"svg:svg\")\n    .attr(\"width\", w + m[1] + m[3])\n    .attr(\"height\", h + m[0] + m[2])\n  .append(\"svg:g\")\n    .attr(\"transform\", \"translate(\" + m[3] + \",\" + m[0] + \")\");\n\nvis.append(\"text\")\n\t.attr(\"opacity\", 1)\n    .attr(\"y\", 246)\n    .attr(\"dy\", \"1.71em\")\n    .style(\"font-size\",\"34px\")\n    .style(\"text-anchor\", \"end\")\n    .attr(\"id\", \"result\")\n    .text(\"\");\n\n\n\nd3.select(\"#testbutton\").on(\"click\", function(e) {\n\tevaluateStatement();\n});\n\nd3.select(\"#statement\").on(\"keyup\", function(){\n    if(d3.event.keyCode == 13){\n        d3.select(\"#testbutton\").on(\"click\")();\n    }\n});\n\nvar parseTree;\n\nfunction evaluateStatement()\n{\n    var statement = d3.select(\"#statement\").node().value;\n\tparseTree = evaluator.parse( statement );\n\tdisplayJSON( parseTree );\n};\n\nfunction displayJSON( json )\n{\n  root = json;\n  root.x0 = h / 2;\n  root.y0 = 0;\n  //d3.select(\"#statement\").val( root.title );\n  d3.select(\"#statement\").property(\"value\", root.expressionString);\n\n  d3.select(\"#result\")\n  .text( root.value )\n\n  function toggleAll(d, delay ) {\n\n  \tif( ! delay ) delay = 1;\n\n    if (d.children) {\n\t\ttoggle(d);\n    }\n\n    if (d._children) {\n\t\ttoggle(d);\n    }\n  }\n  // Initialize the display to show all nodes.\n  root.children.forEach(toggleAll, 444);\n\n  update(root);\n};\n\n// Toggle children.\nfunction toggle(d, showOverlay) {\n\tif( d == undefined ) return;\n    //boolean\n    if( d.value === true  || d.value === false )\n    {\n        if (d.children) {\n        // hide the children by moving them into _children\n            d._children = d.children;\n            d.children = null;\n        } else {\n        // bring back the hidden children\n            d.children = d._children;\n            d._children = null;\n        }\n\n        var hasNoChildren = !d.children && !d._children;\n        if( !hasNoChildren )\n        {\n            // has an array in d.children or d._children\n            // but it might be empty!\n\n            if ( d.children && d.children.length == 0 ) hasNoChildren = true;\n            if ( d._children && d._children.length == 0 ) hasNoChildren = true;\n        }\n        if( hasNoChildren ) // it's a leaf\n        {\n            // toggle true/false\n            if( ( d.value === true ) || (d.value === false ) )\n            {\n                d.value = !d.value;\n                //var myInt = parseInt( d.name );\n                //conditionTruthValues[ myInt ] = d.value;\n                var myVar = d.name;\n                evaluator.state[ myVar ] = d.value;\n                updateWithoutDeleting(root);\n            }\n        }\n    }\n    else // you clicked something that isn't in a boolean flow\n    {\n        if( showOverlay )\n        {\n            var attributeText = d.attributes ? JSON.stringify( d.attributes ) : \"None\";\n            if( ! d.children && !d._children) // it's a leaf\n            {\n                //showValueOverlay( d.value );\n\n                showValueOverlay( \"Attributes: \" + attributeText + \"</br>Content: \" + d.value );\n            }\n            else//oops, we wanted to collapse this thing\n            {\n                //showValueOverlay( \"Attributes: \" + attributeText + \"</br>Content: \" + d.value );\n                if (d.children) {\n                // hide the children by moving them into _children\n                    d._children = d.children;\n                    d.children = null;\n                } else {\n                // bring back the hidden children\n                    d.children = d._children;\n                    d._children = null;\n                }\n            }\n        }\n    }\n}\n\nfunction showValueOverlay( val ){\n    $('#valueModalText').html( val );\n    $('#valueModal').modal('show');\n}\n\nfunction updateWithoutDeleting()\n{\n    parseTree = evaluator.evaluateParseTree();\n    updateObjectAndItsChildren( parseTree, root );\n\n\td3.select(\"#result\")\n\t\t.text( root.value )\n}\n\nfunction updateObjectAndItsChildren( newObjectTemp, rootTemp )\n{\n\n    rootTemp.value = newObjectTemp.value;\n    if( ! newObjectTemp.children ) return;\n    for( var i = 0; i < newObjectTemp.children.length; i++ )\n    {\n        if( rootTemp.children )\n        {\n            updateObjectAndItsChildren( newObjectTemp.children[ i ], rootTemp.children[ i ] );\n        }\n        else\n        {\n        \tif( rootTemp._children )\n        \t{\n            \tupdateObjectAndItsChildren( newObjectTemp.children[ i ], rootTemp._children[ i ] );\n            }\n        }\n\n    }\n}\n\n\n\nfunction update(source) {\n  var duration = d3.event && d3.event.altKey ? 5000 : 500;\n\n  // Compute the new tree layout.\n  var nodes = tree.nodes(root).reverse();\n\n\n\n  // Normalize for fixed-depth.\n  // OK -- why is d.y correlated with the horizontal position here???\n\n  widthPerNode = 110;\n  var body = d3.select(\"body\");\n  var svg = body.select(\"svg\");\n  var widthInPixels = svg.style(\"width\").replace(\"px\", \"\");\n  widthInPixels = parseInt( widthInPixels );\n  var widthPerNode = widthInPixels / nodes.length;\n  nodes.forEach(function(d) { d.y = d.depth * widthPerNode; });\n\n  d3.select(\"#result\")\n  .transition()\n  .duration(duration)\n  .attr(\"x\", nodes[nodes.length -1 ].y - 40 )\n  .attr(\"y\", function(d){ return nodes[nodes.length -1 ].x - 48 } )\n\n  // Update the nodes\n  var node = vis.selectAll(\"g.node\")\n      .data(nodes, function(d) { return d.id || (d.id = ++i); });\n\n  // Enter any new nodes at the parent's previous position.\n  var nodeEnter = node.enter().append(\"svg:g\")\n      .attr(\"class\", \"node\")\n      .attr(\"transform\", function(d) { return \"translate(\" + source.y0 + \",\" + source.x0 + \")\"; })\n      .on(\"click\", function(d) { toggle(d, true ); update(d); })\n      .on(\"mouseover\", function(d){\n            var attributeText = d.attributes ? JSON.stringify( d.attributes ) : \"\";\n            if( attributeText.length > 0 )\n            {\n                showValueOverlay( \"Attributes: \" + attributeText + \"</br>Content: \" + d.value );\n            }\n\n      });\n\n  nodeEnter.append(\"svg:circle\")\n      .attr(\"r\", 1e-6)\n      .style(\"stroke\", function(d){ return d.value ? \"green\" : \"red\" } )\n      .style(\"fill\", function(d) { return d._children ? \"grey\" : \"#fff\"; });\n\n  nodeEnter.append(\"svg:text\")\n      .attr(\"x\", function(d) { return d.children || d._children ? -1 : 17; })\n      .attr(\"y\", function(d) { return d.children || d._children ? 18 : -1; })\n      .attr(\"dy\", \".35em\")\n      .attr(\"text-anchor\", function(d) { return d.children || d._children ? \"middle\" : \"left\"; })\n//      .attr(\"text-anchor\", function(d) { return d.children || d._children ? \"end\" : \"start\"; })\n      .text(function(d) { return d.name; })\n      .style(\"fill-opacity\", 1e-6);\n\n  // Transition nodes to their new position.\n  var nodeUpdate = node.transition()\n      .duration(duration)\n      .style(\"stroke\", function(d){ return d.value ? \"green\" : \"red\";  } )\n      .attr(\"transform\", function(d) { return \"translate(\" + d.y + \",\" + d.x + \")\"; });\n\n  nodeUpdate.select(\"circle\")\n      .attr(\"r\", 8.5)\n      .style(\"stroke\", function(d){ return d.value ? \"green\" : \"red\" } )\n      .style(\"fill\", function(d) { return d._children ? \"lightsteelblue\" : \"#fff\"; });\n\n  nodeUpdate.select(\"text\")\n      .style(\"fill-opacity\", 1);\n\n  // Transition exiting nodes to the parent's new position.\n  var nodeExit = node.exit().transition()\n      .duration(duration)\n      .attr(\"transform\", function(d) { return \"translate(\" + source.y + \",\" + source.x + \")\"; })\n      .remove();\n\n  nodeExit.select(\"circle\")\n      .attr(\"r\", 1e-6);\n\n  nodeExit.select(\"text\")\n      .style(\"fill-opacity\", 1e-6);\n\n  // Update the links\n  var link = vis.selectAll(\"path.link\")\n      .data(tree.links(nodes), function(d) { return d.target.id; });\n\n  // Enter any new links at the parent's previous position.\n  link.enter().insert(\"svg:path\", \"g\")\n      .attr(\"class\", \"link\")\n      .attr(\"d\", function(d) {\n        var o = {x: source.x0, y: source.y0};\n        return diagonal({source: o, target: o});\n      })\n    .transition()\n      .duration(duration)\n      .attr(\"d\", diagonal);\n\n  // Transition links to their new position.\n  link.transition()\n      .duration(duration)\n      .attr(\"d\", diagonal);\n\n  // Transition exiting nodes to the parent's new position.\n  link.exit().transition()\n      .duration(duration)\n      .attr(\"d\", function(d) {\n        var o = {x: source.x, y: source.y};\n        return diagonal({source: o, target: o});\n      })\n      .remove();\n\n  // Stash the old positions for transition.\n  nodes.forEach(function(d) {\n    d.x0 = d.x;\n    d.y0 = d.y;\n  });\n}\n\nchangeMode(\"boolean\");\nevaluateStatement();\n};\n\n\n// WEBPACK FOOTER //\n// ./js/visualizer.js","\nclass BooleanJSONVisitor{\n  constructor( state ){\n    this.state = state;\n  }\n  setState( newstate ){\n    this.state = newstate;\n  }\n\n  execute( thingToEvaluate )\n  {\n        var ob = {};\n        ob.name = thingToEvaluate.type;\n        ob.value = thingToEvaluate.value = this.getBoolean( thingToEvaluate );\n        let symbolsMatched = thingToEvaluate.seriesOfSymbolsIAbsorbedAndReplaced;\n\n        switch( thingToEvaluate.type )\n        {\n            case \"TOKEN\":\n                return { name : thingToEvaluate.stringIActuallyMatched, value: this.getBoolean( thingToEvaluate ), condition: \"Condition Text Goes Here\" };\n            case \"BOOLEAN\":\n\n                ob.children = [];\n                if( symbolsMatched.length == 3 ) // there's a binary operator\n                {\n\n                  // either a binary operator or \"(\" + boolean + \")\"\n                  if( ( symbolsMatched[0].type == \"(\") && ( symbolsMatched[2].type == \")\") )\n                  {\n                    // we'll pass it through transparently\n                    // in other words, allow our middle child to represent us completely\n                    // since the user isn't interested in seeing each \"(\" represented with its own node onscreen\n                    return this.execute( symbolsMatched[ 1 ] );\n                  }\n                  else\n                  {\n                    ob.name = this.getNameForOperator( symbolsMatched[ 1 ].type );\n                    ob.children.push( this.execute( symbolsMatched[ 0 ]) );\n                    ob.children.push( this.execute( symbolsMatched[ 2 ]) );\n                  }\n                  \n                }\n                else if( symbolsMatched.length == 2 ) // there's a unary operator\n                {\n                  // the only unary operator\n                  ob.name = this.getNameForOperator( symbolsMatched[ 0 ].type ); \n                  ob.children.push( this.execute( symbolsMatched[ 1 ]) );\n                }\n                else\n                {\n                  return this.execute( symbolsMatched[ 0 ]);\n                }\n\n                break;\n\n            case \"IDENT\": // basically a passthrough. Assume our first child is a real operator, and return *its* json.\n                ob.name = thingToEvaluate._stringIMatched;\n        }\n        return ob;\n  }\n\n  getBoolean( nonterminalOrToken ){\n\n    if(nonterminalOrToken.constructor.name == \"Nonterminal\" )\n    {\n        let symbolsMatched = nonterminalOrToken.seriesOfSymbolsIAbsorbedAndReplaced;\n        let value = \"FOO\"; // declare this and, hey, initialize it with something we'll notice if there's an error.\n        if( symbolsMatched.length == 1 ) // we're a nonterminal that absorbed one other thing\n        {\n          value = this.getBoolean( symbolsMatched[0] );\n          return value;\n        }\n        else if( symbolsMatched.length == 3 )// we're a boolean comprising an operator and two operands\n        {\n          if( symbolsMatched[1].type == \"|\")\n          {\n            return this.getBoolean( symbolsMatched[0] ) || this.getBoolean( symbolsMatched[2] );\n          }\n          else if( symbolsMatched[1].type == \"&\")\n          {\n            return this.getBoolean( symbolsMatched[0] ) && this.getBoolean( symbolsMatched[2] );\n          }\n          else if( ( symbolsMatched[0].type == \"(\") && ( symbolsMatched[2].type == \")\") )\n          {\n            return this.getBoolean( symbolsMatched[1] );\n          }\n          else\n          {\n            throw new Error(\"DON'T KNOW WHAT THE OPERATOR OF THIS 3-ELEMENT SYMBOLSMATCHED IS:\" + JSON.stringify( symbolsMatched ));\n          }\n        }\n        else if( symbolsMatched.length == 2 )// we're a boolean with one operator -- probably a not\n        {\n          if( symbolsMatched[0].type == \"!\")\n          {\n            return ! this.getBoolean( symbolsMatched[1] );\n          }\n          else\n          {\n            throw new Error(\"DON'T KNOW WHAT THE OPERATOR OF THIS 2-ELEMENT SYMBOLSMATCHED IS:\" + JSON.stringify( symbolsMatched ));\n          }\n        }\n\n        throw new Error(\"UNKNOWN LENGTH OF SYMBOLSMATCHED:\" + JSON.stringify( symbolsMatched ));\n      }\n      else // it's a token\n      {\n        if( nonterminalOrToken.type.toUpperCase().indexOf( \"TRUE\" ) > -1 )\n        {\n          return true;\n        }\n        if( nonterminalOrToken.type.toUpperCase().indexOf( \"FALSE\" ) > -1 )\n        {\n          return false;\n        }\n        if( nonterminalOrToken.type.toUpperCase().indexOf( \"IDENT\" ) > -1 )\n        {\n          return this.state[ nonterminalOrToken._stringIMatched ];\n        }\n\n        throw new Error(\"nonterminalOrToken.type is \" + nonterminalOrToken.type );\n        return null;\n      }\n  }\n\n  getNameForOperator( operatorSymbol ){\n    if( operatorSymbol == \"|\" ) return \"OR\";\n    if( operatorSymbol == \"&\" ) return \"AND\";\n    if( operatorSymbol == \"^\" ) return \"XOR\";\n    if( operatorSymbol == \"!\" ) return \"NOT\";\n  }\n}\n\nmodule.exports = BooleanJSONVisitor;\n\n\n// WEBPACK FOOTER //\n// ./js/visitors/booleanjsonvisitor.js","import EvaluationVisitor from './evaluationvisitor';\n\nclass BooleanVisitor{\n  constructor( state ){\n    this.state = state;\n  }\n  setState( newstate ){\n    this.state = newstate;\n  }\n\n  execute( nonterminalOrToken ){\n    if(nonterminalOrToken.constructor.name == \"Nonterminal\" )\n    {\n        let symbolsMatched = nonterminalOrToken.seriesOfSymbolsIAbsorbedAndReplaced;\n        let value = \"FOO\"; // declare this and, hey, initialize it with something we'll notice if there's an error.\n        if( symbolsMatched.length == 1 ) // we're a nonterminal that absorbed one other thing\n        {\n          value = symbolsMatched[0].visit( this );\n          return value;\n        }\n        else if( symbolsMatched.length == 3 )// we're a boolean comprising an operator and two operands\n        {\n          if( symbolsMatched[1].type == \"|\")\n          {\n            return symbolsMatched[0].visit( this ) || symbolsMatched[2].visit( this );\n          }\n          else if( symbolsMatched[1].type == \"&\")\n          {\n            return symbolsMatched[0].visit( this ) && symbolsMatched[2].visit( this );\n          }\n          else if( ( symbolsMatched[0].type == \"(\") && ( symbolsMatched[2].type == \")\") )\n          {\n            return symbolsMatched[1].visit( this );\n          }\n          else\n          {\n            throw new Error(\"DON'T KNOW WHAT THE OPERATOR OF THIS 3-ELEMENT SYMBOLSMATCHED IS:\" + JSON.stringify( symbolsMatched ));\n          }\n        }\n        else if( symbolsMatched.length == 2 )// we're a boolean with one operator -- probably a not\n        {\n          if( symbolsMatched[0].type == \"!\")\n          {\n            return ! symbolsMatched[1].visit( this );\n          }\n          else\n          {\n            throw new Error(\"DON'T KNOW WHAT THE OPERATOR OF THIS 2-ELEMENT SYMBOLSMATCHED IS:\" + JSON.stringify( symbolsMatched ));\n          }\n        }\n\n\n        throw new Error(\"UNKNOWN LENGTH OF SYMBOLSMATCHED:\" + JSON.stringify( symbolsMatched ));\n      }\n      else // it's a token\n      {\n        if( nonterminalOrToken.type.toUpperCase().indexOf( \"TRUE\" ) > -1 )\n        {\n          return true;\n        }\n        if( nonterminalOrToken.type.toUpperCase().indexOf( \"FALSE\" ) > -1 )\n        {\n          return false;\n        }\n        if( nonterminalOrToken.type.toUpperCase().indexOf( \"IDENT\" ) > -1 )\n        {\n          return this.state[ nonterminalOrToken._stringIMatched ];\n        }\n\n        throw new Error(\"nonterminalOrToken.type is \" + nonterminalOrToken.type );\n        return null;\n      }\n  }\n}\n\nmodule.exports = BooleanVisitor;\n\n\n// WEBPACK FOOTER //\n// ./js/visitors/booleanvisitor.js","\nclass MathJSONVisitor{\n  constructor( state ){\n    this.state = state;\n  }\n  setState( newstate ){\n    this.state = newstate;\n  }\n\n  execute( thingToEvaluate )\n  {\n        var ob = {};\n        ob.name = thingToEvaluate.type;\n        ob.value = thingToEvaluate.value = this.getValue( thingToEvaluate );\n\n        let symbolsMatched = thingToEvaluate.seriesOfSymbolsIAbsorbedAndReplaced;\n\n        switch( thingToEvaluate.type )\n        {\n            case \"NUM_LIT\":\n                return { name : this.getValue( thingToEvaluate ), value: this.getValue( thingToEvaluate ), condition: \"Condition Text Goes Here\" };\n            case \"NUMERIC\":\n\n                ob.children = [];\n                if( symbolsMatched.length == 3 ) // there's a binary operator\n                {\n\n                  // either a binary operator or \"(\" + boolean + \")\"\n                  if( ( symbolsMatched[0].type == \"(\") && ( symbolsMatched[2].type == \")\") )\n                  {\n                    // we'll pass it through transparently\n                    // in other words, allow our middle child to represent us completely\n                    // since the user isn't interested in seeing each \"(\" represented with its own node onscreen\n                    return this.execute( symbolsMatched[ 1 ] );\n                  }\n                  else\n                  {\n                    ob.name = symbolsMatched[ 1 ].type;\n                    ob.children.push( this.execute( symbolsMatched[ 0 ]) );\n                    ob.children.push( this.execute( symbolsMatched[ 2 ]) );\n                  }\n\n                }\n                else if( symbolsMatched.length == 2 ) // there's a unary operator\n                {\n                  // the only unary operator\n                  ob.name = symbolsMatched[ 0 ].type;\n                  ob.children.push( this.execute( symbolsMatched[ 1 ]) );\n                }\n                else\n                {\n                  return this.execute( symbolsMatched[ 0 ]);\n                }\n\n                break;\n\n            case \"IDENT\": // basically a passthrough. Assume our first child is a real operator, and return *its* json.\n                ob.name = thingToEvaluate._stringIMatched;\n        }\n        return ob;\n  }\n\n  getValue( nonterminalOrToken ){\n    if(nonterminalOrToken.constructor.name == \"Nonterminal\" )\n    {\n        let symbolsMatched = nonterminalOrToken.seriesOfSymbolsIAbsorbedAndReplaced;\n        let value = \"FOO\"; // declare this and, hey, initialize it with something we'll notice if there's an error.\n        if( symbolsMatched.length == 1 ) // we're a nonterminal that absorbed one other thing\n        {\n          value = this.getValue( symbolsMatched[0] );\n          return value;\n        }\n        else if( symbolsMatched.length == 3 )// we're a boolean comprising an operator and two operands\n        {\n          // or maybe we're just a numeric wrapped in parens!\n\n          if( ( symbolsMatched[0].type == \"(\") && ( symbolsMatched[2].type == \")\") )\n          {\n            return this.getValue( symbolsMatched[1] );\n          }\n\n          if( symbolsMatched[1].type == \"+\")\n          {\n            return this.getValue( symbolsMatched[0] ) + this.getValue( symbolsMatched[2] );\n          }\n          else if( symbolsMatched[1].type == \"-\")\n          {\n            return this.getValue( symbolsMatched[0] ) - this.getValue( symbolsMatched[2] );\n          }\n          else if( symbolsMatched[1].type == \"*\")\n          {\n            return this.getValue( symbolsMatched[0] ) * this.getValue( symbolsMatched[2] );\n          }\n          else if( symbolsMatched[1].type == \"/\")\n          {\n            return this.getValue( symbolsMatched[0] ) / this.getValue( symbolsMatched[2] );\n          }\n          else if( symbolsMatched[1].type == \"^\")\n          {\n            return Math.pow( this.getValue( symbolsMatched[0] ), this.getValue( symbolsMatched[2] ));\n          }\n          else\n          {\n            throw new Error(\"WE HAVE 3 SYMBOLS BUT I DON'T KNOW WHAT THIS IS:\" + JSON.stringify( symbolsMatched ));\n          }\n        }\n        else if( symbolsMatched.length == 2 )// we're a boolean with one operator\n        {\n          if( symbolsMatched[0].type == \"+\")\n          {\n            return this.getValue( symbolsMatched[1] );\n          }\n          if( symbolsMatched[0].type == \"-\")\n          {\n            return -1 * this.getValue( symbolsMatched[1] );\n          }\n          else\n          {\n            throw new Error(\"IN NUMERICVISITOR, DON'T KNOW WHAT THE OPERATOR OF THIS 2-ELEMENT SYMBOLSMATCHED IS:\" + JSON.stringify( symbolsMatched ));\n          }\n        }\n\n\n        throw new Error(\"UNKNOWN LENGTH OF SYMBOLSMATCHED:\" + JSON.stringify( symbolsMatched ));\n      }\n      else // it's a token\n      {\n        if( nonterminalOrToken.type.toUpperCase().indexOf( \"NUM_LIT\" ) > -1 )\n        {\n          return parseInt( nonterminalOrToken._stringIMatched );\n        }\n        throw new Error(\"nonterminalOrToken.type is \" + nonterminalOrToken.type );\n        return null;\n      }\n  }\n\n  getNameForOperator( operatorSymbol ){\n    if( operatorSymbol == \"|\" ) return \"OR\";\n    if( operatorSymbol == \"&\" ) return \"AND\";\n    if( operatorSymbol == \"^\" ) return \"XOR\";\n    if( operatorSymbol == \"!\" ) return \"NOT\";\n  }\n}\n\nmodule.exports = MathJSONVisitor;\n\n\n// WEBPACK FOOTER //\n// ./js/visitors/mathjsonvisitor.js","import Token from '../token';\n\nclass XMLJSONVisitor{\n  constructor( state ){\n    this.state = state;\n  }\n  setState( newstate ){\n    this.state = newstate;\n  }\n\n  execute( thingToEvaluate )\n  {\n        var ob = {};\n        ob.name = thingToEvaluate.type;\n        ob.value = this.getValue( thingToEvaluate ).trim();\n        let symbolsMatched = thingToEvaluate.symbolsMatched;\n        switch( thingToEvaluate.type )\n        {\n\n            case \"TOKEN\":\n                return { name : thingToEvaluate.stringIActuallyMatched, value: this.getValue( thingToEvaluate ), condition: \"Condition Text Goes Here\" };\n\n            case \"XMLNODES\":\n                ob.name = \"nodelist\";\n                ob.children = [];\n                for( var i = 0; i < symbolsMatched.length; i++ )\n                {\n                  let executedSymbol = this.execute( symbolsMatched[ i ]);\n                  ob.children.push( executedSymbol );\n                }\n                return ob.children;\n                break;\n\n            case \"XMLNODE\":\n\n                this.parentnode = ob;\n                ob.children = [];\n                // opentag is first item, and that gives us our name\n                ob.name = this.getValue( symbolsMatched[ 0 ] );\n                var optionalAttributes = this.getAttributes( symbolsMatched[ 0 ] );\n\n                if( optionalAttributes )\n                {\n                  ob.attributes = optionalAttributes;\n                }\n\n                symbolsMatched = this.consolidateChildrenThatAreTokens( symbolsMatched );\n\n                for( var i = 1; i < symbolsMatched.length - 1; i++ ) // -1, because the last match will be a closetag, which is irrelevant\n                {\n                  let child = this.execute( symbolsMatched[ i ]);\n                  // if a child was a nodelist, then it will return an array of divs.\n                  // we should not push that array as an element onto our array!\n                  // we should concat all its children onto our children (if we have any)\n                  if( Array.isArray( child ) )\n                  {\n                      ob.children = ob.children.concat( child );\n                  }\n                  else\n                  {\n                      ob.children.push( child );\n                  }\n                }\n\n\n                break;\n\n            case \"IDENT\": // basically a passthrough. Assume our first child is a real operator, and return *its* json.\n                ob.name = thingToEvaluate._stringIMatched;\n        }\n        return ob;\n  }\n\n  // good for the wildcard globbing we do inside open and close tags\n  consolidateChildrenThatAreTokens( arrayOfSymbolsThatMightBeTokens ) {\n    let symbolChildrenOnly = [];\n    let runningStringOfTokenText = \"\";\n    for( var symbol of arrayOfSymbolsThatMightBeTokens ){\n      if( symbol.constructor.name != \"Token\" )\n      {\n        if( runningStringOfTokenText.length > 0 ) // we've been building up a text string!\n        {\n          let tokenConsolidatingStrings = this.makeTokenWrappingString( runningStringOfTokenText );\n          symbolChildrenOnly.push( tokenConsolidatingStrings );\n          runningStringOfTokenText = \"\";\n          symbolChildrenOnly.push( symbol );\n        }\n        else\n        {\n          symbolChildrenOnly.push( symbol );\n        }\n      }\n      else // it's a token!\n      {\n\n         runningStringOfTokenText += symbol._stringIMatched;\n\n      }\n    }\n\n    if( runningStringOfTokenText.length > 0 )\n    {\n      let tokenConsolidatingStrings = this.makeTokenWrappingString( runningStringOfTokenText );\n      symbolChildrenOnly.push( tokenConsolidatingStrings );\n    }\n\n    return symbolChildrenOnly;\n  }\n\n  makeTokenWrappingString( stringToWrap ){\n    let newSymbol = new Token( /.+/, \"TEXTNODE\", stringToWrap.length, stringToWrap );\n    return newSymbol;\n  }\n\n  // sent either an opentag or an opentagstart\n  getAttributes( childOfXMLNode ) {\n\n    if( childOfXMLNode.type == \"OPENTAGSTART\" )\n    {\n      // could be nested\n      // or could be <, IDENT, IDENT, =, ', WILDCARD, '\n      // or could be <, IDENT, IDENT, =, ', IDENT, '\n      // or could be <, IDENT, IDENT, =, ', IDENT, IDENT, '\n      let atts = {};\n      if( childOfXMLNode.symbolsMatched[0].constructor.name == \"Token\" ) // could only be \"<\"\n      {\n        let name = this.getValue( childOfXMLNode.symbolsMatched[2] );\n        let valueForName = \"\";\n        for( let attributeValueIndex = 5; attributeValueIndex < childOfXMLNode.symbolsMatched.length - 1; attributeValueIndex++ )\n        {\n          valueForName += this.getValue( childOfXMLNode.symbolsMatched[ attributeValueIndex ] );\n          let notLast = attributeValueIndex < childOfXMLNode.symbolsMatched.length - 2;\n          if( notLast ) valueForName += \" \";\n        }\n        atts[ name ] = valueForName;\n        return atts;\n      }\n      else if(childOfXMLNode.symbolsMatched[0].type == \"OPENTAGSTART\") // nested opentagstarts! multiple attributes\n      {\n        atts = this.getAttributes( childOfXMLNode.symbolsMatched[0] );\n        let name = this.getValue( childOfXMLNode.symbolsMatched[1] );\n        let val = this.getValue( childOfXMLNode.symbolsMatched[4] );\n        atts[ name ] = val;\n        return atts;\n      }\n    }\n    else if(childOfXMLNode.symbolsMatched[0].type == \"OPENTAGSTART\")\n    {\n      let returnAtts = this.getAttributes( childOfXMLNode.symbolsMatched[0] );\n      return returnAtts;\n    }\n    return null;\n  }\n\n  getValue( nonterminalOrToken ){\n    if(nonterminalOrToken.constructor.name == \"Nonterminal\" )\n    {\n        let symbolsMatched = nonterminalOrToken.symbolsMatched;\n\n        let value = \"FOO\"; // declare this and, hey, initialize it with something we'll notice if there's an error.\n\n        if( nonterminalOrToken.type == \"XMLNODE\")\n        {\n          // our first child will be our opentag, which is where our name comes from.\n          let returnVal = this.getValue( symbolsMatched[0] );\n          return returnVal;\n        }\n\n        if( nonterminalOrToken.type == \"XMLNODES\")\n        {\n          let returnVal = \"NODELIST\";\n          return returnVal;\n        }\n\n        if( nonterminalOrToken.type == \"OPENTAG\" || nonterminalOrToken.type == \"OPENTAGSTART\")\n        {\n          var returnVal;\n          // symbolsMatched[1] will either be an IDENT or an OPENTAGSTART (the wrapper for attribute definitions)\n          if( symbolsMatched[0].type == \"OPENTAGSTART\" )\n          {\n            returnVal = this.getValue( symbolsMatched[0] );\n            return returnVal;\n          }\n          returnVal = this.getValue( symbolsMatched[1] );\n          return returnVal;\n        }\n\n        if( nonterminalOrToken.type == \"CLOSETAG\")\n        {\n            return this.getValue( symbolsMatched[2] ); // after < and /\n        }\n\n        if( nonterminalOrToken.type == \"COMMENT\")\n        {\n          let commentstring = \"\";\n          for(var kid of nonterminalOrToken.symbolsMatched )\n          {\n            if( kid.type == \"OPENCOMMENT\" || kid.type == \"CLOSECOMMENT\") continue;\n            commentstring += this.getValue( kid );\n          }\n            return commentstring;\n        }\n\n        if( nonterminalOrToken.type == \"NODETEXT\")\n        {\n          let contentstring = \"\";\n          for(var kid of nonterminalOrToken.symbolsMatched )\n          {\n            if( ( kid.type == \"NODETEXT\" )  || ( kid.type == \"IDENT\" )  )\n              // IDENT generally means it was preceded and/or followed by some kind of whitespace\n              // so we should restore that delimiter\n              if( kid.type == \"IDENT\" )\n              {\n                contentstring += \" \" + this.getValue( kid );\n              }\n              else\n              {\n                contentstring += this.getValue( kid );\n              }\n          }\n          return contentstring;\n        }\n\n        throw new Error(\"XMLJSONVISITOR UNKNOWN LENGTH OF SYMBOLSMATCHED for \" + nonterminalOrToken.type + \":\" + JSON.stringify( symbolsMatched ));\n      }\n      else // it's a token\n      {\n        if( nonterminalOrToken.type.toUpperCase().indexOf( \"TRUE\" ) > -1 )\n        {\n          return true;\n        }\n        if( nonterminalOrToken.type.toUpperCase().indexOf( \"TEXTNODE\" ) > -1 )\n        {\n          return nonterminalOrToken._stringIMatched;\n        }\n        if( nonterminalOrToken.type.toUpperCase().indexOf( \"IDENT\" ) > -1 )\n        {\n          return nonterminalOrToken._stringIMatched;\n        }\n        return nonterminalOrToken._stringIMatched;\n//        throw new Error(\"nonterminalOrToken.type is \" + nonterminalOrToken.type );\n//        return null;\n      }\n  }\n}\n\nmodule.exports = XMLJSONVisitor;\n\n\n// WEBPACK FOOTER //\n// ./js/visitors/xmljsonvisitor.js","\nclass XMLParseTimeVisitor{\n  constructor( state ){\n    this.state = state;\n  }\n  setState( newstate ){\n    this.state = newstate;\n  }\n\n  execute( nonterm )\n  {\n\n    if( nonterm.type == \"XMLNODE\")\n    {\n      return this.verifyOpeningAndCloseTagsMatch( nonterm ) && this.verifyTagContentIsLegal( nonterm );\n    }\n    else if( nonterm.type == \"OPENTAG\")\n    {\n      return this.verifyAttributeContentIsLegal( nonterm );\n    }\n    else return true;\n  }\n\n  verifyOpeningAndCloseTagsMatch( thingToEvaluate ) {\n      \n      \n      let openTagName   = this.getTagName( thingToEvaluate.symbolsMatched[ 0 ] );\n       let closeTagName;\n      if( thingToEvaluate.symbolsMatched.length == 2 )\n      {\n        closeTagName = this.getTagName( thingToEvaluate.symbolsMatched[ 1 ] );\n      }\n      else if( thingToEvaluate.symbolsMatched.length > 2 )\n      {\n        closeTagName  = this.getTagName( thingToEvaluate.symbolsMatched[ thingToEvaluate.symbolsMatched.length - 1] );\n      }\n      \n      return openTagName == closeTagName;\n  }\n\n  verifyAttributeContentIsLegal( nonterm ){\n    // remember that OPENTAG can contain optional OPENTAGSTART nodes\n    // each of which can enclose other OPENTAGSTART nodes in perpetuity\n    return true;\n  }\n\n  verifyTagContentIsLegal( thingToEvaluate ){\n    return true;\n  }\n\n\n  getTagName( thingToEvaluate ){\n\n\n    while( thingToEvaluate.type != \"IDENT\" )\n    {\n      \n      if( thingToEvaluate.type == \"OPENTAG\")\n      {\n        if( thingToEvaluate.symbolsMatched)\n        {\n          if(  thingToEvaluate.symbolsMatched[0].type == \"<\")\n          {\n            \n            return thingToEvaluate.symbolsMatched[1]._stringIMatched;\n          }\n        }\n      }\n      else if( thingToEvaluate.type == \"CLOSETAG\")\n      {\n        \n        if( thingToEvaluate.symbolsMatched)\n        {\n          if(  thingToEvaluate.symbolsMatched[0].type == \"<\")\n          {\n            // element [1] will be \"/\" so we'll skip to [2]\n            \n            return thingToEvaluate.symbolsMatched[2]._stringIMatched;\n          }\n        }\n      }\n      else if( thingToEvaluate.type == \"OPENTAGSTART\")\n      {\n        \n        if( thingToEvaluate.symbolsMatched)\n        {\n          if(  thingToEvaluate.symbolsMatched[0].type == \"<\")\n          {\n            return thingToEvaluate.symbolsMatched[1]._stringIMatched;\n          }\n        }\n      }\n      thingToEvaluate = thingToEvaluate.symbolsMatched[0]\n    }\n    return thingToEvaluate._stringIMatched;\n    }\n}\n\n\n\nmodule.exports = XMLParseTimeVisitor;\n\n\n// WEBPACK FOOTER //\n// ./js/visitors/xmlparsetimevisitor.js"],"sourceRoot":""}